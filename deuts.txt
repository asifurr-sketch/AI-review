# **Metadata**

**Category:** - Coding

**GitHub URL:** - https://github.com/NOI-gen/duets_in_the_greenhouse

**Topic:** - Competitive Programming

**Subtopic:** - ["Sorting Algorithms", "Hash Tables", "Arrays and Lists", "Basic Data Structures", "Control Structures and Loops", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 4, $O\big((N \cdot T)^2\big) \rightarrow O\big((N \cdot T)\log(N \cdot T)\big) \rightarrow O(N \cdot T) \rightarrow O\big((N \cdot T)\log(N \cdot T)\big)$


**Number of Chains:** - 10

---

**[User]**

*Demark the start of the User's activity*

---

# **Duets in the Greenhouse**

**Time Limit:** **1 second**

**Memory Limit:** **32 MB**

Within the labyrinthine enclave of a bioluminescent conservatory, a cohort of $N$ ethereal pollinators, each adorned with a cryptic sigil, is scrutinized across $T$ temporal shards.
In each shard, these enigmatic entities either retreat into a state of mute resonance (denoted by the null cipher, $0$) or project a spectral frequency code—a positive integer woven into the aether.

Each non-null frequency code manifests as a singular *canticle*, a harmonic phenomenon bound by the following arcane edicts:

* A canticle persists through an unbroken continuum of temporal shards; its essence may never be fractured by silence or resurgence.
* Its chorus is sustained by a fixed coterie of either one (a *soliloquy*) or two (a *dyadic hymn*) pollinators, their sigils eternally bound to the canticle’s duration.
* No canticle may be intoned by a triad or greater assembly in any shard, lest the harmonic fabric unravel.

Your task is to divine whether the conservatory's chronicle aligns with these mystic tenets.
If the chronicle is sound, unveil the count of *dyadic hymns* (codes chanted by exactly two pollinators).
If the chronicle is tainted by discord, proclaim the verdict of $-1$.

---

### **Input Format:**

* The first line bears two integers $N$ and $T$, the number of sigil-bearing pollinators and temporal shards, respectively.
* The next $T$ lines each encode $N$ integers, representing the conservatory's chronicle:

  * For shard $t$ and pollinator $i$, a value of $0$ signifies mute resonance, while a positive integer denotes a frequency code projected into the aether.

---

### **Output Format:**

* Emit a solitary integer — the tally of *dyadic hymns* if the chronicle is harmonious; otherwise, inscribe $-1$.

---

### **Constraints:**

* $(1 \le N, T)$
* $(N \cdot T \le 2 \cdot 10^6)$
* $(0 \le \text{code} \le 10^9)$
* In any single shard, no frequency code may be intoned by more than two pollinators; otherwise, the chronicle is deemed dissonant.

---

### **Examples:**

**Input:**

```
2 5
9 9
9 9
0 0
0 0
9 9
```

**Output:**

```
-1
```

---

**Input:**

```
1 3
1000000000
1000000000
1000000000
```

**Output:**

```
0
```

---

### **Exegesis of Examples:**

In the first chronicle, two pollinators weave frequency code $9$ through shards $1$–$2$, then lapse into silence across shards $3$–$4$, only to resurrect the same code $9$ in shard $5$.
The mystic edict demands that a canticle's essence endure through a single, unbroken continuum; its resurgence after silence rends the harmonic fabric, rendering the chronicle dissonant, thus yielding $-1$.

In the second chronicle, a lone pollinator intones frequency code $10^9$ across all three shards, forming a single *soliloquy* (a canticle with one emitter).
The chronicle is harmonious, yet no *dyadic hymns* (codes with exactly two emitters) exist, so the tally is $0$.

---

### **Additional Arcana:**

* The null cipher ($0$) signifies mute resonance and does not kindle a canticle.
* Each positive frequency code corresponds to exactly one canticle, defined by:

  * A singular, unbroken continuum of shards.
  * A fixed coterie of one (*soliloquy*) or two (*dyadic hymn*) pollinators.
  * Never more than two emitters in any shard; otherwise the chronicle is invalid.
* For a *dyadic hymn*, both pollinators must intone the code in every shard of the canticle’s continuum; the absence of either in any shard disrupts the harmony, invalidating the chronicle.
* The output counts distinct *dyadic hymn* codes, not the shards where dual emissions occur.
* A single pair of pollinators may weave multiple *dyadic hymns* using distinct codes at different continua, each counted once.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

This section clarifies the rules and the goal of the verification task.

**[THOUGHT_01_01]**

We are given a grid of size $T \times N$ where $T$ is the number of frames and $N$ is the number of pollinators. Each cell holds a non-negative integer: $0$ means silent, and a positive integer is a frequency code. We must verify if these observations could arise from songs where each positive code corresponds to exactly one contiguous activity interval and a fixed emitter set of size either $1$ (solo) or $2$ (duet).

**[THOUGHT_01_02]**

To examine what rules must be enforced, let me consider the problem statement carefully. Looking at the per-frame constraint, a given code may appear at most twice in any single frame. Examining the participant consistency requirement, throughout the entire active interval of a code, the exact set of emitters must remain constant and have size either  $1$  or  $2$ . Considering the temporal structure, the frames in which a given code appears must form a single contiguous interval, meaning once a code disappears it cannot reappear later. All three conditions must hold simultaneously.

**[THOUGHT_01_03]**

Rather than restating the goal, formalize the constraints: for any positive code $x$, define $A_x = \{\, t \in [0, T-1] : \exists i \text{ with } \text{grid}[t][i] = x \,\}$. Validity requires $A_x$ to equal a single interval $[L_x, R_x]$ and a fixed emitter set $E_x \subseteq \{1,\dots,N\}$ with $|E_x| \in \{1,2\}$ such that for every $t \in [L_x, R_x]$ precisely the indices in $E_x$ emit $x$. The quantity of interest is the count of codes with $|E_x| = 2$ after validity is established.

**[THOUGHT_01_04]**

The input bounds are $1 \le N, T$ with $N \cdot T \le 2 \cdot 10^6$.

---

**[CHAIN_02]**

This section executes test cases step-by-step to verify compliance with the stated rules and to illustrate violations.

**[THOUGHT_02_01]**

Consider a basic valid scenario: input with $N=2, T=3$ where all values are $0$. Frame 1: $[0, 0]$, Frame 2: $[0, 0]$, Frame 3: $[0, 0]$. No positive codes appear, so no songs exist; the log is valid and the duet count is $0$.

**[THOUGHT_02_02]**

Testing per-frame violations with $N=3, T=1$: input $[9, 9, 9]$. In the single frame, code $9$ appears three times (participants $(1, 2, 3)$). This violates the rule that a code may be emitted by at most two pollinators in any frame; the log is invalid and the output is $-1$.

**[THOUGHT_02_03]**

Examining participant consistency with $N=2, T=2$: input Frame 1: $[5, 0]$, Frame 2: $[0, 5]$. Code $5$ is emitted by participant $1$ in the first frame and by participant $2$ in the second. The participant set changes, violating the fixed-participants rule; the log is invalid and the output is $-1$.

**[THOUGHT_02_04]**

Testing contiguity with $N=1, T=3$: input Frame 1: $[7]$, Frame 2: $[0]$, Frame 3: $[7]$. Code $7$ appears in Frame $1$, disappears in Frame $2$, and reappears in Frame $3$; this breaks contiguity, so the log is invalid and the output is $-1$.

**[THOUGHT_02_05]**

Boundary case with large values: input $N=1, T=1$ with value $[1000000000]$. This forms a solo (one emitter, no duet). No rules are violated; since there are no duets, the output is $0$.

---

**[CHAIN_03]**

This section implements a brute-force solution and analyzes it without presupposing the outcome.

**[THOUGHT_03_01]**

A brute-force approach involves, for every distinct positive code, scanning the entire grid to collect all its occurrences. After collecting these, it would verify the three rules: checking counts per frame, comparing participant sets across frames, and ensuring the set of frames with appearances is contiguous. This requires building a presence list across all $T$ frames and counting occurrences per frame by scanning all $N$ columns for each code.

**[THOUGHT_03_02]**

Let $M = N \cdot T$. If we traverse the entire grid for each distinct code $D$, we face $O(D \cdot M)$ time in the worst case. Since $D$ can be $O(M)$ when many codes are unique, analyzing this complexity shows it degenerates to $O(M^2)$. For $M \le 2 \cdot 10^6$, this would require up to $4 \cdot 10^{12}$ operations, which exceeds practical time limits.

**[THOUGHT_03_03]**

Re-scanning without extra storage minimizes memory but keeps time at  $Θ(D⋅M)$ . Precomputing per-frame counts (code → count per frame) allows  $O(1)$  lookups when validating a specific code, yet we still must iterate relevant frames for each code, so the time remains  $Θ(D⋅T+K)$  with  K  non-zero entries. The memory for all per-frame count entries totals  $Θ(K)$ ; at  $K \approx 2 \times 10^6$  and, on 64-bit systems, a realistic per-entry footprint for $(key, count)$ in a hashed structure (including buckets/pointers and allocator overhead) is typically on the order of tens of bytes (e.g., $\approx 24\text{–}48+$ bytes). Thus caching does not improve the asymptotic time and risks exceeding tight memory budgets.

**[THOUGHT_03_04]**

Attempting to salvage per-code rescans by caching per-code presence bitsets is still infeasible under the limits: storing, for each distinct code, a $T$-bit vector of frame presence costs $D\cdot T$ bits. In worst case $D = \Theta(M)$ and $T = \Theta(M)$, yielding $\Theta(M^2)$ bits; for $M = 2\cdot 10^6$ this is $\approx 4\cdot 10^{12}$ bits $\approx 500$ GB, far beyond the $32$ MB budget. Thus designs that rely on per-code global presence structures to avoid rescans are ruled out by memory, not just time.

---

**[CHAIN_04]**

This section outlines an approach that aggregates all occurrences per code before validation, and examines memory and overhead considerations.

**[THOUGHT_04_01]**

This method consists of a single pass over the grid to build a dictionary mapping each code to a vector of its occurrences (as $(t, i)$ pairs). After reading all data, each vector is sorted by $(t, i)$. Validation per code then involves scanning its timeline to check for at most two occurrences per frame, fixed participants over consecutive frames, and contiguity by detecting gaps in $t$. This consolidates all occurrences before validation.

**[THOUGHT_04_02]**

The total number of stored pairs is $K$, the count of non-zero cells, with $K \le M$. Sorting all vectors across all codes is bounded by sorting $K$ items overall, i.e., $O(K \log K)$. The validation pass per code is linear in the size of each vector, summing to $O(K)$. Quantitatively, with $K \le 2\cdot 10^6$ and $\log_2 K \approx 21$, the dominant work is on the order of $\approx 4.2\cdot 10^7$ comparisons plus linear scans, which is consistent with the time limit on typical hardware; thus the time budget is acceptable.

**[THOUGHT_04_03]**

Quantitatively, storing occurrences per code costs payload plus container overhead. Each occurrence $(t,i)$ fits in two 32-bit integers $\Rightarrow$ 8 bytes; with $K \le 2\cdot 10^6$, payload $\approx 16$ MB. Each vector typically has three size_t fields (data pointer, size, capacity), $\approx 24$ bytes of header. With $D$ vectors, header overhead alone $\approx 24\cdot D$ bytes; when $D$ is large (e.g., $D \approx 1.5\cdot 10^6$ with many singleton codes), this is $\approx 36$ MB. An unordered_map adds node and bucket overhead (tens of bytes per entry plus a bucket array), pushing the total well beyond 32 MB in adversarial distributions, even before accounting for allocator fragmentation.

**[THOUGHT_04_04]**

Per-code post-processing complicates bookkeeping for the per-frame limit and encourages multiple small sorts. Each code's vector must be sorted independently, then scanned with logic to group consecutive frames and validate participants. Examining these complexities motivates seeking a streaming per-frame method that uses only transient per-frame buffers and a single global state per code, thus improving locality and lowering allocator churn.

**[THOUGHT_04_05]**

Given $K$ up to $2\cdot 10^6$, even moderate $D$ drives overhead above the 32 MB budget (e.g., payload $\sim$16 MB + vector headers $\ge 24\cdot D$ + hash buckets/nodes). Therefore, despite acceptable $O(K \log K)$ time, retaining all occurrences is precarious under the stated memory limit; a streaming design that avoids storing $K$ items concurrently is the robust choice.

---

**[CHAIN_05]**

This section describes an approach that tracks participants without enforcing contiguity, and examines its correctness properties.

**[THOUGHT_05_01]**

This strategy processes the input frame by frame, computing the set of emitters for each code and ensuring no code appears more than twice in that frame. It maintains a global dictionary mapping each code to its fixed set of participants. On each appearance, it requires the current participants to match the recorded set, thereby enforcing the per-frame limit and fixed participants.

**[THOUGHT_05_02]**

Contiguity is not enforced in this approach. If a code appears in frame $t$, vanishes in frame $t+1$, and reappears in frame $t+2$ with the same participants, this approach would accept it, but the rules require a single continuous interval of activity.

**[THOUGHT_05_03]**

Consider a scenario where Frame $1$ has code $5$ at index $1$, Frame $2$ has no code $5$, and Frame $3$ has code $5$ again at index $1$. The participant set is consistent throughout, but there is a gap in Frame $2$. Examining the rules shows this must be rejected due to non-contiguity. This attempt would wrongly accept it because it only checks participant consistency without tracking frame adjacency.

**[THOUGHT_05_04]**

With a per-frame hash aggregation, time is $O(\sum_t K_t)$ for building per-frame maps plus hash operations, and space is $O(D)$ globally plus $O(K_t)$ transiently. Although efficient in terms of complexity, analyzing this approach reveals it fails correctness due to not tracking temporal contiguity. Augmenting it with time-aware state to record the last frame where each code appeared would enable contiguity enforcement by checking frame adjacency on each reappearance.

---

**[CHAIN_06]**

This section details an approach that enforces contiguity by tracking the last-seen frame while streaming per frame.

**[THOUGHT_06_01]**

To enforce contiguity, the algorithm processes frames sequentially. Within each frame, it groups identical codes to determine their participant sets and check the per-frame limit of at most two. It maintains a global mapping from each code to a record containing its participants and the last frame it appeared in. This enables verification of both fixed participants and contiguity.

**[THOUGHT_06_02]**

For frame $t$, forming a temporary list of pairs $(\text{code}, i)$ for all non-zero entries, then sorting this list by code would make equal codes adjacent. Sweeping the sorted list to form groups for each code, rejecting when group size exceeds two, otherwise converting the group to a normalized participant set: either $(a, -1)$ for solos or $(\min(a,b), \max(a,b))$ for duets.

**[THOUGHT_06_03]**

For the global state, when encountering a new code, inserting its participant set and setting last-seen frame to $t$; for a previously seen code, requiring that the last-seen frame equals $t - 1$ (to enforce contiguity) and that the participant set matches exactly (to enforce fixed emitters). Rejecting if either check fails, then updating last-seen to $t$.

**[THOUGHT_06_04]**

Once all frames are processed without a violation, scanning the global map to count codes whose participant record indicates two distinct indices (i.e., the stored second participant is not $-1$) would give the number of duets.

**[THOUGHT_06_05]**

Let $K_t$ be the number of non-zero entries in frame $t$ and $\sum_t K_t = K$. By monotonicity, $\sum_t K_t \log K_t \le K\, \log \big(\min\{N, \max_t K_t\}\big) \le K \log \min\{N, K\}$. Thus per-frame sorting is $O\big(K\, \log \min\{N, K\}\big)$, which collapses toward linear when frames are sparse (small $K_t$). This complements the alternative per-frame hashing path (expected $O(K)$) without repeating prior constants.

---

**[CHAIN_07]**

This section refines implementation details to reduce constants and improve robustness.

**[THOUGHT_07_01]**

Sorting the per-frame list  $(\text{code}, i)$  costs  $O(K_t \log K_t)$ and enables a single linear sweep to form groups. Using a per-frame unordered map for counts is expected  $O(K_t)$  without a sort, assuming average-case $O(1)$ hash operations (adequate load factor, minimal collisions, and capacity reserved to avoid rehashes). Both achieve the required grouping; we adopt the sort-and-sweep route for determinism and straightforward group iteration, acknowledging the extra  log  factor.

**[THOUGHT_07_02]**

Storing duet participants as $(\min(i,j), \max(i,j))$ regardless of the order in which participants appear in the frame data would make the representation consistent. This normalization prevents false mismatches due to ordering when comparing participant sets across frames.

**[THOUGHT_07_03]**

With large datasets near the $2 \cdot 10^6$ limit, the unordered map may rehash frequently, triggering expensive reallocations and bucket reorganizations. Each rehash costs $O(\text{size})$ to migrate elements; repeated growth (e.g., doubling buckets) can sum to significant overhead. Reserving capacity for the per-frame buffer ($N$) prevents repeated resizes within a frame, and pre-reserving the global map to an estimated number of distinct codes reduces expected rehash count from multiple $O(\text{size})$ events to near zero, improving constants at the cost of upfront memory reservation.

**[THOUGHT_07_04]**

Storing codes in $32$-bit integers suffices for $0 \le \text{code} \le 10^9$. Indices also fit in $32$-bit since $N \le 2 \cdot 10^6$.

**[THOUGHT_07_05]**

Defining a struct with clear documentation of its purpose and member variables makes comparisons and updates straightforward. Using the sentinel  $−1$  for solos allows duet counting by checking whether the second participant field is positive. This single-type representation avoids separate code paths for solo and duet records.

**[THOUGHT_07_06]**

Processing input frame by frame allows the algorithm to stream data with bounded transient memory. When any validation check fails, the algorithm can output $−1$  and terminate immediately without processing remaining frames. Continuing after a violation yields no extra value, so early exit avoids unnecessary work. For large inputs, standard I/O optimizations (disabling synchronization with stdio, untying streams) reduce synchronization and flushing overhead; the magnitude of benefit depends on the environment.

---

**[CHAIN_08]**

This section validates invariants and argues correctness systematically.

**[THOUGHT_08_01]**

Invariant I1 (per-frame admissibility): during processing of frame $t$, any group with size $>2$ immediately violates the per-frame constraint; otherwise the state remains admissible. This frames the group-size test as preservation of admissibility rather than restating behavior.

**[THOUGHT_08_02]**

Invariant I2 (contiguity): for any code $x$ present up to frame $t$, let $\text{lastSeen}_x$ be the most recent processed frame of $x$. Acceptance at frame $t$ requires $\text{lastSeen}_x = t-1$. If a gap exists, $\text{lastSeen}_x \le t-2$ and the check fails; if no gap exists, induction on $t$ establishes equality, so contiguity holds.

**[THOUGHT_08_03]**

Invariant I3 (fixed emitters): store normalized participants as an ordered pair $(a,b)$ with $b=-1$ for solos. Equality of this pair across consecutive frames is necessary and sufficient for a fixed emitter set; any role change, index swap, or solo↔duet transition alters the pair and is detected.

**[THOUGHT_08_04]**

If a code is seen consecutively across some interval $[L, R]$ with a fixed participant set and never appears outside that interval, analyzing the algorithm shows it admits the code because each step satisfies both the fixed-participants and last-seen adjacency checks. Codes appearing only once are also correctly handled, as their insertion does not require adjacency checks. This confirms the algorithm avoids false rejections.

---

**[CHAIN_09]**

This section analyzes time and space complexity across approaches to justify the final choice.

**[THOUGHT_09_01]**

Formal lower bound for per-code rescans: consider inputs with $D = \Theta(M)$ distinct positive codes, each appearing in $\Theta(1)$ cells. Any algorithm that, for each code, performs a verification pass touching $\Omega(M)$ cells incurs $\Omega(D\,M) = \Omega(M^2)$ time. Hence the per-code rescan paradigm is asymptotically ruled out.

**[THOUGHT_09_02]**

Aggregating all occurrences per code requires storing $K$ occurrences plus container metadata. Even with compact representations (e.g., a 16-byte pair per occurrence) and modest map/vector overhead averaging $\ge 16\text{–}24$ bytes per entry, total memory is $\gtrsim (32\text{–}40)\cdot K$ bytes. For $K \approx 2 \times 10^6$, this exceeds the 32 MB memory limit, making the approach risky despite its $O(K \log K + K)$ time.

**[THOUGHT_09_03]**

Per-frame hashing without a last-seen frame fails to enforce contiguity: a code can appear in $f_1$, skip $f_2$, and reappear in $f_3$ with identical participants and still be accepted. Augmenting the global state with a last-seen frame (and checking $t = \text{last}+1$) repairs this while preserving the per-frame $O(\sum_t K_t)$ work bound.

**[THOUGHT_09_04]**

A tighter bound on $\sum_t K_t \log K_t$ follows from convexity of $x\log x$: with $\sum_t K_t = K$, the sum is maximized by concentrating mass, yielding $\sum_t K_t \log K_t \le K \log K$. Since $K_t \le N$ for all $t$, we also have $\sum_t K_t \log K_t \le K \log N$. Therefore $\sum_t K_t \log K_t \le K \log \min\{K, N\}$, which can be much tighter than the crude $O(M\log M)$ bound depending on $(K,N,T)$.

---

**[CHAIN_10]**

This section performs lightweight hand-traces to build confidence in the solution. We use $0$-based frame indices throughout this chain.

**[THOUGHT_10_01]**

Frame $0$ has indices $2$ and $3$ emit code $10$. Group size is $2$ and participants are $(2, 3)$. Insert with last $= 0$. No further frames. Count duets $= 1$. Valid.

**[THOUGHT_10_02]**

Frame $0$ has index $1$ emits code $5$ $\rightarrow$ insert with last $= 0$. Frame $1$ is silent. Frame $2$ has index $1$ emits code $5$. Lookup finds last $= 0$, but current $t = 2$; not contiguous. Reject. Output is $-1$.

**[THOUGHT_10_03]**

Frame $0$ has indices $1$ and $2$ emit code $8$. Record participants $(1, 2)$, last $= 0$. Frame $1$ has only index $1$ emits code $8$. Group size $= 1$ and participants $(1, -1)$ differ from $(1, 2)$. Reject. Output is $-1$.

**[THOUGHT_10_04]**

Frames $1$ and $2$ have indices $4$ and $5$ emit code $12$. Frame $1$ creates entry $(4, 5)$, last $= 1$. Frame $2$ checks last $= 2 - 1$ and participants unchanged. Valid across both frames. Final duet count includes this code.

---

[RESPONSE]

**1. Problem Understanding**

We observe $N$ pollinators across $T$ frames. In each frame, every pollinator either stays silent (value $0$) or emits a positive integer frequency code. Each positive code corresponds to exactly one song that:
- Is active over a single contiguous block of frames.
- Has a fixed set of emitters (participants) throughout its active period, and this set is either of size $1$ (solo) or size $2$ (duet).
- Is never emitted by three or more pollinators in the same frame.

Task:
- Verify whether the log satisfies all rules.
- If valid, output the number of duets (codes with exactly two fixed participants).
- Otherwise, output $-1$.

Key observations:
- Validity checks can be performed per code, but to remain efficient we must process the log in a streaming fashion across frames.
- We need to enforce three conditions: per-frame limit (at most two simultaneous emitters per code), fixed participants for each code across its active interval, and contiguity (no gaps in the frames where a code appears).


**2. Optimal Approach**

We process the log frame by frame, grouping identical codes within each frame and maintaining per-code global state to enforce both fixed participants and contiguity.

Steps:
1. For each frame $t$, collect all non-zero entries into a list of pairs $(\text{code}, i)$, where $i$ is the pollinator index.
2. Sort this list by code to group identical codes together for the current frame. Sweep the list:
   - If any code appears more than twice in the same frame, it violates the per-frame rule; return $-1$.
   - Otherwise, derive the participant set for that code in the frame:
     - If it appears once, record as $(a, -1)$ for a solo.
     - If it appears twice, record as $(\min(a, b), \max(a, b))$ for a duet.
3. Maintain a global hash map: code $\to$ {participants, lastSeenFrame}.
   - If a code is new, insert its participants with lastSeenFrame set to the current frame.
   - If the code exists, enforce:
     - Contiguity: its lastSeenFrame must be the previous frame ($t - 1$).
     - Fixed participants: the current participants must equal the stored participants.
     - If either check fails, return $-1$. Otherwise, update lastSeenFrame to the current frame.
4. After processing all frames without violations, count how many codes have two participants (i.e., the second participant is not $-1$) and print that count.

This approach is efficient and memory-conscious: sorting per frame groups instances locally, while the global map ensures continuity and participant consistency over time.


**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <utility>
#include <cstddef>

struct CodeState {
    int firstParticipant;   // 1-based index of first pollinator
    int secondParticipant;  // -1 if solo
    int lastFrameSeen;      // 0-based index of last frame where seen
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int numberOfPollinators, numberOfFrames;
    if (!(std::cin >> numberOfPollinators >> numberOfFrames)) return 0;

    std::unordered_map<long long, CodeState> codeStateMap;
    // Reserve a small amount based on T to reduce some rehashing but avoid
    // aggressive reservation which can blow memory on small limits.
    std::size_t reserveEstimate = std::min<std::size_t>(static_cast<std::size_t>(numberOfFrames) * 2, static_cast<std::size_t>(100000));
    codeStateMap.reserve(reserveEstimate);

    std::vector<std::pair<long long,int>> frameBuffer;
    frameBuffer.reserve(numberOfPollinators);

    for (int frame = 0; frame < numberOfFrames; ++frame) {
        frameBuffer.clear();
        for (int participantIndex = 1; participantIndex <= numberOfPollinators; ++participantIndex) {
            long long code;
            std::cin >> code;
            if (code != 0) frameBuffer.emplace_back(code, participantIndex);
        }

        if (!frameBuffer.empty()) {
            std::sort(frameBuffer.begin(), frameBuffer.end(),
                 [](const std::pair<long long,int>& leftPair, const std::pair<long long,int>& rightPair) {
                     if (leftPair.first != rightPair.first) return leftPair.first < rightPair.first;
                     return leftPair.second < rightPair.second;
                 });

            for (size_t groupStartIndex = 0; groupStartIndex < frameBuffer.size(); ) {
                long long code = frameBuffer[groupStartIndex].first;
                int occurrenceCount = 0;
                int firstParticipantIndex = -1, secondParticipantIndex = -1;

                size_t groupEndIndex = groupStartIndex;
                while (groupEndIndex < frameBuffer.size() && frameBuffer[groupEndIndex].first == code) {
                    ++occurrenceCount;
                    if (occurrenceCount == 1) firstParticipantIndex = frameBuffer[groupEndIndex].second;
                    else if (occurrenceCount == 2) secondParticipantIndex = frameBuffer[groupEndIndex].second;
                    else {
                        std::cout << -1 << '\n';
                        return 0;
                    }
                    ++groupEndIndex;
                }

                if (secondParticipantIndex != -1 && firstParticipantIndex > secondParticipantIndex) std::swap(firstParticipantIndex, secondParticipantIndex);

                auto it = codeStateMap.find(code);
                if (it == codeStateMap.end()) {
                    // first time seeing this code
                    codeStateMap.emplace(code, CodeState{firstParticipantIndex, secondParticipantIndex, frame});
                } else {
                    CodeState &state = it->second;
                    // must be contiguous
                    if (state.lastFrameSeen != frame - 1) {
                        std::cout << -1 << '\n';
                        return 0;
                    }
                    // participants must match exactly
                    if (state.firstParticipant != firstParticipantIndex || state.secondParticipant != secondParticipantIndex) {
                        std::cout << -1 << '\n';
                        return 0;
                    }
                    state.lastFrameSeen = frame;
                }

                groupStartIndex = groupEndIndex;
            }
        }
    }

    long long duetCount = 0;
    for (const auto &entry : codeStateMap) {
        if (entry.second.secondParticipant != -1) ++duetCount;
    }

    std::cout << duetCount << '\n';
    return 0;
}
```

**4. Code Explanation**

- Data structures:
  - `frameBuffer` collects non-zero $(\text{code}, \text{pollinator})$ pairs for the current frame.
  - `codeStateMap` maintains, for each code, its fixed participant set and the last frame it appeared in.

- Per-frame processing:
  - Sort `frameBuffer` by code to cluster identical codes. For each cluster, count occurrences.
  - If a cluster exceeds two occurrences, the per-frame rule is violated; print $-1$.
  - Otherwise, determine the participant set: a single index for solos (`firstParticipant`, $-1$) or two sorted indices $(\min(\text{firstParticipant}, \text{secondParticipant}), \max(\text{firstParticipant}, \text{secondParticipant}))$ for duets.

- Global validation:
  - If a code is new, store its participants and mark the current frame as last seen.
  - If previously seen, enforce contiguity by requiring last seen frame to be the immediate predecessor, and enforce fixed participants by requiring exact equality of the participant set. Reject if any check fails.

- Final result:
  - Count codes with two participants (second participant not $-1$) as duets and print the count.

**Detailed Example Walkthrough:**

Let's trace the algorithm execution on the first problem example:
```
Input:
2 5
9 9
9 9
0 0
0 0
9 9
```

**Initial State:**
- `codeStateMap = {}` (empty)
- `numberOfPollinators = 2`, `numberOfFrames = 5`

**Frame $0$ (indices: $9$, $9$):**
1. Read frame: `frameBuffer` = [$(9, 1)$, $(9, 2)$]
2. Sort by code: [$(9, 1)$, $(9, 2)$] (already sorted)
3. Group codes: code $9$ appears twice with participants $(1, 2)$
4. Check group size: $2$ ≤ $2$ ✓
5. Normalize participants: `firstParticipant` = $1$, `secondParticipant` = $2$
6. Check `codeStateMap`: code $9$ not found (new code)
7. Insert: `codeStateMap`[$9$] = {`firstParticipant`: $1$, `secondParticipant`: $2$, `lastFrameSeen`: $0$}

**Frame $1$ (indices: $9$, $9$):**
1. Read frame: `frameBuffer` = [$(9, 1)$, $(9, 2)$]
2. Sort by code: [$(9, 1)$, $(9, 2)$]
3. Group codes: code $9$ appears twice with participants $(1, 2)$
4. Normalize participants: `firstParticipant` = $1$, `secondParticipant` = $2$
5. Check `codeStateMap`: code $9$ found → `currentState` = {$1$, $2$, $0$}
6. Check contiguity: `lastFrameSeen` = $0$, current frame = $1$ → $0 = 1 - 1$ ✓
7. Check fixed participants: $(1, 2) = (1, 2)$ ✓
8. Update: `codeStateMap`[$9$].`lastFrameSeen` = $1$

**Frame $2$ (indices: $0$, $0$):**
1. Read frame: `frameBuffer` = [] (all zeros, no codes)
2. No processing needed

**Frame $3$ (indices: $0$, $0$):**
1. Read frame: `frameBuffer` = []
2. No processing needed

**Frame $4$ (indices: $9$, $9$):**
1. Read frame: `frameBuffer` = [$(9, 1)$, $(9, 2)$]
2. Sort by code: [$(9, 1)$, $(9, 2)$]
3. Group codes: code $9$ appears twice with participants $(1, 2)$
4. Normalize participants: `firstParticipant` = $1$, `secondParticipant` = $2$
5. Check `codeStateMap`: code $9$ found → `currentState` = {$1$, $2$, $1$}
6. **Check contiguity: `lastFrameSeen` = $1$, current frame = $4$ → $1 \ne 4 - 1 = 3$ ✗**
7. **VIOLATION DETECTED: Code reappears after gap (frames 2-3 were silent)**
8. Output: $-1$

The algorithm correctly detects the contiguity violation and outputs $-1$.

---

Now let's trace the second example:
```
Input:
1 3
1000000000
1000000000
1000000000
```

**Initial State:**
- `codeStateMap = {}`, `numberOfPollinators = 1`, `numberOfFrames = 3`

**Frame $0$:**
1. `frameBuffer` = [$(1000000000, 1)$]
2. code $1000000000$ appears once → solo
3. Participants: `firstParticipant` = $1$, `secondParticipant` = $-1$
4. Insert: `codeStateMap`[$1000000000$] = {$1$, $-1$, $0$}

**Frame $1$:**
1. `frameBuffer` = [$(1000000000, 1)$]
2. Check contiguity: $0 = 1 - 1$ ✓
3. Check participants: $(1, -1) = (1, -1)$ ✓
4. Update `lastFrameSeen` = $1$

**Frame $2$:**
1. `frameBuffer` = [$(1000000000, 1)$]
2. Check contiguity: $1 = 2 - 1$ ✓
3. Check participants: $(1, -1) = (1, -1)$ ✓
4. Update `lastFrameSeen` = $2$

**Final Count:**
- Scan `codeStateMap`: code $1000000000$ has `secondParticipant` = $-1$ (solo, not duet)
- `duetCount` = $0$
- Output: $0$

The algorithm correctly identifies this as a valid solo and outputs $0$.

Walkthroughs for Chain 2 test cases (from [CHAIN_02]):

1) All zeros, $N=2, T=3$:
   - Frames 0..2: `frameBuffer` empty each time → no codes processed.
   - Final: `codeStateMap` empty → duetCount = 0 → output 0.

2) Per-frame violation, $N=3, T=1$, row: `[9, 9, 9]`:
   - Frame 0: group for code 9 has size 3 → immediate print -1.

3) Participant inconsistency, $N=2, T=2$:
   - Frame 0: `[5, 0]` → code 5 group: participants (1, -1). Insert last=0.
   - Frame 1: `[0, 5]` → code 5 group: participants (2, -1) ≠ stored (1, -1) → print -1.

4) Non-contiguity, $N=1, T=3$ with `[7]`, `[0]`, `[7]`:
   - Frame 0: insert code 7 with last=0.
   - Frame 1: no 7.
   - Frame 2: code 7 reappears; stored last=0 ≠ 2-1 → print -1.

5) Large value solo, $N=1, T=1$ with `[1000000000]`:
   - Frame 0: insert code 1e9 with participants (1, -1), last=0.
   - Final: secondParticipant = -1 → duetCount = 0 → output 0.

**5. Time and Space Complexity**

- Let $M = N \cdot T$ and $K_t$ be the number of non-zero entries in frame $t$.
- Time complexity:
  - Sorting within each frame takes $O(K_t \log K_t)$.
  - The total across frames is $\sum_{t=1}^{T} K_t \log K_t \le O(M \log M)$ in the worst case.
  - The grouping and map operations are linear in the number of non-zero entries.
- Space complexity:
  - Global map stores one record per distinct code: $O(D)$ where $D$ is the number of distinct positive codes.
  - Per-frame buffer uses $O(N)$ space.
  - Total additional space is $O(D + N)$.

**6. Conclusion**

By streaming each frame, grouping identical codes per frame, and maintaining per-code participants with a last-seen frame index, we rigorously enforce all constraints: at most two simultaneous emitters per code, fixed participants across the active interval, and contiguity of appearances. If a violation is detected, we output $-1$; otherwise, we count and output the number of duets. This solution is efficient and robust for inputs where $N \cdot T \le 2 \cdot 10^6$.
