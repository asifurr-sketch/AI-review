# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** - ["Greedy Algorithms", "Dynamic Programming", "Backtracking Algorithms", "Arrays and Lists", "Control Structures and Loops", "Algorithm Complexity and Big O Notation", "Functions and Recursion"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 5, O(3^n) -> O(n) -> O(n^2) -> O(n^2) -> O(n)

**Number of Chains:** - 9

---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**The Lantern Loop**

Time Limit: **1 seconds**

Memory Limit: **32 MB**

A seaside town hangs numbered lanterns around a circular boardwalk every year. For each position \(i\) on the loop, the crew receives three candidate tags \(X_i\), \(Y_i\), \(Z_i\). Adjacent lanterns may never bear the same tag, and the last lantern sits next to the first one along the loop. Among all valid assignments, you must choose tags so that the resulting sequence read clockwise from position 1 to \(n\) is lexicographically smallest. It is guaranteed that a valid assignment exists and that the lexicographically smallest valid assignment is unique.

Lexicographic order: compare sequences from left to right; at the first index where they differ, the sequence with the smaller number is smaller.

You are given \(t\) independent test cases.

**Input Format:-**
- The first line contains an integer \(t\), the number of test cases.
- For each test case:
  - A line with an integer \(n\), the number of positions on the loop.
  - A line with \(n\) integers \(X_1, X_2, \dots, X_n\).
  - A line with \(n\) integers \(Y_1, Y_2, \dots, Y_n\).
  - A line with \(n\) integers \(Z_1, Z_2, \dots, Z_n\).
- For every \(i\), the three integers \(X_i\), \(Y_i\), \(Z_i\) are pairwise distinct.

**Output Format:-**
- For each test case, print a single line with \(n\) integers: the chosen tags for positions \(1\) through \(n\) forming the unique lexicographically smallest valid assignment where adjacent positions (including \(n\) and \(1\)) have different values.

**Constraints:-**
- \(3 \le n \le 2 \times 10^5\) per test case.
- For all \(i\), \(X_i\), \(Y_i\), \(Z_i\) are pairwise distinct.
- Adjacent positions must not receive the same value; position \(n\) is adjacent to position \(1\).
- The sum of \(n\) over all test cases does not exceed \(2 \times 10^5\).
**Examples:-**
 - **Input:**
```
1
4
1 3 2 3
5 4 5 4
6 7 6 8
```

 - **Output:**
```
1 3 2 3
```

 - **Input:**
```
1
7
0 0 0 0 0 0 0
1 1 2 1 1 1 1
2 3 3 4 5 6 7
```

 - **Output:**
```
0 1 0 1 0 1 7
```

**Note:-**
In the first example, we choose the smallest allowed value at each position while ensuring neighbors differ, and at the last position also avoid the first value:
- Position \(1\): from \(\{1,5,6\}\) pick \(1\).
- Position \(2\): from \(\{3,4,7\}\) pick \(3\) (\(\neq 1\)).
- Position \(3\): from \(\{2,5,6\}\) pick \(2\) (\(\neq 3\)).
- Position \(4\): from \(\{3,4,8\}\) pick \(3\) (\(\neq 2\) and \(\neq\) first value \(1\)).
This yields \(1\ 3\ 2\ 3\).

In the second example, the smallest allowed alternates between 0 and 1 for positions 1–6:
- Positions \(1..6\): \(0,1,0,1,0,1\) (each differs from its predecessor).
- Position \(7\) must differ from both the previous (\(1\)) and the first (\(0\)), so from \(\{0,1,7\}\) we pick \(7\).
This yields \(0\ 1\ 0\ 1\ 0\ 1\ 7\).

Additional clarifications:
- At positions \(1..n-1\), select the smallest of \(\{X_i, Y_i, Z_i\}\) that is not equal to the previous chosen tag; at position \(n\), also ensure it differs from the tag at position \(1\).
- Values may repeat across non-adjacent positions; only adjacent equal tags are forbidden.
- The three candidates at each position are pairwise distinct, so there is no tie within a position. The problem guarantees a valid assignment exists and the lexicographically smallest valid assignment is unique.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarifying the objective and constraints to ground our reasoning

**[THOUGHT_01_01]**

We restate the problem in concrete terms. We have \(t\) independent test cases, each describing a circular arrangement of \(n\) positions labeled \(1\) through \(n\). For each position \(i\), we are given three distinct integers \(X_i\), \(Y_i\), \(Z_i\). We must select exactly one integer for each position so that adjacent positions receive different integers, with position \(n\) also adjacent to position \(1\). Among all assignments that satisfy these adjacency constraints, we must output the lexicographically smallest sequence \((a_1, a_2, \dots, a_n)\). Lexicographic order compares sequences from left to right; at the first differing index, the sequence with the smaller value is the smaller sequence.


**[THOUGHT_01_02]**

We capture the constraints precisely. For each test case, \(3 \le n \le 2 \times 10^5\), the sum of \(n\) across all test cases is at most \(2 \times 10^5\), and for each \(i\), \(X_i\), \(Y_i\), \(Z_i\) are pairwise distinct. Values can be any integers and may exceed 32-bit range, so we must treat them as 64-bit. The output is guaranteed to be unique given the problem statement’s guarantees and the choice of lexicographic minimization.


**[THOUGHT_01_03]**

We identify structural implications that shape solution space. For positions \(2\) through \(n-1\), the only constraint is \(a_i \ne a_{i-1}\). Since \(\{X_i, Y_i, Z_i\}\) are pairwise distinct, at most one of these three values equals \(a_{i-1}\). Hence, at least two valid choices exist for any such position. For the last position \(n\), two values may be forbidden: \(a_{n-1}\) and \(a_1\). Because there are three distinct candidates, at least one value remains valid for \(a_n\). This guarantees existence of a valid assignment regardless of earlier choices.


**[THOUGHT_01_04]**

We formalize the objective. Among all valid assignments, we prefer to minimize the earliest index at which our chosen sequence may become larger than some alternative valid sequence. This is the classical property of lexicographic order. Crucially, lexicographic minimization is dominated by early positions, suggesting that greedy strategies that always pick the smallest available value can be strong candidates, provided that the wrap-around constraint at the last position is handled correctly.


**[THOUGHT_01_05]**

We set performance goals aligned with constraints. With \(\sum n \le 2 \times 10^5\), we aim for an \(O(n)\) solution per test case (or \(O(\sum n)\) overall), with \(O(1)\) extra work per position. Memory usage should be linear in \(n\) for storing the three arrays and the answer. These goals exclude brute force and heavy backtracking. They also suggest we avoid storing or comparing entire sequences during optimization.

---


---

**[CHAIN_02]**

Designing test scenarios that stress correctness and edge cases

**[THOUGHT_02_01]**

We include the minimal cycle size. For \(n=3\), we must ensure that the last choice respects both adjacency constraints simultaneously. Example: \(X=[5, 1, 2]\), \(Y=[7, 2, 3]\), \(Z=[6, 4, 1]\). The sequence must ensure \(a_3 \ne a_2\) and \(a_3 \ne a_1\), and still be lexicographically minimal. This tests the smallest nontrivial wrap-around.


**[THOUGHT_02_02]**

We craft a case where the last position is forced. We want \(a_{n-1}\) and \(a_1\) to collectively forbid two candidates at position \(n\), leaving a single valid choice. Example: \(n=4\). Let \((X_1, Y_1, Z_1)=(2, 5, 9)\) so \(a_1=2\). Suppose we drive \(a_3\) to \(7\) and then set position \(4\) candidates as \((7, 2, 100)\). Then at \(i=4\), only \(100\) avoids both \(a_3=7\) and \(a_1=2\), validating the necessity of checking both forbiddances at the last position.


**[THOUGHT_02_03]**

We validate behavior with repeated numbers across positions. While within each position candidates are distinct, the same number can recur at different positions. Example: \(X=[1, 1, 1, 1]\), \(Y=[2, 2, 2, 2]\), \(Z=[3, 3, 3, 3]\). The algorithm must avoid adjacent equal values even when a number is globally frequent, and still achieve lexicographic minimality.


**[THOUGHT_02_04]**

We test extremes of value ranges and sign. Values can be large or negative. Example: \(X=[10^{12}, -10^{12}, 5]\), \(Y=[10^{12}-1, -10^{12}+1, 6]\), \(Z=[0, 1, 2]\). We must ensure that comparisons and storage use 64-bit integers and that sorting among three candidates remains correct.


**[THOUGHT_02_05]**

We include adversarial monotone patterns that may tempt suboptimal choices. Example: \(X_i=i\), \(Y_i=i+1\), \(Z_i=i+2\) for increasing \(i\). We check that local greedy choices at each step do not produce a conflict at the end and that the final choice is correctly constrained by both \(a_{n-1}\) and \(a_1\).


**[THOUGHT_02_06]**

We perform random stress testing. Generate many random test cases with \(n\) up to \(10^5\) and random distinct triples per position. Compare outputs from the intended \(O(n)\) greedy solution against a slower checker that verifies the constraints and lexicographic minimality for small \(n\) (e.g., brute force for \(n \le 12\)) to build confidence.

---


---

**[CHAIN_03]**

Implementing brute force to enumerate all assignments (failed approach)

**[THOUGHT_03_01]**

We consider a naive exhaustive search. For each position \(i\), pick one of \(X_i\), \(Y_i\), \(Z_i\). This yields \(3^n\) assignments. For each assignment, we check adjacency constraints \(a_i \ne a_{i+1}\) for all \(i\) with wrap-around \(a_n \ne a_1\), and track the lexicographically smallest valid sequence by comparisons.


**[THOUGHT_03_02]**

We estimate time complexity. Even for \(n=20\), the search space has \(3^{20} \approx 3.486 \times 10^9\) assignments. With \(\sum n\) up to \(2 \times 10^5\), realistic instances include \(n\) in the tens or hundreds of thousands. Therefore, exhaustive enumeration is hopeless. Memory is acceptable but runtime is astronomical.


**[THOUGHT_03_03]**

We consider branch-and-bound pruning. If at position \(i\) we violate adjacency with \(a_{i-1}\), we prune. If the current partial prefix is already lexicographically larger than the best-known prefix, we prune. While these reduce the search space for small \(n\), the worst-case complexity remains exponential and still intractable for large \(n\), making it unsuitable.


**[THOUGHT_03_04]**

We conclude that brute force is infeasible. Despite being conceptually simple and complete, it violates our performance goals by many orders of magnitude and cannot be used even for moderate \(n\). We discard this approach and look for polynomial-time solutions.

---


---

**[CHAIN_04]**

Attempting dynamic programming with a wrong objective (failed approach)

**[THOUGHT_04_01]**

We entertain a dynamic programming approach that minimizes a surrogate metric such as the sum of chosen values or the number of "switches". Define \(dp[i][c]\) as the minimal sum achievable up to index \(i\) with choice \(c \in \{X_i, Y_i, Z_i\}\), respecting adjacency constraints. Transitions ensure \(a_i \ne a_{i-1}\), and wrap-around can be handled by fixing \(a_1\) and minimizing over consistent endings.


**[THOUGHT_04_02]**

We reveal the flaw: minimizing sum does not imply lexicographic minimality. Consider two sequences of the same length \(n=3\): sequence A is \([100, 0, 0]\), sequence B is \([101, -1000, -1000]\). Sequence B has a smaller sum but is lexicographically larger because at index 1 we compare 100 vs 101. Lexicographic order prioritizes early positions over any aggregation, so any DP targeting a global additive objective can pick a lexicographically worse sequence.


**[THOUGHT_04_03]**

We construct a concrete counterexample under the problem’s constraints. Let \(n=3\). Suppose
- Position 1: \(\{100, 101, 200\}\),
- Position 2: \(\{0, 50, 60\}\),
- Position 3: \(\{0, -1000, -999\}\).
A sum-minimizing DP may pick \(101\) at position 1 to allow both \(-1000\) and \(0\) later, achieving a smaller total, whereas the lexicographic minimum must begin with \(100\). This mismatch invalidates the approach for our objective.


**[THOUGHT_04_04]**

We conclude that a DP optimizing any additive score (sum, differences, or similar) is misaligned with lexicographic minimization. Even with correct handling of wrap-around, the metric mismatch guarantees wrong answers on adversarial inputs. We discard this approach.

---


---

**[CHAIN_05]**

Trying a local greedy with late backtracking (failed approach)

**[THOUGHT_05_01]**

We attempt a locally greedy strategy: pick the smallest among \(\{X_1, Y_1, Z_1\}\) for \(a_1\). For \(i=2\) to \(n\), pick the smallest candidate not equal to \(a_{i-1}\). If at \(i=n\) we end up with \(a_n = a_1\), we backtrack by changing \(a_n\) to the next smallest option, or if none is possible, adjust \(a_{n-1}\), and so on. This ensures a valid final sequence but may require multiple revisions near the end.


**[THOUGHT_05_02]**

We examine why it initially feels plausible. At each middle position, only one value is forbidden, so picking the smallest allowed seems aligned with lexicographic goals. The only complication arises at the last position due to the wrap-around. It seems reasonable to repair the sequence locally at the end if needed.


**[THOUGHT_05_03]**

We highlight the practical issues. Backtracking can cause a cascade: changing \(a_{n-1}\) forces revisiting \(a_{n-2}\), etc., potentially leading to \(O(n)\) rework per conflict and \(O(n^2)\) worst-case time. More importantly, a late change to \(a_{n-1}\) or earlier may violate lexicographic minimality of the prefix that had been locally minimized before. Even if we finally obtain a valid sequence, it may not be the lexicographically smallest under the constraint that earlier indices were altered to satisfy the end condition.


**[THOUGHT_05_04]**

We conclude that this approach is both fragile and unnecessarily complex. It risks quadratic behavior due to cascading backtracking and can defeat the lexicographic intent by changing earlier minimized positions. We set it aside and seek a method that incorporates the last-position constraint without backtracking.

---


---

**[CHAIN_06]**

Constructing a lexicographic dynamic programming for cycles (overkill but instructive)

**[THOUGHT_06_01]**

We propose a DP that explicitly targets lexicographic minimality. Fix \(a_1\) to one of its three candidates. For each fixed \(a_1\), define \(dp[i][c]\) to store the lexicographically smallest suffix \((a_i, a_{i+1}, \dots, a_n)\) when \(a_i=c\) and adjacency is enforced. For transitions at \(i<n\), we append the minimal allowed suffix from \(i+1\); at \(i=n\), we enforce \(a_n \ne a_1\). Finally, we pick the smallest sequence among the three results for the three choices of \(a_1\).


**[THOUGHT_06_02]**

We pinpoint the complexity concerns. Storing full suffix sequences at each state is too heavy: comparing sequences can take \(O(n)\) time, making transitions \(O(n)\) and the total time \(O(n^2)\) per test case. Memory would also be large if we materialize sequences. Even storing path pointers to reconstruct later keeps comparisons expensive.


**[THOUGHT_06_03]**

We analyze the structure of the DP transitions. Given a fixed prefix and the adjacency constraint, the lexicographically smallest continuation at index \(i\) is to pick the smallest allowed value at position \(i\) and proceed. This observation collapses the DP into a greedy choice at every step, provided we handle the last position with the additional \(a_n \ne a_1\) constraint.


**[THOUGHT_06_04]**

We conclude that while an explicit lexicographic DP is conceptually correct, it is overkill. It naturally reduces to a linear greedy construction once we observe that at positions \(2\) to \(n-1\) only one value is forbidden and at \(n\) exactly two values may be forbidden. We therefore discard the DP in favor of a simpler one-pass greedy.

---


---

**[CHAIN_07]**

Adopting a one-pass greedy that respects both neighbors at the last position

**[THOUGHT_07_01]**

We describe the final algorithm.
- At position \(1\), choose \(a_1 = \min\{X_1, Y_1, Z_1\}\).
- For each position \(i = 2, 3, \dots, n-1\), choose \(a_i\) as the smallest candidate in \(\{X_i, Y_i, Z_i\}\) that is not equal to \(a_{i-1}\).
- At position \(n\), choose \(a_n\) as the smallest candidate in \(\{X_n, Y_n, Z_n\}\) that differs from both \(a_{n-1}\) and \(a_1\).


**[THOUGHT_07_02]**

We justify correctness for existence and minimality. For positions \(2\) through \(n-1\), at most one candidate equals \(a_{i-1}\), so at least two are valid; picking the smallest valid guarantees the smallest possible value at the earliest index that could differ among valid sequences. At position \(n\), there may be up to two forbidden values \(a_{n-1}\) and \(a_1\); at least one candidate remains valid due to pairwise distinctness, and choosing the smallest such candidate ensures lexicographic minimality of the full sequence given the fixed prefix. Since each chosen minimum at each step is unique (distinct candidates), the final sequence is unique.


**[THOUGHT_07_03]**

We compare against prior attempts. This method integrates the wrap-around constraint directly at the last step, avoiding any backtracking. It avoids the exponential blowup of brute force and the quadratic or correctness issues of DP variants that optimize an unrelated objective. It is the distilled insight of the DP that the lexicographically smallest choice at each step is independent of future positions once the prefix and constraints are set.


**[THOUGHT_07_04]**

We note complexity and resource usage. Each position requires checking at most three values and possibly two exclusions. The time per test case is \(O(n)\), and the total across all test cases is \(O(\sum n)\). Memory is \(O(n)\) to store the three arrays and the answer, with \(O(1)\) extra per position during the pass. This meets and comfortably satisfies the constraints.

---


---

**[CHAIN_08]**

Validating the final approach with dry runs and corner cases

**[THOUGHT_08_01]**

We dry-run Sample 1, Test 1.
- \(n=4\)
- Position 1 candidates: \(\{3, 5, 2\} \Rightarrow a_1 = 2\).
- Position 2 candidates: \(\{1, 4, 9\}\) choose the smallest not equal to \(2\): \(a_2 = 1\).
- Position 3 candidates: \(\{7, 1, 8\}\), avoid \(a_2=1\): \(a_3 = 7\).
- Position 4 candidates: \(\{2, 6, 3\}\), avoid \(a_3=7\) and \(a_1=2\): smallest remaining is \(3\).
Final: \(2\ 1\ 7\ 3\).


**[THOUGHT_08_02]**

We dry-run Sample 1, Test 2.
- \(n=3\)
- Position 1: \(\{10, 11, 12\} \Rightarrow a_1 = 10\).
- Position 2: \(\{20, 21, 22\}\), avoid \(10\): \(a_2 = 20\).
- Position 3: \(\{30, 31, 25\}\), avoid \(a_2=20\) and \(a_1=10\) (neither matches), pick the smallest: \(a_3 = 25\).
Final: \(10\ 20\ 25\).


**[THOUGHT_08_03]**

We validate the smallest cycle \(n=3\) with a forced last choice. Example:
- \(X=[5, 1, 5]\), \(Y=[6, 2, 1]\), \(Z=[7, 3, 6]\).
- \(a_1=\min\{5,6,7\}=5\).
- \(a_2=\min\{1,2,3\}\) not equal to \(5\) is \(1\).
- At \(i=3\), candidates \(\{5, 1, 6\}\), avoid \(a_2=1\) and \(a_1=5\), only valid is \(6\).
Final: \(5\ 1\ 6\), confirming the last-position dual exclusion.


**[THOUGHT_08_04]**

We validate a case with duplicates across positions.
- \(X=[1, 1, 1, 1]\), \(Y=[2, 2, 2, 2]\), \(Z=[3, 3, 3, 3]\).
- \(a_1=1\).
- \(a_2=2\) (avoid 1).
- \(a_3=1\) (avoid 2).
- \(a_4\) must avoid \(a_3=1\) and \(a_1=1\), so choose \(2\).
Final: \(1\ 2\ 1\ 2\). This satisfies adjacency and demonstrates wrap-around awareness at the last step.

---


---

**[CHAIN_09]**

Detailing implementation decisions and presenting core utility snippets

**[THOUGHT_09_01]**

We choose 64-bit integers for values. Since input values can be large and not explicitly bounded in 32-bit range, we use signed 64-bit integers in C++ (long long) to store \(X\), \(Y\), \(Z\), and the answer. This avoids overflow and preserves correctness for comparisons.


**[THOUGHT_09_02]**

We keep indexing consistent and simple. We can use 0-based arrays internally for \(X\), \(Y\), \(Z\), and answer. The loop runs from \(i=0\) to \(n-1\). We compute \(a[0]\) as the minimum of \(X[0], Y[0], Z[0]\). For \(1 \le i \le n-2\), we choose the minimum candidate not equal to \(a[i-1]\). For \(i = n-1\), we choose the minimum candidate not equal to both \(a[n-2]\) and \(a[0]\).


**[THOUGHT_09_03]**

We implement a helper that picks the minimum among three values with up to two exclusions. This isolates the core decision logic, reduces duplication, and makes the code easier to test. The function takes flags or sentinels to indicate whether each exclusion is active and returns the smallest allowed candidate. It avoids unnecessary headers by not using sentinel constants.

```cpp
/**
 * @brief Picks the smallest value among three candidates while excluding up to two forbidden values.
 *
 * @param x First candidate value.
 * @param y Second candidate value.
 * @param z Third candidate value.
 * @param f1 First forbidden value to exclude.
 * @param useF1 If true, exclude f1 when selecting the result.
 * @param f2 Second forbidden value to exclude.
 * @param useF2 If true, exclude f2 when selecting the result.
 * @return The smallest candidate among {x, y, z} that differs from every active forbidden value.
 */
long long pickMin3Excluding(long long x, long long y, long long z,
                            long long f1, bool useF1,
                            long long f2, bool useF2) {
    long long ans = 0;
    bool hasAns = false;
    if ((!useF1 || x != f1) && (!useF2 || x != f2)) {
        ans = x;
        hasAns = true;
    }
    if ((!useF1 || y != f1) && (!useF2 || y != f2)) {
        if (!hasAns || y < ans) {
            ans = y;
            hasAns = true;
        }
    }
    if ((!useF1 || z != f1) && (!useF2 || z != f2)) {
        if (!hasAns || z < ans) {
            ans = z;
            hasAns = true;
        }
    }
    return ans; // Guaranteed to exist by problem constraints.
}
```


**[THOUGHT_09_04]**

We outline the one-pass construction using the helper. The main loop computes \(a[0]\) by a plain min, populates \(a[1..n-2]\) by excluding only the previous choice, and computes \(a[n-1]\) by excluding both the previous choice and \(a[0]\). We then print the answer with spaces between values, one test per line. The time is \(O(n)\) per test, and we do a constant amount of work per position.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given \(t\) independent test cases. Each test case describes a circular loop of \(n\) positions labeled \(1\) to \(n\). For each position \(i\), we are given three pairwise-distinct integers \(X_i\), \(Y_i\), \(Z_i\). We must assign one of these three values to position \(i\), ensuring that adjacent positions have different values and that position \(n\) is adjacent to position \(1\).

Among all valid assignments, we must output the lexicographically smallest sequence \(a_1, a_2, \dots, a_n\). Lexicographic order compares sequences from left to right; at the first index where they differ, the sequence with the smaller number is considered smaller.

Key observations:
- For positions \(2\) through \(n-1\), the only restriction is \(a_i \ne a_{i-1}\). Since the three candidates at each position are distinct, at most one candidate is forbidden, so at least two remain valid.
- For position \(n\), two values might be forbidden: \(a_{n-1}\) and \(a_1\). Because the candidates are pairwise distinct, at least one valid option always remains.
- To minimize lexicographically, we should choose the smallest allowed value at the earliest possible position. This suggests a greedy approach from left to right, with a special check at the last position to avoid both neighbors.

Constraints:
- \(3 \le n \le 2 \times 10^5\) per test case.
- The sum of \(n\) across all test cases does not exceed \(2 \times 10^5\).
- For all \(i\), \(X_i\), \(Y_i\), \(Z_i\) are pairwise distinct.
- The lexicographically smallest valid assignment is guaranteed to exist and is unique.

**2. Optimal Approach**

We perform a single pass to construct the answer:
1. Set \(a_1\) to the smallest among \(\{X_1, Y_1, Z_1\}\). Any larger choice would make the sequence lexicographically larger regardless of later choices.
2. For each position \(i\) from \(2\) to \(n-1\), set \(a_i\) as the smallest candidate among \(\{X_i, Y_i, Z_i\}\) that is not equal to \(a_{i-1}\). At most one candidate is forbidden, so this always exists.
3. For position \(n\), set \(a_n\) as the smallest candidate among \(\{X_n, Y_n, Z_n\}\) that differs from both \(a_{n-1}\) and \(a_1\). With three distinct candidates, at least one valid choice remains.

Correctness:
- Existence: Each step has at least one valid candidate due to distinctness and at most one or two forbidden values.
- Lexicographic minimality: Greedily choosing the smallest allowed at each step ensures we minimize the earliest position where sequences can differ.
- Uniqueness: At each position, the minimal allowed candidate among three distinct values is unique, making the entire sequence unique.

Complexity:
- Each position inspects up to three values with simple comparisons, yielding \(O(n)\) time per test case and \(O\!\left(\sum n\right)\) overall.
- Memory usage is \(O(n)\) per test case for storing arrays and the answer.

**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

/**
 * @brief Picks the smallest value among three candidates while excluding one forbidden value.
 *
 * @param x First candidate value.
 * @param y Second candidate value.
 * @param z Third candidate value.
 * @param forbidden The forbidden value to exclude.
 * @return The smallest candidate among {x, y, z} that differs from forbidden.
 */
long long pickMin3ExcludingOne(long long x, long long y, long long z, long long forbidden) {
    long long ans = 0;
    bool hasAns = false;
    if (x != forbidden) {
        ans = x;
        hasAns = true;
    }
    if (y != forbidden) {
        if (!hasAns || y < ans) {
            ans = y;
            hasAns = true;
        }
    }
    if (z != forbidden) {
        if (!hasAns || z < ans) {
            ans = z;
            hasAns = true;
        }
    }
    return ans; // Guaranteed to exist by problem constraints.
}

/**
 * @brief Picks the smallest value among three candidates while excluding two forbidden values.
 *
 * @param x First candidate value.
 * @param y Second candidate value.
 * @param z Third candidate value.
 * @param forbidden1 First forbidden value to exclude.
 * @param forbidden2 Second forbidden value to exclude.
 * @return The smallest candidate among {x, y, z} that differs from both forbidden values.
 */
long long pickMin3ExcludingTwo(long long x, long long y, long long z,
                               long long forbidden1, long long forbidden2) {
    long long ans = 0;
    bool hasAns = false;
    if (x != forbidden1 && x != forbidden2) {
        ans = x;
        hasAns = true;
    }
    if (y != forbidden1 && y != forbidden2) {
        if (!hasAns || y < ans) {
            ans = y;
            hasAns = true;
        }
    }
    if (z != forbidden1 && z != forbidden2) {
        if (!hasAns || z < ans) {
            ans = z;
            hasAns = true;
        }
    }
    return ans; // Guaranteed to exist by problem constraints.
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t;
    if (!(std::cin >> t)) {
        return 0;
    }
    while (t--) {
        int n;
        std::cin >> n;
        std::vector<long long> x(n), y(n), z(n);
        for (int i = 0; i < n; ++i) std::cin >> x[i];
        for (int i = 0; i < n; ++i) std::cin >> y[i];
        for (int i = 0; i < n; ++i) std::cin >> z[i];

        std::vector<long long> ans(n);
        // First position: pick the smallest among the three
        ans[0] = std::min(x[0], std::min(y[0], z[0]));

        // Positions 2..n-1: pick the smallest candidate not equal to previous
        for (int i = 1; i < n - 1; ++i) {
            ans[i] = pickMin3ExcludingOne(x[i], y[i], z[i], ans[i - 1]);
        }

        // Position n: pick the smallest candidate not equal to both previous and first
        ans[n - 1] = pickMin3ExcludingTwo(x[n - 1], y[n - 1], z[n - 1], ans[n - 2], ans[0]);

        for (int i = 0; i < n; ++i) {
            if (i) std::cout << ' ';
            std::cout << ans[i];
        }
        std::cout << '\n';
    }
    return 0;
}
```

**4. Code Explanation**

- Reading input: For each test case, we read \(n\) and three arrays \(x\), \(y\), and \(z\), each of length \(n\).
- Greedy construction:
  - For the first position, choose the minimum among its three candidates.
  - For positions \(2\) to \(n-1\), choose the smallest candidate that differs from the previously chosen value.
  - For the last position, choose the smallest candidate that differs from both the previous and the first chosen values.
- The helper functions pickMin3ExcludingOne and pickMin3ExcludingTwo encapsulate selecting the smallest among three values while excluding one or two forbidden values respectively. This ensures linear-time processing with constant work per position and makes the code more explicit about which constraints are being applied.

Illustrative process:
- Given each triple, the algorithm picks the minimal allowed value in order. This guarantees the lexicographically smallest sequence because any deviation to a larger option at an earlier index would make the resulting sequence lexicographically larger, regardless of subsequent choices, subject to the circular constraint handled at the last position.

**5. Time and Space Complexity**

- Time complexity: \(O(n)\) per test case, since each of the \(n\) positions is processed once with constant work. Across all test cases, the complexity is \(O\!\left(\sum n\right)\).
- Space complexity: \(O(n)\) per test case to store the input arrays and the resulting sequence.

**6. Conclusion**

By selecting the smallest feasible candidate at each position in a single left-to-right pass and handling the circular constraint at the last position, we obtain the unique lexicographically smallest valid assignment. The approach is simple, provably correct, and runs in linear time with linear space, comfortably meeting the problem’s constraints.