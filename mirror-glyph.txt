# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** -  ["Trees and Tries", "Basic Data Structures", "Arrays and Lists", "Algorithm Complexity and Big O Notation", "Dynamic Programming", "Memoization", "Control Structures and Loops", "Searching Algorithms", "Hash Tables", "Functions and Recursion", "Computational Complexity Theory", "Object-Oriented Programming", "Graphs and Networks"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 4, ($O(n^4)$ -> $O(n^3)$ -> $O(n^2 \log n)$ -> $O(n)$)

**Number of Chains:** - 10

**GitHub URL:** - https://github.com/NOI-gen/mirror_glyph_chronicles


---

**[User]**

*Mark the start of the User's activity*

---

**[Prompt]**

# Mirror-Glyph Chronicles

Time Limit: **1 seconds**  
Memory Limit: **32 MB**

An ancient scroll reveals itself one character at a time. A mirror-glyph is any palindromic substring. For every prefix of the scroll, record:

- the number of different mirror-glyphs seen so far,
- the length of the longest mirror-glyph so far,
- the total sum of lengths of all distinct mirror-glyphs discovered so far.

You are given a lowercase string $g$ of length $n$. For each prefix $g[1..m]$, define the following:

- $M(m)$ = the number of distinct palindromic substrings in $g[1..m]$
- $R(m)$ = the maximum length of a palindromic substring in $g[1..m]$
- $I(m)$ = the sum of lengths of all distinct palindromic substrings in $g[1..m]$

You are given $q$ queries. For each query $m$, output $M(m)$, $R(m)$, and $I(m)$.

Distinct palindromic substrings are considered by content only. For example, if "aa" appears multiple times, it is counted once.

**Input Format:-**

- The first line contains an integer $t$, the number of test cases.
- For each test case:
- A line with two integers $n$ and $q$.
- A line with the string $g$ of length $n$ consisting of lowercase English letters.
- A line with $q$ integers $m_1, m_2, \ldots, m_q$, where each $m_i$ is a prefix length.

**Output Format:-**

- For each query $m_i$ (in order), print three integers: $M(m_i)$ $R(m_i)$ $I(m_i)$.
- Print answers for different queries on separate lines.

**Constraints:-**

- $1 \le n \le 2 \cdot 10^{5}$
- $1 \le q \le 2 \cdot 10^{5}$
- $1 \le m_i \le n$
- $\sum n \le 2 \cdot 10^{5}$ over all test cases
- $\sum q \le 2 \cdot 10^{5}$ over all test cases  
  **Examples:-**
- **Input:**

```
1
1 1
a
1
```

- **Output:**

```
1 1 1
```

**Explanation**

- Prefix $g[1..1] = a$.
- Distinct palindromic substrings: $a$.

  - $M(1) = 1$ (only $a$),
  - $R(1) = 1$ (longest is length $1$),
  - $I(1) = 1$ (sum of lengths = $1$).

- **Input:**

```
1
5 5
aaaaa
1 2 3 4 5
```

- **Output:**

```
1 1 1
2 2 3
3 3 6
4 4 10
5 5 15
```

**Notes:**

- First example ($g$ = "a", queries: 1): For prefix $g[1..1] = a$, the distinct palindromic substrings are $\{a\}$. Thus $M(1)=1$, $R(1)=1$, $I(1)=1$.
- Second example ($g$ = "aaaaa", queries: 1 2 3 4 5):
  - $m=1$: distinct palindromes $\{a\}$ → $M=1$, $R=1$, $I=1$.
  - $m=2$: $\{a, aa\}$ → $M=2$, $R=2$, $I=1+2=3$.
  - $m=3$: $\{a, aa, aaa\}$ → $M=3$, $R=3$, $I=1+2+3=6$.
  - $m=4$: $\{a, aa, aaa, aaaa\}$ → $M=4$, $R=4$, $I=1+2+3+4=10$.
  - $m=5$: $\{a, aa, aaa, aaaa, aaaaa\}$ → $M=5$, $R=5$, $I=1+2+3+4+5=15$.

---

**[Assistant]**

Mark the start of the Assistant's activity

---

**[CHAIN_01]**

Understanding objectives, constraints, and distinctness by content


**[THOUGHT_01_01]**

Let me understand what we're dealing with here. We have a string and need to answer queries about palindromes in prefixes. The key insight is that we need to track distinct palindromes by content, not by position. This means if "aba" appears multiple times, we only count it once. The problem constraints are: $1 \le n \le 2 \cdot 10^{5}$ and $1 \le q \le 2 \cdot 10^{5}$, which means we need to process up to 200,000 characters and answer up to 200,000 queries.



**[THOUGHT_01_02]**

Looking at the input format, I need to handle multiple test cases. Each test case gives me a string and some queries about different prefix lengths. The queries can be in any order and might repeat. I need to figure out how to efficiently compute $M(m)$, $R(m)$, and $I(m)$ for the given prefix lengths.


**[THOUGHT_01_03]**

Let me analyze what happens when we extend a prefix. Consider prefix $g[1..m]$ and extending it to $g[1..m+1]$. Any palindromic substring in $g[1..m]$ is also a palindromic substring in $g[1..m+1]$ since we're only adding one character at the end. Therefore, the set of palindromic substrings in $g[1..m]$ is a subset of those in $g[1..m+1]$. This means $M(m) \le M(m+1)$, $R(m) \le R(m+1)$, and $I(m) \le I(m+1)$ - all three functions are non-decreasing. This monotonicity property might be useful for optimization.


---

**[CHAIN_02]**

Design sample tests and edge cases to anchor expectations


**[THOUGHT_02_01]**

Step-by-step execution on $g = \text{"aba"}$
- Prefix $m=1$ ($"a"$): distinct palindromes $\{a\}$. So $M(1)=1$, $R(1)=1$, $I(1)=1$.
- Prefix $m=2$ ($"ab"$): distinct palindromes $\{a,b\}$. So $M(2)=2$, $R(2)=1$, $I(2)=2$.
- Prefix $m=3$ ($"aba"$): new palindrome $"aba"$ appears; distinct $\{a,b,aba\}$. So $M(3)=3$, $R(3)=3$, $I(3)=5$.

- All distinct letters For $g=\text{"abcde"}$, each character forms a single-letter palindrome. Since all characters are different, no multi-character palindromes can exist (a palindrome of length 2+ would require identical characters at symmetric positions). Therefore, only single-letter palindromes exist: $M(m)=m$, $R(m)=1$, $I(m)=m$.
- Homogeneous For $g=\text{"aaaaa"}$ with prefix $m$, all substrings of length $k$ from 1 to $m$ are palindromes since all characters are identical. The palindromes are "a","aa",..., up to length $m$. Therefore: $M(m)=m$ (one palindrome of each length), $R(m)=m$ (longest is length $m$), $I(m)=1+2+\ldots+m=m(m+1)/2$ (sum of arithmetic sequence).



**[THOUGHT_02_02]**

Testing edge case $g = \text{"aaaaa"}$ with prefix lengths 1-5
- $m=1$: distinct palindromes $\{a\}$ → $M=1$, $R=1$, $I=1$
- $m=2$: distinct palindromes $\{a, aa\}$ → $M=2$, $R=2$, $I=1+2=3$
- $m=3$: distinct palindromes $\{a, aa, aaa\}$ → $M=3$, $R=3$, $I=1+2+3=6$
- $m=4$: distinct palindromes $\{a, aa, aaa, aaaa\}$ → $M=4$, $R=4$, $I=1+2+3+4=10$
- $m=5$: distinct palindromes $\{a, aa, aaa, aaaa, aaaaa\}$ → $M=5$, $R=5$, $I=1+2+3+4+5=15$

This confirms the pattern: for homogeneous strings of length $m$, we get $M(m)=m$, $R(m)=m$, $I(m)=m(m+1)/2$.


**[THOUGHT_02_03]**

Testing mixed case $g = \text{"ababa"}$ with prefix lengths 1-5
- $m=1$: distinct palindromes $\{a\}$ → $M=1$, $R=1$, $I=1$
- $m=2$: distinct palindromes $\{a, b\}$ → $M=2$, $R=1$, $I=2$
- $m=3$: distinct palindromes $\{a, b, aba\}$ → $M=3$, $R=3$, $I=5$
- $m=4$: distinct palindromes $\{a, b, aba, bab\}$ → $M=4$, $R=3$, $I=8$
- $m=5$: distinct palindromes $\{a, b, aba, bab, ababa\}$ → $M=5$, $R=5$, $I=13$

This shows how new palindromes are introduced incrementally, with at most one new palindrome per character.


---

**[CHAIN_03]**

Naive enumeration to probe feasibility (failed approach)


**[THOUGHT_03_01]**

Let me analyze a brute force approach: enumerate all substrings per prefix and test palindromicity, deduplicating in a set by content. For a prefix of length $m$, there are $\binom{m+1}{2} = \frac{m(m+1)}{2} = O(m^2)$ possible substrings. Testing each substring for palindromicity takes $O(k)$ time where $k$ is the substring length, so the total time per prefix is $\sum_{k=1}^{m} k \cdot (m-k+1) = O(m^3)$. Summing over all prefixes: $\sum_{m=1}^{n} O(m^3) = O(n^4)$. Even with rolling hashes reducing palindrome checks to $O(1)$, we still need to enumerate $O(m^2)$ substrings per prefix, giving $\sum_{m=1}^{n} O(m^2) = O(n^3)$ total time. For $n = 2 \cdot 10^5$, this would require approximately $8 \cdot 10^{15}$ operations, making this approach infeasible.



**[THOUGHT_03_02]**

Let me analyze the deduplication complexity. For repetitive inputs like $g = "aaaaa"$, every substring is a palindrome. There are $\sum_{k=1}^{n} k = \frac{n(n+1)}{2} = \Theta(n^2)$ total substrings, and since all are palindromes, we have $\Theta(n^2)$ distinct palindromes by content. Even with hashing to deduplicate by content and tracking the earliest introduction time, we still need to enumerate all $\Theta(n^2)$ palindromes. The memory requirement becomes $\Theta(n^2)$ to store all distinct palindromes and their metadata. This quadratic space and time complexity makes the approach unsuitable for the given constraints.



---

**[CHAIN_04]**

Leverage Manacher but confront output-scale limitations



**[THOUGHT_04_01]**

Let me analyze Manacher's algorithm approach. Manacher's algorithm computes palindrome radii in $O(n)$ time by expanding around centers and leveraging symmetry properties. However, to get distinct palindromes by content, we need to materialize all palindromic substrings. For a homogeneous string like "aaaaa", every substring is a palindrome, giving us $\Theta(n^2)$ distinct palindromes. Even with hash-based content deduplication, we still need to process and store all $\Theta(n^2)$ palindromes. The space complexity becomes $\Theta(n^2)$ and the time complexity for deduplication using balanced trees is $O(n^2 \log n)$. This exceeds the memory limit of 32 MB and time constraints, making this approach not scalable.



**[THOUGHT_04_02]**

Even with Manacher's radii known, determining the first prefix $m$ where each distinct palindrome content appears requires tracking each palindrome's first occurrence. For each of the $\Theta(n^2)$ possible palindromes in worst-case strings, we need to store when it first appears and maintain this information. The space requirement becomes $\Theta(n^2)$ for storing all distinct palindromes and their metadata. The time complexity for processing all $\Theta(n^2)$ candidates and maintaining the tracking data structures exceeds the time budget. This makes the approach infeasible within the given constraints.



---

**[CHAIN_05]**

Adopt the Palindromic Tree (Eertree) for online distinctness



**[THOUGHT_05_01]**

Let me analyze how the Eertree's structural properties enable efficient processing. The key insight is that the Eertree maintains at most one new palindrome node per character position. This single-introduction property means we process exactly n characters and create at most n+2 nodes total (including the two root nodes). The suffix-link structure ensures that finding the longest extendable palindromic suffix takes amortized O(1) time per character because each suffix-link traversal moves to a shorter palindrome, and we can charge the traversal cost to the palindrome length. Since the total length of all palindromes is at most n, the total traversal cost is O(n). This linear-time preprocessing enables constant-time query answers because we precompute M(m), R(m), and I(m) for all prefixes during the single pass through the string.


**[THOUGHT_05_02]**

Let me prove that at most one new palindrome can be introduced per character step. Suppose, for contradiction, that two different palindromes P1 and P2 could be newly introduced when adding character g[i] to prefix g[1..i-1]. Without loss of generality, assume P1 is shorter than P2. Since both are palindromes ending at position i, P1 must be a proper palindromic suffix of P2. Now, the suffix-link invariant states that if a palindrome P exists in the tree, then all its proper palindromic suffixes also exist in the tree. Since P2 would be created in this step, its proper palindromic suffix P1 must already exist in the tree from a previous step. This contradicts our assumption that P1 is newly introduced. Therefore, at most one new palindrome can be created per character position.


---

**[CHAIN_06]**

Implementation essentials, numeric bounds, and pitfalls


**[THOUGHT_06_01]**

Let me analyze the implementation details systematically. The Eertree uses two sentinel states: root node -1 (length -1, self-linked) and root node 0 (length 0, linked to -1). These sentinels handle edge cases for single-character palindromes and empty strings. For transition compactness with fixed alphabets, we use array<int, 26> nextNode where transitions are indexed by g[i]-'a' mapping to [0,25]. Guard conditions include checking position - currentLength - 1 >= 0 before accessing processedCharacters[position - currentLength - 1] to prevent out-of-bounds access. For numeric bounds M(m) ≤ n ≤ 2×10^5 (fits in 32-bit), R(m) ≤ n ≤ 2×10^5 (fits in 32-bit), but I(m) can reach Θ(n²) = Θ(4×10^10) for homogeneous strings, requiring 64-bit integers. Per-test reinitialization clears all data structures between test cases to prevent state leakage between different input strings.


**[THOUGHT_06_02]**

Transitions are indexed by $g[i]-'a'$ to map to $[0,25]$. The Eertree here is specialized to lowercase English letters, matching the problem statement.




**[THOUGHT_06_03]**

Let me analyze the space complexity of the Eertree. The Eertree has two special root nodes (length -1 and 0) plus at most one node created per character position. Since each character can create at most one new palindrome node, the total number of nodes is at most $n+2$. Each node stores: length (1 int), link (1 int), and nextNode array (26 ints), totaling 28 integers per node. The arrays $count$, $maxLength$, and $sumLength$ each have size $n+1$. Therefore, total space is $O(n)$ nodes × 28 integers + $O(n)$ for arrays = $O(n)$ space complexity.



---

**[CHAIN_07]**

Validation, examples, and complexity summary



**[THOUGHT_07_01]**

Let me verify the algorithm with examples and analyze complexity. For $g=\text{"aaa"}$: at position 1, create palindrome "a" (length 1) → $(M,R,I)=(1,1,1)$; at position 2, create "aa" (length 2) → $(M,R,I)=(2,2,3)$; at position 3, create "aaa" (length 3) → $(M,R,I)=(3,3,6)$. For $g=\text{"ababa"}$: positions 1-5 create palindromes of lengths 1,1,3,1,5 respectively → $(M,R,I)$: $(1,1,1),(2,1,2),(3,3,5),(4,3,8),(5,5,13)$. The complexity analysis each character causes at most one node creation and constant amortized suffix-link traversals, giving $O(n)$ total time. Query answering is $O(1)$ per query using precomputed arrays. Space is $O(n)$ for nodes plus $O(n)$ for arrays. Correctness each distinct palindrome is created exactly once at its first occurrence because the Eertree's suffix-link structure ensures we find the longest extendable palindromic suffix, and shorter ones already exist.


**[THOUGHT_07_02]**

When the extension leads to an already existing node via transition, $count$, $maxLength$, $sumLength$ carry over unchanged for that prefix.


**[THOUGHT_07_03]**

Reinitialize the Eertree and arrays per test to avoid state bleed. This guarantees that answers for each test depend only on its own input.


---

**[CHAIN_08]**

Correctness arguments and numeric bounds



**[THOUGHT_08_01]**

Let me prove that at most one new palindrome node is created per character position. When appending character $g[i]$ to prefix $g[1..i-1]$, we need to find the longest palindromic suffix that can be extended by $g[i]$ on both ends. The key insight if a shorter palindromic suffix can be extended by $g[i]$, then a longer palindromic suffix containing it can also be extended. This is because if palindrome $P$ centered at position $j$ can be extended by $g[i]$, then any longer palindrome containing $P$ and centered at $j$ can also be extended. The suffix-link structure ensures we find the longest such extendable palindrome. Since only the longest extendable palindromic suffix can yield new content (shorter ones already exist in the tree), at most one new node is created per position.


**[THOUGHT_08_02]**

Let me prove the correctness of the counting mechanism. Each distinct palindrome corresponds to exactly one node created at its first occurrence because: (1) the Eertree's structure ensures each palindrome is represented by exactly one node, (2) nodes are only created when a new palindrome is first encountered, and (3) the suffix-link traversal ensures we find the longest extendable palindromic suffix, so shorter palindromes that could be extended already exist. Therefore: $M(m)$ equals the number of nodes created up to prefix $m$ (count of distinct palindromes); $R(m)$ is the maximum created length up to $m$ (longest palindrome seen); $I(m)$ is the sum of created lengths up to $m$ (sum of all distinct palindrome lengths).



**[THOUGHT_08_03]**

Let me analyze the time complexity. Each character position requires walking suffix links to find the longest extendable palindromic suffix. The key insight each suffix-link traversal moves to a shorter palindrome, and we can charge the traversal cost to the palindrome length. Since the total length of all palindromes is at most $n$ (each character contributes to at most one palindrome), the total suffix-link traversal cost is $O(n)$. Creating one node per character (if needed) takes $O(1)$ time. Therefore, the total time is $O(n)$. Answering $q$ queries takes $O(q)$ time using precomputed arrays. Space is $O(n)$ for nodes plus $O(n)$ for the three arrays of size $n+1$.


**[THOUGHT_08_04]**

Let me analyze the numeric bounds for the output values. For $I(m)$ in the worst case of homogeneous strings like "aaaaa", we have palindromes of lengths 1, 2, ..., $m$, so $I(m) = 1 + 2 + \ldots + m = \frac{m(m+1)}{2} = \Theta(m^2)$. For $m = n = 2 \cdot 10^5$, this gives $I(n) \approx 2 \cdot 10^{10}$, which exceeds 32-bit integer range. Therefore, 64-bit integers are required for $sumLength$. For $M(m)$ at most $n$ distinct palindromes, so $M(m) \le n \le 2 \cdot 10^5$, fitting in 32-bit. For $R(m)$ at most $n$ (longest palindrome length), so $R(m) \le n \le 2 \cdot 10^5$, fitting in 32-bit.


---

**[CHAIN_09]**

Implementation details and pitfalls to avoid



**[THOUGHT_09_01]**

Nodes store $length$, $link$, and $nextNode[26]$. Two roots exist: length $-1$ with a self-link and length $0$ linked to $-1$. A $suffix$ pointer tracks the longest palindromic suffix of the current prefix.



**[THOUGHT_09_02]**

Push the new character (as $0\ldots 25$). Follow suffix links until the extension check $(position - currentLength - 1 \ge 0 \wedge data[position - currentLength - 1] = charIndex)$ holds. If a transition exists, move $suffix$ there (no new node). Otherwise, create a node of length $currentLength+2$, wire the transition, set $link$ to $1$ if length $=1$, else find the proper link via another suffix walk, then finalize $suffix$ to the new node.


**[THOUGHT_09_03]**

For each position $i$, let $created$ indicate whether a node was added and $L$ be its length. Update the count array by adding one if a new node was created, update the maximum length array with the new length if it's larger, and add the new length to the sum array if a node was created.


**[THOUGHT_09_04]**

Reinitialize per test case; ensure index guard $(position - currentLength - 1 \ge 0)$; alphabet indices stay within $[0,25]$; use 64-bit for $sumLength$; do not double count when no new node is created.


---

**[CHAIN_10]**

Positioning versus alternate approaches


**[THOUGHT_10_01]**

Let me compare Eertree to brute force approaches. Brute force requires enumerating all $O(m^2)$ substrings per prefix of length $m$, leading to $O(n^3)$ total time. Eertree avoids this by maintaining the palindromic structure incrementally: each character creates at most one new palindrome node, and the suffix-link structure ensures we find the longest extendable palindromic suffix efficiently. This reduces the time complexity from $O(n^3)$ (brute force) to $O(n)$ (Eertree) by avoiding the need to enumerate and check all possible substrings.


**[THOUGHT_10_02]**

Let me compare Eertree to Manacher plus hashing. Manacher finds all palindrome radii in $O(n)$ time, but to get distinct palindromes by content, we need to materialize all $\Theta(n^2)$ palindromic substrings in worst-case strings (like homogeneous strings). This requires $O(n^2)$ space and $O(n^2 \log n)$ time for hash-based deduplication. Eertree avoids this by maintaining only the distinct palindromes as needed: it stores at most $n+2$ nodes (one per character plus roots) and creates palindromes incrementally, avoiding the need to materialize and deduplicate all possible palindromes.



**[THOUGHT_10_03]**

Let me compare Eertree to suffix automaton approaches. Suffix automata can be augmented to track palindromic substrings, but this requires complex modifications to handle palindrome-specific properties like symmetry and earliest occurrence timing. The Eertree is specifically designed for palindromes: it naturally maintains the palindromic structure through its suffix-link organization and directly tracks when each distinct palindrome first appears. This makes maintaining $M(m)$ (count), $R(m)$ (maximum length), and $I(m)$ (sum of lengths) straightforward without requiring heavy augmentations or complex data structure modifications.


---

**[RESPONSE]**

**1. Problem Understanding**

We are given a lowercase string $g$ of length $n$. For any prefix $g[1..m]$, define:
- $M(m)$: the number of distinct palindromic substrings within the prefix $g[1..m]$, where distinctness is by content.
- $R(m)$: the maximum length among all palindromic substrings within $g[1..m]$.
- $I(m)$: the sum of lengths of all distinct palindromic substrings within $g[1..m]$.

We are given $q$ queries, each query provides a prefix length $m$, and we must output $M(m)$, $R(m)$, and $I(m)$ for that prefix.

Key observations:
- Extending the string by one character to the right introduces at most one new distinct palindromic substring.
- This suggests an online, incremental approach where we process characters from left to right and maintain $M$, $R$, and $I$ for all prefixes.

Constraints and implications:
- $1 \le n \le 2 \cdot 10^{5}$
- $1 \le q \le 2 \cdot 10^{5}$
- $1 \le m_i \le n$ for each query
- $\sum n \le 2 \cdot 10^{5}$ and $\sum q \le 2 \cdot 10^{5}$ over all test cases
- Any solution should run in near-linear time overall, and we must use 64-bit integers for $I(m)$ because it can be as large as $\Theta(n^{2})$.


**2. Approach Analysis**

**2.1 Brute Force Approach - $O(n^4)$**
Enumerate all possible substrings for each prefix and check palindromicity naively. For each prefix of length $m$, there are $O(m^2)$ substrings, and a naive palindrome check costs $O(m)$ per substring, yielding $O(m^3)$ per prefix. Summed over $m=1\ldots n$, this is $\sum m^3 = O(n^4)$. This approach is infeasible for the given constraints (on the order of $2 \times 10^{10}$ substring checks for $n=2 \times 10^5$ even ignoring the per-substring check).

**2.2 Optimized Enumeration - $O(n^3)$ (all prefixes)**
Using rolling hashes, each palindrome check can be reduced to $O(1)$ per substring. Rolling hashes work by computing polynomial hash values for substrings using a base $b$ and modulo $p$: $h(s[i..j]) = \sum_{k=i}^{j} s[k] \cdot b^{j-k} \bmod p$. To check if a substring is a palindrome, we compute both forward hash $h(s[i..j])$ and reverse hash $h(s[j..i])$ and compare them. The reverse hash can be computed as $h(s[j..i]) = \sum_{k=i}^{j} s[k] \cdot b^{k-i} \bmod p$. However, since the problem requires handling all prefixes, we need to recompute this independently for every prefix, yielding $\sum m^2 = O(n^3)$. Worst-case distinct-palindrome materialization remains too large for the constraints.

**2.3 Manacher's Algorithm with Hashing - $O(n^2 \log n)$**
Manacher's algorithm finds palindrome radii in $O(n)$ time by expanding around centers and leveraging symmetry properties. The algorithm handles both odd and even-length palindromes by inserting sentinel characters (e.g., '#' between each character). For each position $i$, it maintains the rightmost palindrome boundary and uses previously computed information to avoid redundant work. The radius array $R[i]$ stores the radius of the longest palindrome centered at position $i$. However, when deduplicating distinct palindromic substrings across all positions using balanced maps or ordered sets (to maintain canonical representatives and earliest-introduction order), each insertion/lookup contributes a $\log n$ factor, and there are $\Theta(n^2)$ candidates in the worst case (e.g., homogeneous strings). Hence a realistic upper bound is $O(n^2 \log n)$ time and $O(n^2)$ space in the worst case. This remains too slow for the constraints.

**2.4 Optimal Approach - $O(n)$**
We use a Palindromic Tree (Eertree), a linear-time data structure that stores all distinct palindromic substrings of the processed prefix. It has
- Two root nodes one with length $-1$ (virtual) and one with length $0$ (empty).
- Each node represents a distinct palindrome, stores its length, a suffix link to the largest proper palindromic suffix, and transitions by characters.

Processing steps:
1. Initialize the Eertree with the two roots and set the current suffix pointer to the empty root.
2. For each new character $g[i]$:
   - Walk suffix links from the current longest palindromic suffix to find the longest suffix that can be extended by $g[i]$ on both ends.
   - If the resulting palindrome already exists, no new node is created.
   - Otherwise, create a new node with length equal to the extended palindrome's length and set its suffix link by finding the next largest proper palindromic suffix that extends appropriately.
3. Maintain three arrays for prefixes:
   - $count[m] = M(m)$: increment by 1 only when a new node is created.
   - $maxLength[m] = R(m)$: update with the maximum of the previous value and the newly created palindrome length.
   - $sumLength[m] = I(m)$: add the length of the newly created palindrome when it occurs.

Correctness rationale:
- Each distinct palindrome is created exactly once, at its first appearance. Thus $M(m)$ is the number of created nodes up to $m$, $R(m)$ is the maximum created length up to $m$, and $I(m)$ sums created lengths once at their introduction.

Complexity:
- Building the Eertree is $O(n)$ since each character causes at most one node creation and a constant amortized number of suffix-link traversals.
- Answering each query is $O(1)$ by indexing precomputed arrays.
- Overall complexity across all tests is $O(\sum n + \sum q)$, and space is $O(n)$.


**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <array>
#include <string>
#include <algorithm>
#include <utility>
using namespace std;

/**
 * @class Eertree
 * @brief Palindromic Tree (Eertree) to store all distinct palindromic substrings.
 *
 * Supports online insertion of characters and ensures at most one new
 * palindrome node is created per character.
 */
class Eertree
{
public:
    /** @var kAlphabetSize Size of the alphabet (26 for lowercase English letters) */
    static constexpr int kAlphabetSize = 26;
    /**
     * @struct Node
     * @brief Node representing a distinct palindrome in the Eertree.
     *
     * @var Node::length Length of the palindrome represented by this node.
     * @var Node::link Suffix link to the largest proper palindromic suffix node.
     * @var Node::nextNode Transitions by character to other palindrome nodes.
     */
    struct Node
    {
        int length;
        int link;
        array<int, kAlphabetSize> nextNode;
        /**
         * @brief Construct a new Node with a given palindrome length.
         * @param length Length of the palindrome represented by this node.
         */
        Node(int length = 0) : length(length), link(0) { nextNode.fill(-1); }
    };

    /**
     * @brief Constructs the Eertree and optionally preallocates memory.
     * @param numElements Expected maximum length of the string to process.
     */
    explicit Eertree(int numElements = 0) { init(numElements); }

    /**
     * @brief Reinitializes the Eertree to process a new string.
     * @param numElements Expected maximum length of the string to process.
     */
    void init(int numElements)
    {
        palindromeNodes.clear();
        processedCharacters.clear();
        palindromeNodes.reserve(numElements + 3);
        processedCharacters.reserve(numElements);

        // Root -1: length = -1, link to itself
        palindromeNodes.emplace_back(Node(-1));
        palindromeNodes[0].link = 0;

        // Root 0: length = 0, link to root -1
        palindromeNodes.emplace_back(Node(0));
        palindromeNodes[1].link = 0;

        currentSuffixNode = 1; // Start with the empty string root
    }

    /**
     * @brief Adds a character to the end of the current string.
     * @param charIndex Zero-based index of the character in [0..25].
     * @return Pair {createdNewNode, createdPalindromeLength}.
     */
    pair<bool, int> addChar(int charIndex)
    {
        processedCharacters.push_back(charIndex);
        int position = static_cast<int>(processedCharacters.size()) - 1;

        int current = currentSuffixNode;
        while (true)
        {
            int currentLength = palindromeNodes[current].length;
            if (position - currentLength - 1 >= 0 && processedCharacters[position - currentLength - 1] == charIndex)
            {
                break;
            }
            current = palindromeNodes[current].link;
        }

        if (palindromeNodes[current].nextNode[charIndex] != -1)
        {
            currentSuffixNode = palindromeNodes[current].nextNode[charIndex];
            return {false, 0};
        }

        int newNodeIndex = static_cast<int>(palindromeNodes.size());
        palindromeNodes.emplace_back(Node(palindromeNodes[current].length + 2));
        palindromeNodes[current].nextNode[charIndex] = newNodeIndex;

        if (palindromeNodes[newNodeIndex].length == 1)
        {
            palindromeNodes[newNodeIndex].link = 1;
        }
        else
        {
            int linkCandidate = palindromeNodes[current].link;
            while (true)
            {
                int candidateLength = palindromeNodes[linkCandidate].length;
                if (position - candidateLength - 1 >= 0 && processedCharacters[position - candidateLength - 1] == charIndex)
                {
                    break;
                }
                linkCandidate = palindromeNodes[linkCandidate].link;
            }
            palindromeNodes[newNodeIndex].link = palindromeNodes[linkCandidate].nextNode[charIndex];
        }

        currentSuffixNode = newNodeIndex;
        return {true, palindromeNodes[newNodeIndex].length};
    }

private:
    /** @var palindromeNodes All nodes in the Eertree */
    vector<Node> palindromeNodes;
    /** @var processedCharacters Processed characters as integers [0..25] */
    vector<int> processedCharacters;
    /** @var currentSuffixNode Node index of the longest palindromic suffix */
    int currentSuffixNode;
};

/**
 * @brief Main function to solve the Mirror-Glyph Chronicles problem.
 *
 * Reads test cases, processes each string using Eertree, and answers queries.
 *
 * @return int Exit status (0 for success)
 */
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int testCases;
    if (!(cin >> testCases))
    {
        return 0;
    }
    while (testCases--)
    {
        int stringLength, queryCount;
        cin >> stringLength >> queryCount;
        string inputString;
        cin >> inputString;

        Eertree eertree(stringLength);
        vector<long long> sumLength(stringLength + 1, 0); // I[m]
        vector<int> count(stringLength + 1, 0);          // M[m]
        vector<int> maxLength(stringLength + 1, 0);       // R[m]

        for (int i = 0; i < stringLength; ++i)
        {
            auto result = eertree.addChar(inputString[i] - 'a');
            int createdLength = result.second;
            count[i + 1] = count[i] + (result.first ? 1 : 0);
            maxLength[i + 1] = max(maxLength[i], (result.first ? createdLength : 0));
            sumLength[i + 1] = sumLength[i] + (result.first ? static_cast<long long>(createdLength) : 0LL);
        }

        for (int i = 0; i < queryCount; ++i)
        {
            int prefixLength;
            cin >> prefixLength;
            cout << count[prefixLength] << " " << maxLength[prefixLength] << " " << sumLength[prefixLength] << "\n";
        }
    }
    return 0;
}
```

**4. Code Explanation**

- We build an Eertree to maintain all distinct palindromic substrings of the current prefix.
- The tree has two special root nodes: one with length -1 and one with length 0. The suffix pointer tracks the longest palindromic suffix of the current prefix.
- For each character $g[i]$, we:
  - Traverse suffix links from the current suffix until we find a palindrome that can be extended by $g[i]$.
  - If the resulting palindrome already exists, no new node is created.
  - Otherwise, we create one new node with length equal to the extended palindrome length and set its suffix link accordingly.
- Arrays $count$, $maxLength$, and $sumLength$ track, respectively, the number of distinct palindromes, the best palindrome length, and the sum of lengths of distinct palindromes for every prefix. Each time a new node is created with length $L$, we increment $count$, update $maxLength$ with $L$ if needed, and add $L$ to $sumLength$.
- Finally, we answer each query $m$ in $O(1)$ using these arrays: print $count[m]$, $maxLength[m]$, $sumLength[m]$.

Example on $g = "ababa"$:
- After processing $"a"$: new $"a"$ created, $M = 1$, $R = 1$, $I = 1$.
- After processing $"ab"$: new $"b"$ created, $M = 2$, $R = 1$, $I = 2$.
- After processing $"aba"$: new $"aba"$ created, $M = 3$, $R = 3$, $I = 5$.
- After processing $"abab"$: new $"bab"$ created, $M = 4$, $R = 3$, $I = 8$.
- After processing $"ababa"$: new $"ababa"$ created, $M = 5$, $R = 5$, $I = 13$.

This matches the expected outputs.

**5. Time and Space Complexity**

- Building the Eertree over the string is $O(n)$ because each character causes at most one node creation and constant amortized traversal along suffix links.
- Each query is answered in $O(1)$.
- Overall time across all tests is $O(\sum n + \sum q)$.
- Space usage is $O(n)$ nodes in the Eertree plus $O(n)$ for the arrays. Use 64-bit integers for $I(m)$ due to potential growth up to $\Theta(n^{2})$.

**6. Conclusion**

By leveraging the Eertree, we process the string online and maintain counts, maximum lengths, and total lengths of distinct palindromic substrings for every prefix in linear time. Each appended character introduces at most one new distinct palindrome, enabling simple $O(1)$ updates to $M$, $R$, and $I$. The solution answers queries in $O(1)$ after preprocessing, fits within memory limits, and adheres to the problem's constraints.