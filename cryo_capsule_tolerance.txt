# Metadata

**Category:** - Coding  

**Topic:** - Competitive Programming  

**Subtopic:** - ["Greedy Algorithms", "Searching Algorithms", "Divide and Conquer", "Arrays and Lists", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard  

**Languages:** - C++  

**Number of Approaches:** - 4, ($O(2^n)$ → $O(n)$ → $O(n)$  → $O\!\big(n \log (t_n - t_1 + 1)\big)$ )

**Number of Chains:** - 10  

**GitHub URL:** https://github.com/NOI-gen/cryo_capsule_tolerance_calibration_2


---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**Cryo-Capsule Tolerance Calibration**

Time Limit: **2 seconds**

Memory Limit: **10 MB**

On an asteroid research station, incoming stardust samples are fragile and must be snap-frozen to preserve their structure. The station owns at most $B$ cryo-capsules for the entire shift. Each capsule can preserve up to $k$ samples and, once activated at an integer minute $x$, it stays cold and usable at integer minutes $x, x+1, \dots, x+d$. Samples arrive at integer minutes $t_1, t_2, \dots, t_n$ in non-decreasing order. A sample may sit at room temperature for at most $w$ minutes after it arrives; within that tolerance it can be frozen at any integer minute in $[t_i, t_i + w]$. Freezing is instantaneous and the lab crew is abundant.

Your task is to determine, for each scenario, the minimum waiting tolerance $w$ so that all samples can be frozen using at most $B$ cryo-capsules. If this is impossible no matter how large $w$ is, output $-1$.

Notes:
- A capsule activated at time $x$ can be used at times $x, x+1, \dots, x+d$.
- A sample arriving at time $t_i$ can be frozen at any time in $[t_i, t_i + w]$ (inclusive), at integer minutes only.
- A capsule can freeze at most $k$ samples total across its usable lifetime.
- Multiple capsules may be activated at the same time; the crew is unlimited.

**Input Format:-**

- The first line contains an integer $t$ — the number of scenarios.
- For each scenario:
  - The first line contains four integers $n$, $k$, $d$, $B$:
    - $n$ — number of samples,
    - $k$ — maximum number of samples one capsule can preserve,
    - $d$ — the number of minutes a capsule remains cold after activation (inclusive window $x..x+d$),
    - $B$ — maximum number of capsules available.
  - The second line contains $n$ integers $t_1, t_2, \dots, t_n$ — a non-decreasing sequence of arrival times.

**Output Format:-**

- For each scenario, print a single integer — the smallest $w$ such that all samples can be frozen using at most $B$ capsules, or $-1$ if impossible.

**Constraints:-**

- $1 \le t \le 2\cdot 10^5$
- $1 \le n, k \le 2\cdot 10^5$
- $0 \le d \le 10^9$
- $1 \le B \le 2\cdot 10^5$
- $0 \le t_i \le 10^9$
- The sequence $t_1 \le t_2 \le \dots \le t_n$ is non-decreasing
- The sum of $n$ across all scenarios does not exceed $2\cdot 10^5$

**Examples:-**
 - **Input:**
```
1
6 2 1 3
0 0 5 5 11 11
```

 - **Output:**
```
0
```

 - **Input:**
```
1
4 2 1 1
0 1 2 3
```

 - **Output:**
```
-1
```

**Note:-**
In the first example, with $n=6$, $k=2$, $d=1$, $B=3$, and arrivals $[0,0,5,5,11,11]$, setting $w=0$ means each sample must be frozen exactly at its arrival time. Activate three capsules at $x=0$, $x=5$, and $x=11$. Each capsule, with capacity $k=2$, freezes the two samples at its activation minute (since freezing is instantaneous and there is no per-minute limit). Exactly $B=3$ capsules are used, so $w=0$ is feasible and minimal.

In the first example, with $n=4$, $k=2$, $d=1$, $B=1$, and arrivals $[0,1,2,3]$, the total capacity bound $n \le B \cdot k$ is violated since $4 > 1 \cdot 2$. Therefore, no matter how large $w$ is, it is impossible to freeze all samples using at most $B$ capsules, so the answer is $-1$.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarify the problem requirements and constraints precisely.

**[THOUGHT_01_01]**

We receive $n$ samples at integer arrival times $t_1 \le t_2 \le \dots \le t_n$. We have at most $B$ cryo-capsules. When a capsule is activated at an integer minute $x$, it can be used at every integer minute in $[x,\,x+d]$ (inclusive) and can freeze at most $k$ samples in total. Each sample $i$ must be frozen at some integer minute in $[t_i,\,t_i + w]$, where $w$ is the waiting tolerance we will determine.

The goal is to compute the smallest $w$ such that all $n$ samples can be frozen using at most $B$ capsules; if no such $w$ exists (for any $w$), output $-1$.



**[THOUGHT_01_02]**

A necessary capacity condition is $B \ge \left\lceil \dfrac{n}{k} \right\rceil$; otherwise, even with infinite $w$, total capacity $Bk$ is insufficient for $n$ samples.


**[THOUGHT_01_03]**

For a fixed $w$, a single capsule that starts covering from index $i$ can serve a **consecutive** block $[i,\,j]$ subject to two constraints:
1) capacity: $j - i + 1 \le k$,
2) time reach: $t_j \le t_i + w + d$.

We do **not** need to pin down the exact activation time $x$; feasibility of covering $[i,\,j]$ is characterized by $t_j \le t_i + w + d$ together with the capacity bound.



**[THOUGHT_01_04]**

Edge-conditions to keep in view:
- $d=0$ implies a capsule is usable only at a single minute; the reach condition becomes $t_j \le t_i + w$.
- Duplicate arrival times are allowed and are covered by the inclusive comparison $t_j \le t_i + w + d$.
- All times and bounds must be handled with $64$-bit integers.

---

**[CHAIN_02]**

Construct comprehensive test cases to cover typical and corner scenarios.

**[THOUGHT_02_01]**

 Single-sample sanity

- Parameters: $n=1$, $k=3$, $d=5$, $B=1$; arrivals $t=\langle 42\rangle$.
- Claim (Output): minimal $w=0$.
- Analysis: With $w=0$, the sample must be frozen at minute $42$. One capsule can be activated at $x=42$ and used at minute $42$ (since $d\ge 0$), serving $1\le k$ samples. As $w$ cannot be negative, $w=0$ is minimal.





**[THOUGHT_02_02] **

Capacity-bound impossibility

- Parameters: $n=5$, $k=2$, $d=10$, $B=2$; arrivals $t=\langle 0,0,0,0,0\rangle$.
- Claim (Output): $-1$.
- Analysis: The total capacity is $Bk=4<n=5$. Since each capsule can freeze at most $k$ samples overall, no $w$ can make this feasible. Therefore the answer is $-1$.




**[THOUGHT_02_03]**

All arrivals equal, zero lifespan

- Parameters: $n=4$, $k=2$, $d=0$, $B=2$; arrivals $t=\langle 7,7,7,7\rangle$.
- Claim (Output): minimal $w=0$.
- Analysis: With $w=0$ and $d=0$, freezing must occur at the arrival minute $7$. Two capsules activated at $x=7$ are each usable only at minute $7$, but together they can freeze $2+2=4$ samples, matching $n=4$. As $w$ cannot be negative, $w=0$ is minimal.




**[THOUGHT_02_04]**

Lifespan-dominant scenario

- Parameters: $n=5$, $k=2$, $d=100$, $B=3$; arrivals $t=\langle 0,1,2,100,101\rangle$.
- Claim (Output): minimal $w=0$.
- Analysis: With $w=0$, each sample must be frozen at its arrival minute. A capsule remains usable across many minutes ($d=100$) but still counts capacity across its lifetime. One feasible schedule:  
  - Capsule A serves minutes $0$ and $1$ (two samples).  
  - Capsule B serves minutes $2$ and $100$ (two samples).  
  - Capsule C serves minute $101$ (one sample).  
  This uses $3$ capsules $\le B$ with no waiting; hence $w=0$ suffices and is minimal.




**[THOUGHT_02_05]**

Tight lifespan forcing waiting

- Parameters: $n=6$, $k=2$, $d=0$, $B=3$; arrivals $t=\langle 0,3,3,6,6,6\rangle$.
- Claim (Output): minimal $w=3$.
- Analysis:
  - **Feasibility with $w=3$:** Use one capsule at minute $3$ to freeze samples at $0$ (delayed to $3$ since $3\in[0,0+3]$) and one of the $3$’s. Use two capsules at minute $6$ to freeze the three $6$’s and the remaining $3$ (delayed to $6$ since $6\in[3,3+3]$). Each capsule handles at most $2$ samples, and the total capsules used is $3$.
  - **Infeasibility with $w\le 2$:** The two $3$’s cannot be frozen at minute $6$ (since $6\notin[3,3+2]$), so at least one capsule must be at minute $3$ for those two samples. The sample at $0$ cannot be frozen at minute $3$ if $w\le 2$ (since $3\notin[0,0+2]$), thus it needs a separate minute. The three $6$’s require at least two capsules (capacity $2$ each). That totals at least $1+1+2=4$ capsules $>B$. Hence $w=3$ is the minimum.




**[THOUGHT_02_06]**

Duplicates and boundary equality

- Parameters: $n=4$, $k=3$, $d=0$, $B=2$; arrivals $t=\langle 1,1,2,5\rangle$.
- Claim (Output): minimal $w=1$.
- Analysis: With $w=1$, choose two freezing minutes: $2$ and $5$. The two $1$’s and the $2$ can all be frozen at minute $2$ (since $2\in[1,1+1]$ and $2\in[2,2+1]$), filling one capsule with $3$ samples ($\le k$). The sample at $5$ is frozen at minute $5$ using the second capsule. With $w=0$, minutes $1$, $2$, and $5$ would all be needed, exceeding $B=2$, so $w=1$ is minimal.




**[THOUGHT_02_07]**

Monotonicity check

- Parameters: $n=4$, $k=2$, $d=0$, $B=2$; arrivals $t=\langle 0,2,4,6\rangle$.
- Claim (Output): minimal $w=2$.
- Analysis: With $w=2$, freeze two samples at minute $2$ (the sample at $0$ delayed to $2$ since $2\in[0,0+2]$, and the sample at $2$), and the other two at minute $6$ (the sample at $4$ delayed to $6$ since $6\in[4,4+2]$, and the sample at $6$). This uses exactly $2$ capsules. For $w\le 1$, the sample at $0$ cannot be delayed to minute $2$ (since $2\notin[0,0+1]$), forcing at least three distinct freezing minutes and hence $\ge 3$ capsules, which exceeds $B$.




**[THOUGHT_02_08]**

Scale and limits

- Parameters: $n=200{,}000$, $k=2$, $d=0$, $B=100{,}000$; arrivals $t=\langle \underbrace{0,\dots,0}_{200{,}000\ \text{times}}\rangle$.
- Claim (Output): minimal $w=0$.
- Analysis: At minute $0$, one can activate $100{,}000$ capsules (crew is unbounded), each serving at most $2$ samples. Total capacity $B k = 200{,}000$ exactly matches $n$, so all samples are frozen at arrival with $w=0$. As waiting cannot be negative, $w=0$ is minimal.

---

**[CHAIN_03]**

Explore brute-force activation enumeration.

**[THOUGHT_03_01]**

Trying to enumerate activation schedules: A naive plan is to try every $w$ from $0$ up to a large bound (say $t_n - t_1$) and, for each $w$, enumerate all possible activation schedules for up to $B$ capsules. Since each sample $i$ allows any $x \in [t_i, t_i + w]$, the number of candidate schedules explodes combinatorially with $n$ and the width of waiting intervals.




**[THOUGHT_03_02]**

Quantifying the explosion: Even if we restrict activations to interval endpoints, the number of combinations remains exponential in $n$ (roughly branching by choices of which sample anchors each capsule and its exact activation time). For $n$ up to $2 \cdot 10^5$, such enumeration is entirely infeasible.




**[THOUGHT_03_03]**

Rejecting time-indexed DP: Considering a DP over time values (activating capsules and processing samples minute by minute) is not viable because $t_i$ and $d$ are up to $10^9$. Discretizing all potentially relevant times per $w$ still leaves an intractable state space, coupled with complex transitions over overlapping windows.




**[THOUGHT_03_04]**

The state space for brute-force schedules or time-indexed DP is prohibitive: activation choices per sample yield exponentially many combinations in $n$, and discretizing the time axis up to $10^9$ creates intractable DP tables or transitions across overlapping windows. Therefore, brute force and time-domain DP are infeasible. This motivates avoiding iteration over time or enumeration of activations and instead seeking a linear-time, index-based decision procedure for any fixed $w$.

---

**[CHAIN_04]**

Attempt a capacity-only greedy

**[THOUGHT_04_01]**

Consider grouping samples purely by capacity into contiguous blocks of size at most $k$, ignoring $d$. This would suggest exactly $\left\lceil \dfrac{n}{k} \right\rceil$ capsules regardless of time spacing or lifespan.



**[THOUGHT_04_02]**

This capacity-only view neglects that a capsule activated at time $x$ is usable only within $[x,\,x+d]$. When $d$ is small (e.g., $d=0$), the samples a capsule can serve may need to be frozen at the same minute (or within a very narrow horizon) relative to their arrivals, which the capacity-only partition may violate.



**[THOUGHT_04_03]**

Counterexamples:
- With $t=[0,10]$, $k=2$, $d=0$, $B=1$, capacity-only grouping yields one block, but a single capsule cannot serve both minutes since it is usable only at one minute.  
- With $t=[1,1,2,5]$, $k=3$, $d=0$, $B=2$, setting $w=0$ fails to merge $2$ and $1$ into the same minute; some waiting is required, contradicting capacity-only grouping.



**[THOUGHT_04_04]**

Because reach is limited to $[x,\,x+d]$, any correct grouping must respect both capacity ($\le k$ per capsule) and the time-reach condition $t_j \le t_i + w + d$. Ignoring $d$ therefore leads to incorrect feasibility judgments.

---

**[CHAIN_05]**

Adopt a greedy per-tolerance strategy by delaying activations to the latest feasible time.

**[THOUGHT_05_01]**

Fix a tolerance $w$. Let $i$ be the earliest uncovered index. A single capsule starting at $i$ can cover a maximal consecutive block up to the largest $j$ satisfying both:
- capacity: $j - i + 1 \le k$, and
- reach: $t_j \le t_i + w + d$.
We do not need to specify an explicit activation time $x$; the inequality characterizes feasibility of covering $[i,\,j]$.



**[THOUGHT_05_02]**

Assign $[i,\,j]$ to one capsule, then set $i \leftarrow j+1$ and repeat until all samples are covered. The number of capsules used for this $w$ is $f(w)$.




**[THOUGHT_05_03]**

By an exchange argument, if a first block covers fewer than the maximal feasible $[i,\,j]$, replacing it with the maximal block cannot increase the total number of capsules. Applying this inductively proves minimality of the greedy decision for fixed $w$.



**[THOUGHT_05_04]**

Edge consistency:
- For $d=0$, the reach reduces to $t_j \le t_i + w$ and the same sweep applies.  
- Duplicates are handled by the inclusive boundary $t_j \le t_i + w + d$.  
- Use $64$-bit arithmetic for $t_i + w + d$.



**[THOUGHT_05_05]**

**Time:** $O(n)$ per fixed $w$ using two pointers.  
**Space:** $O(1)$ auxiliary memory.

---

**[CHAIN_06]**

Leverage monotonicity of the capsule count in tolerance and search by binary splitting.

**[THOUGHT_06_01]**

Establishing non-increasing behavior: For $w_1 \le w_2$, the horizon from any anchor $t_i$ increases from $t_i + w_1 + d$ to $t_i + w_2 + d$, so the maximal block size cannot shrink. Therefore, $f(w)$, the minimal capsule count, is non-increasing in $w$.





**[THOUGHT_06_02]**

Bounding the search interval: If $B < \lceil n/k \rceil$, output $-1$ (capacity infeasible). Otherwise, a solution exists. An upper bound for $w$ is $t_n - t_1$: if $w \ge t_n - t_1$, then $t_i + w \ge t_n$ for every anchor $i$, so with $d \ge 0$, the horizon reaches at least $t_n$ and expiry no longer binds; only capacity limits blocks, making $f(w) = \lceil n/k \rceil \le B$.




**[THOUGHT_06_03]**

Conducting a binary search on $w$: Binary search the minimal $w$ in $[0, t_n - t_1]$ such that $f(w) \le B$. Each check evaluates $f(w)$ via the $O(n)$ greedy sweep. If $f(w) \le B$, try smaller $w$; otherwise, increase $w$.




**[THOUGHT_06_04]**

Each check is $O(n)$ and the binary search needs $O\!\big(\log (t_n - t_1 + 1)\big) \le 31$ iterations for times up to $10^9$. Hence, the per-scenario complexity is $O\!\big(n \log (t_n - t_1 + 1)\big)$ with small constants.





**[THOUGHT_06_05]**

Maintaining robustness: Use 64-bit arithmetic for time expressions. Respect inclusivity in comparisons. Ensure the binary search returns the smallest feasible $w$ by keeping the standard invariant where the right boundary is feasible and the left is infeasible during narrowing.

---

**[CHAIN_07]**

Prove correctness of the greedy decision and address special cases completely.

**[THOUGHT_07_01]**

Justifying delayed activation: In any feasible plan for fixed $w$, consider a capsule that serves the earliest uncovered sample $i$ and activates at $x \le t_i + w$. Delaying to $x' = t_i + w$ cannot exclude any later sample that was previously coverable, because the activation window shifts right and still intersects every sample’s waiting window: for any served sample $j \ge i$, we have $x' \le t_j + w$ and $t_j \le x' + d$.




**[THOUGHT_07_02]**

Ensuring contiguity of coverage: Arrivals are sorted, and the feasible set of samples for a capsule anchored at $i$ is a consecutive suffix from $i$, constrained by capacity and expiry. Skipping a feasible sample within this suffix makes it impossible to cover that sample with earlier capsules (they would violate maximality), and later capsules would add an extra block, never reducing the count.




**[THOUGHT_07_03]**

Proving global minimality: Any feasible solution must use at least one capsule to cover sample $i$. Since the greedy choice covers a maximal block from $i$, any alternative first capsule cannot cover more samples than the greedy block. Replacing the alternative’s first block with the greedy block does not increase the number of capsules. Repeating this exchange step inductively yields a schedule with no more capsules than any alternative, so the greedy is optimal for fixed $w$.



**[THOUGHT_07_04]**

Covering edge scenarios:
- $d=0$: Capsules are usable at a single minute; the horizon reduces to $t_i + w$, and the greedy remains valid.
- $k=1$: Each capsule covers exactly one sample, so $f(w)=n$ and feasibility reduces to $B \ge n$; the minimal $w$ is $0$.
- Duplicate times: Inclusivity ensures samples exactly at the horizon are covered; duplicates pose no special complications.
- $w=0$: Each sample must be processed at its arrival time; the greedy determines how many capsules are needed when activations cannot shift right.



**[THOUGHT_07_05]**

Confirming the upper bound on $w$: With $w = t_n - t_1$, every anchor $t_i$ satisfies $t_i + w \ge t_n$, hence expiry is irrelevant and capacity alone determines the number of capsules. Therefore, if $B \ge \lceil n/k \rceil$, the binary search interval always contains a feasible $w$.

---

**[CHAIN_08]**

Quantify the algorithm’s time and space complexity precisely.

**[THOUGHT_08_01]**

Per-check complexity: The greedy two-pointer sweep processes each sample index at most once; computing $f(w)$ is $O(n)$ time with $O(1)$ extra memory.




**[THOUGHT_08_02]**

Binary search overhead: The number of iterations is at most $\lceil \log_2(t_n - t_1 + 1) \rceil \le 31$ for arrival times up to $10^9$, contributing a small logarithmic factor.




**[THOUGHT_08_03]**

Total complexity across scenarios: With $\sum n \le 2 \cdot 10^5$, the total runtime is $O\!\left(\sum n \cdot \log (t_n - t_1 + 1)\right)$, which is practical in competitive settings. Memory usage remains $O(n)$ per scenario for storing the arrivals.




**[THOUGHT_08_04]**

Space guarantees: No auxiliary large data structures are used beyond the input array. All computations rely on a few 64-bit counters and indices.

---

**[CHAIN_09]**

Validate reasoning through targeted unit tests and careful dry runs.

**[THOUGHT_09_01]**

Dry run on a clustered case with $d=0$: Consider $t=[0,3,3,6,6,6]$, $k=2$, $d=0$, $B=3$. Check $w=2$:
- Anchor $i=0$, horizon $0+2=2$, cover only index $0$. Used $=1$.
- Anchor $i=1$, horizon $3+2=5$, cover indices $1,2$. Used $=2$.
- Anchor $i=3$, horizon $6+2=8$, cover indices $3,4$. Used $=3$.
- Remaining index $5$ needs another capsule. So $f(2)=4>3$.
Now check $w=3$:
- $i=0$, horizon $3$, cover $0,1,2$ (capped by capacity to $0,1,2$). Used $=1$.
- $i=3$, horizon $9$, cover $3,4$. Used $=2$.
- $i=5$, horizon $9$, cover $5$. Used $=3$.
We get $f(3)=3 \le B$, hence minimal $w=3$.





**[THOUGHT_09_02]**

Dry run on lifespan-dominant case: Let $t=[0,1,2,100,101]$, $k=2$, $d=100$, $B=3$. For $w=0$:
- $i=0$, horizon $100$, cover $0,1$ (capacity bound). Used $=1$.
- $i=2$, horizon $102$, cover $2,3$ (capacity bound). Used $=2$.
- $i=4$, horizon $201$, cover $4$. Used $=3$.
Thus $f(0)=3 \le B$, so the minimal $w$ is $0$.




**[THOUGHT_09_03]**

Monotonicity dry run on separated times: With $t=[0,2,4,6]$, $k=2$, $d=0$, $B=2$. For $w=0$, each sample must be processed at its own time, so each capsule can process only one sample and $f(0)=4$. For $w=2$, horizons allow grouping into two blocks: $[0,1]$ and $[2,3]$, so $f(2)=2$. This confirms that increasing $w$ does not increase $f(w)$.




**[THOUGHT_09_04]**

Capacity-bound negative case: With $n=5$, $k=2$, $B=2$, arbitrary $d$ and arrivals, $\lceil 5/2 \rceil=3 > 2$, thus return $-1$ immediately. This validates the early-exit capacity check.

---

**[CHAIN_10]**

Summarize implementation details and present a standards-compliant snippet.

**[THOUGHT_10_01]**

Finalize implementation guidelines:
- Use $64$-bit integers for time computations to avoid overflow.
- Short-circuit with the capacity lower bound: if $B < \lceil n/k \rceil$, print $-1$.
- Arrival times are input in non-decreasing order, so no sorting is needed.
- Perform a standard integer binary search on $[0,\,t_n - t_1]$, computing mid as $(lo + hi)\gg 1$ or $lo + \dfrac{(hi - lo)}{2}$.
- Keep I/O efficient (e.g., untie streams) and ensure outputs have no extra spaces or trailing spaces.





**[THOUGHT_10_02]**

Explain why the snippet satisfies the guidelines: The snippet includes required headers explicitly and uses only the C++ standard library. Identifiers follow lowerCamelCase for variables and functions, with clear, concise Doxygen comments documenting parameters and return values. Indentation is 4 spaces, comments use correct spacing and capitalization, and there are no trailing spaces. The code avoids external dependencies and uses 64-bit arithmetic for safety.




**[THOUGHT_10_03]**

Reconfirm behavior on curated tests: Running the approach on the earlier test cases yields the expected results: capacity-infeasible cases return $-1$; large-lifespan scenarios often give $w=0$; clustered arrivals with $d=0$ produce the minimal nonzero $w$ required to meet capacity with at most $B$ capsules. This consolidates correctness and adherence to constraints.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given $n$ samples arriving at integer times $t_1 \le t_2 \le \dots \le t_n$. There are at most $B$ cryo-capsules available. When a capsule is activated at an integer time $x$, it can be used at every integer minute in $[x, x+d]$ inclusive and can process at most $k$ samples in total. Each sample $i$ must be frozen at an integer minute within its waiting window $[t_i, t_i + w]$, where $w$ is a non-negative integer tolerance to be determined.

Task: For each scenario, find the minimum $w$ such that all samples can be frozen using at most $B$ capsules. If it is impossible regardless of $w$, output $-1$.

Key observations:
- Capacity lower bound: At least $\lceil n/k \rceil$ capsules are necessary. If $B < \lceil n/k \rceil$, the answer is $-1$ immediately.
- For a fixed $w$, to minimize capsules, for the earliest unprocessed sample $i$, it is optimal to activate at the latest allowed time $x = t_i + w$. This maximizes the usable horizon $t_i + w + d$ and allows serving a maximal consecutive block from $i$, limited by capacity and expiry (arrivals must satisfy $t_j \le t_i + w + d$).
- The minimal capsule count $f(w)$ is non-increasing in $w$. Hence we can binary search the minimal feasible $w$.

**2. Optimal Approach**

We combine a greedy evaluation for a fixed $w$ with a binary search over $w$:
1) Capacity check:
   - If $B < \lceil n/k \rceil$, return $-1$.

2) Greedy evaluation for $f(w)$:
   - Start from the earliest uncovered sample at index $i$.
   - Activate at $x = t_i + w$, giving a horizon $t_i + w + d$.
   - Advance $j$ from $i$ while both $j - i < k$ and $t_j \le t_i + w + d$.
   - Use one capsule for samples $i, \dots, j-1$, then set $i \leftarrow j$ and repeat.
   - The count of used capsules is $f(w)$ for that $w$.

3) Binary search on $w$:
   - If $B \ge \lceil n/k \rceil$, a solution exists. An upper bound is $w_{\max} = t_n - t_1$, since with $w \ge w_{\max}$ expiry no longer binds and $f(w)=\lceil n/k \rceil$.
   - Binary search the smallest $w \in [0, w_{\max}]$ such that $f(w) \le B$.

Correctness sketch:
- For fixed $w$, delaying activation to $t_i + w$ cannot reduce the set of coverable samples and thus maximizes each block; taking the maximal block is optimal.
- Since $f(w)$ is non-increasing in $w$, binary search returns the minimal feasible $w$.

**3. Code**
```cpp
#include <iostream>
#include <vector>

using std::cin;
using std::cout;
using std::vector;

/*
 * Ceil division for non-negative integers.
 * Precondition: a >= 0, b > 0.
 * Returns ceil(a / b).
 */
long long ceilDiv(long long a, long long b) {
    return (a + b - 1) / b;
}

/*
 * Compute how many capsules are needed if the waiting tolerance is `tolerance`.
 *
 * Greedy decision checker (O(n)):
 * - Process arrivals left to right.
 * - For the earliest uncovered index i, any activation x in
 *   [arrivalTimes[i] - coldDuration, arrivalTimes[i] + tolerance] can serve it.
 * - The maximal right reach over arrival times is:
 *       horizon = arrivalTimes[i] + tolerance + coldDuration
 *   so one capsule can cover a consecutive block [i..j] such that
 *       (j - i + 1) <= maxPerCapsule  and  arrivalTimes[j] <= horizon.
 * - Take the largest such block, count one capsule, and continue from j + 1.
 */
long long capsulesNeededForTolerance(const vector<long long>& arrivalTimes,
                                     long long maxPerCapsule,
                                     long long coldDuration,
                                     long long tolerance) {
    long long capsulesUsed = 0;
    const int n = static_cast<int>(arrivalTimes.size());
    int i = 0;

    while (i < n) {
        // Maximal right reach over arrival times for a block starting at i.
        const long long horizon = arrivalTimes[i] + tolerance + coldDuration;

        // Extend j while capacity and horizon allow.
        int j = i;
        while (j < n &&
               (j - i) < maxPerCapsule &&
               arrivalTimes[j] <= horizon) {
            ++j;
        }

        ++capsulesUsed;   // One capsule covers [i .. j-1]
        i = j;            // Next uncovered index
    }

    return capsulesUsed;
}

/*
 * Find the minimal waiting tolerance w such that all samples can be frozen
 * using at most `maxCapsules`. If impossible due to total capacity, return -1.
 *
 * Approach:
 * - Capacity lower bound: need at least ceil(n / maxPerCapsule) capsules.
 * - Binary search w in [0, arrivalTimes.back() - arrivalTimes.front()].
 *   (This upper bound suffices because with w >= span, horizon reaches the last
 *    arrival for any start, so only capacity matters.)
 * - For each w, use the greedy checker above (O(n)).
 */
long long findMinimalToleranceOrMinusOne(const vector<long long>& arrivalTimes,
                                         long long maxPerCapsule,
                                         long long coldDuration,
                                         long long maxCapsules) {
    const int n = static_cast<int>(arrivalTimes.size());

    // Necessary capacity condition.
    const long long minCapsulesByCapacity = ceilDiv(n, maxPerCapsule);
    if (maxCapsules < minCapsulesByCapacity) {
        return -1;
    }

    long long low = 0;
    long long high = arrivalTimes.back() - arrivalTimes.front(); // Sufficient upper bound on w

    // Standard binary search for minimal feasible tolerance.
    while (low < high) {
        const long long mid = (low + high) >> 1;
        const long long needed =
            capsulesNeededForTolerance(arrivalTimes, maxPerCapsule, coldDuration, mid);

        if (needed <= maxCapsules) {
            high = mid;  // mid is feasible; try smaller
        } else {
            low = mid + 1;  // mid not feasible; need more tolerance
        }
    }

    return low;  // Minimal feasible tolerance
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int scenarioCount = 0;
    if (!(cin >> scenarioCount)) {
        return 0;
    }

    while (scenarioCount--) {
        int n = 0;
        long long maxPerCapsule = 0;   // (k) Max samples a capsule can process
        long long coldDuration = 0;    // (d) Capsule usable minutes after activation
        long long maxCapsules = 0;     // (B) Total available capsules

        cin >> n >> maxPerCapsule >> coldDuration >> maxCapsules;

        vector<long long> arrivalTimes(n);
        for (int i = 0; i < n; ++i) {
            cin >> arrivalTimes[i];
        }

        const long long answer =
            findMinimalToleranceOrMinusOne(arrivalTimes,
                                           maxPerCapsule,
                                           coldDuration,
                                           maxCapsules);

        cout << answer << "\n";
    }

    return 0;
}
```

**4. Code Explanation**

- Capacity check: Compute $\lceil n/k \rceil$. If $B$ is smaller, it is impossible to process all samples due to capacity alone, so return $-1$.
- Greedy per-tolerance evaluation: For a given $w$, we scan from left to right. For the earliest uncovered sample at index $i$, we choose activation $x = t_i + w$, giving horizon $t_i + w + d$. We cover as many consecutive samples as allowed by capacity $k$ and by expiry ($t_j \le t_i + w + d$). This uses one capsule; we continue from the next uncovered index. This computes $f(w)$.
- Binary search: Since $f(w)$ is non-increasing, we binary search $w$ over $[0, t_n - t_1]$ to find the smallest $w$ with $f(w) \le B$.

Illustrative example:
- For $t=[1,1,2,5]$, $k=3$, $d=0$, $B=2$:
  - $w=0$: Anchor $i=0$, horizon $1$, cover $[0,1]$. Next $i=2$, horizon $2$, cover $[2]$. Next $i=3$, cover $[3]$. Total $3 > B$, infeasible.
  - $w=1$: Anchor $i=0$, horizon $2$, cover $[0,1,2]$. Next $i=3$, cover $[3]$. Total $2 \le B$, minimal feasible $w=1$.

**5. Time and Space Complexity**

- Greedy evaluation for fixed $w$: $O(n)$ time using two pointers and $O(1)$ extra space.
- Binary search iterations: $O(\log(t_n - t_1 + 1))$ (at most $31$ for times up to $10^9$).
- Total per scenario: $O(n \log(t_n - t_1 + 1))$ time, $O(n)$ space to store inputs with $O(1)$ extra working space.

**6. Conclusion**

We minimize the waiting tolerance $w$ under capacity and lifespan limits. For any fixed $w$, activating capsules at the latest feasible time and greedily covering the maximal consecutive block yields the minimal capsule count. Because this count is non-increasing in $w$, a binary search over $w$ finds the minimal feasible tolerance efficiently. The solution is simple, correct, and runs in $O(n \log(t_n - t_1 + 1))$ time with minimal extra space.

**7. Walkthrough on Example 1 (Optimal Approach)**

**Instance:** $n=6$, $k=2$, $d=1$, $B=3$, arrivals $t=\langle 0,0,5,5,11,11\rangle$.


**Step 1 — Capacity check.**  
Compute the lower bound: $\left\lceil \dfrac{n}{k} \right\rceil=\left\lceil \dfrac{6}{2} \right\rceil=3$. Since $B=3\ge 3$, a solution may exist.


**Step 2 — Binary-search range for $w$.**  
Set $w_{\min}=0$, $w_{\max}=t_n-t_1=11$. We binary search the smallest $w\in[0,11]$ with $f(w)\le B$.


**Step 3 — Greedy checker $f(w)$ (how a single check works).**  
For any fixed $w$, process the earliest uncovered index $i$, and cover a maximal block up to the largest $j$ such that:
- capacity: $j-i+1\le k$, and
- reach: $t_j \le t_i + w + d$.

Each such block uses one capsule; repeat from the next uncovered index.


**Step 4 — Run the actual binary search iterations.**

- **Iteration 1:** $w=\left\lfloor \dfrac{0+11}{2} \right\rfloor=5$  
  - $i=0$: horizon $=t_0+w+d=0+5+1=6$.  
    Take up to capacity $k=2$ within $t\le 6$: cover $t_0=0$, $t_1=0$ → use $1$ capsule; next $i=2$.  
  - $i=2$: horizon $=5+5+1=11$.  
    Cover $t_2=5$, $t_3=5$ → use $1$ more; next $i=4$.  
  - $i=4$: horizon $=11+5+1=17$.  
    Cover $t_4=11$, $t_5=11$ → use $1$ more; done.  
  Total capsules $f(5)=3\le B$. Set new right bound to $w_{\max}=5$.

- **Iteration 2:** $w=\left\lfloor \dfrac{0+5}{2} \right\rfloor=2$  
  By the same sweep (horizons $=t_i+2+1$), we cover pairs $(0,0)$, $(5,5)$, $(11,11)$ using $3$ capsules.  
  Thus $f(2)=3\le B$ → set $w_{\max}=2$.

- **Iteration 3:** $w=\left\lfloor \dfrac{0+2}{2} \right\rfloor=1$  
  Sweep again (horizons $=t_i+1+1$): the same three pairs fit within capacity, so $f(1)=3\le B$ → set $w_{\max}=1$.

- **Iteration 4:** $w=\left\lfloor \dfrac{0+1}{2} \right\rfloor=0$  
  Horizons $=t_i+0+1$: still cover the pairs $(0,0)$, $(5,5)$, $(11,11)$, hence $f(0)=3\le B$ → set $w_{\max}=0$.

Binary search terminates with $w_{\min}=w_{\max}=0$.

**Conclusion of the walkthrough.**  
The checker confirms $f(0)=3\le B$, and by monotonicity of $f(w)$ the minimal feasible tolerance is
$$[
w^\star=0.
]$$
