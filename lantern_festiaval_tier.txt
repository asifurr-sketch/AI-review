# Metadata

**Category:** - Coding

**GitHub URL:** - https://github.com/NOI-gen/lantern_festival_tier_k_spark_summation

**Topic:** - Competitive Programming

**Subtopic:** - ["Dynamic Programming", "Graph Algorithms", "Backtracking Algorithms", "Memoization", "Arrays and Lists", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of approaches:** - 3, $O(2^{n^2})$, $O(2^{n^2})$, $O(n^2 k)$

**Number of Sections:** - 9

---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

A city celebrates a Lantern Festival for n consecutive nights, numbered 1 to n. A “lantern river” is a spectacle that runs over a consecutive block of nights [l, r] (inclusive). The organizers may commission any collection (subset) of such spectacles.

Two river spectacles intersect if they shine on the same night (i.e., intervals share at least one night). The tier of a plan (subset) is defined as the maximum size of a pairwise non-intersecting subfamily within it. If a plan contains s spectacles in total, its spark is x^s.

Compute the total spark over all plans whose tier is exactly k, modulo 1 000 000 007.

- Nights are 1..n.
- Spectacles are all intervals [l, r] with 1 ≤ l ≤ r ≤ n.
- A plan is any subset of these intervals.
- Tier(plan) = maximum number of pairwise non-intersecting intervals in the plan.
- Spark(plan) = x^(number of intervals in the plan).

All computations are modulo 1 000 000 007.

**Input Format:-**
- A single line with three integers: n k x

**Output Format:-**
- A single integer: the sum of x^s over all plans with tier exactly k, modulo 1 000 000 007.

**Constraints:-**
- 1 ≤ n ≤ 500
- 0 ≤ k ≤ 500
- 0 ≤ x ≤ 1 000 000 006

**Examples:-**

**Input:**
```
3 1 1
```

**Output:**
```
23
```

**Input:**
```
3 2 1
```

**Output:**
```
32
```

**Input:**
```
2 0 2025
```

**Output:**
```
1
```

**Input:**
```
2 1 3
```

**Output:**
```
27
```

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Understanding the problem and clarifying definitions

**[THOUGHT_01_01]**

We are given $n$ nights labeled $1$ to $n$. A spectacle is any interval $[l,r]$ with $1 \le l \le r \le n$. A plan is any subset $S$ of all such intervals. Two intervals intersect if they share at least one night. The tier of a plan $S$ is defined as the maximum number of intervals in $S$ that are pairwise non-intersecting. If a plan has $s$ intervals, its spark is $x^s$. We must compute the total spark over all plans whose tier is exactly $k$, modulo $M=10^9+7$.


**[THOUGHT_01_02]**

The total number of intervals is $N = \frac{n(n+1)}{2}$. A plan is any subset of these $N$ intervals. For each plan $S$, its contribution to the answer is $x^{|S|}$ if $\operatorname{tier}(S)=k$, and $0$ otherwise. Hence the answer is
$$
\sum_{S \subseteq \mathcal{I}} [\operatorname{tier}(S)=k] \cdot x^{|S|} \pmod{M},
$$
where $\mathcal{I}$ is the set of all intervals and $[\cdot]$ is the indicator.


**[THOUGHT_01_03]**

The tier constraint depends on the structure of intersections inside $S$. Note that the intervals form an interval graph; the tier of $S$ equals the size of a maximum independent set of the induced subgraph on $S$. Interval graphs admit efficient algorithms for maximum independent set, but enumerating all $S$ is infeasible.


**[THOUGHT_01_04]**

We must aggregate $x^{|S|}$ across all subsets with a given tier. This suggests generating-function-like reasoning or dynamic programming that respects how intervals combine. A useful property of interval families is the natural ordering by right endpoints; many optimal substructures are exposed by the earliest finishing interval.


**[THOUGHT_01_05]**

Corner cases: when $k=0$, only the empty plan qualifies, so the answer is $1$ for any $x$. When $x=0$, only the empty plan contributes nonzero weight, so the answer is $1$ if $k=0$ and $0$ otherwise. When $k>n$, no plan can have tier $k$ because at most $n$ pairwise disjoint intervals exist.


**[THOUGHT_01_06]**

The modulus $M=10^9+7$ is prime. All computations, especially powers of $1+x$, must be performed modulo $M$. Since exponents can be as large as $\Theta(n^2)$, we will need careful precomputation of powers.



---

**[CHAIN_02]**

Implementing brute force to enumerate all plans

**[THOUGHT_02_01]**

First attempt: enumerate every subset $S \subseteq \mathcal{I}$, compute $\operatorname{tier}(S)$, and if it equals $k$ add $x^{|S|}$ modulo $M$. Complexity-wise, there are $2^N$ subsets with $N=\Theta(n^2)$, making this intractable for $n$ up to $500$.


**[THOUGHT_02_02]**

Even if we exploit that maximum independent set in an interval graph is computable in $O(|S| \log |S|)$ or better, this sits inside an outer loop of $2^N$ subsets. For $n=500$, $N \approx 125{,}250$, so $2^N$ is astronomically large; any per-subset polynomial factor is irrelevant.


**[THOUGHT_02_03]**

A minor refinement could try to sum contributions by $|S|=s$ using binomial coefficients, but the tier constraint couples choices in a highly nontrivial way. Direct counting of qualifying subsets by size $s$ is not accessible combinatorially without further structure.


**[THOUGHT_02_04]**

Conclusion: exhaustive enumeration is impossible. We need to exploit structural decompositions of interval families to aggregate contributions without iterating over all subsets.



---

**[CHAIN_03]**

Classifying plans only by independent set size and exposing its limitation

**[THOUGHT_03_01]**

Second attempt: Count how many plans have tier exactly $k$ regardless of how many total intervals $|S|$ they contain. If we could count plans with $\operatorname{tier}(S) \le k$ or exactly $k$ combinatorially, we might then fold in weights $x^{|S|}$ post hoc. However, weight depends on $|S|$, not only on tier.


**[THOUGHT_03_02]**

One might try to count by first choosing a non-intersecting set $I$ of size $k$ and then selecting any remaining intervals intersecting in arbitrary ways that do not increase the tier beyond $k$. The difficulty is ensuring that no additional disjoint interval can be included to increase the tier to $k+1$. This global constraint entangles choices across the entire set of intervals.


**[THOUGHT_03_03]**

Moreover, two plans can have the same tier $k$ but very different sizes $|S|$, so aggregating $x^{|S|}$ over all such plans still requires tracking sizes or generating functions. A classification only by tier is insufficient to recover the weighted sum.


**[THOUGHT_03_04]**

Conclusion: this approach fails because it does not factor the space of plans in a way that supports summing $x^{|S|}$ under the exact-tier constraint. We must find a decomposition where both tier and size interact in a multiplicative or convolution-friendly manner.



---

**[CHAIN_04]**

Decomposing plans by earliest finishing night and validating the lemma

**[THOUGHT_04_01]**

Third attempt: Exploit interval structure by conditioning on the minimum right endpoint among intervals included in a non-empty plan. For fixed nights $1..m$, define $t$ as the smallest right endpoint among intervals in the plan. All intervals covering $t$ mutually intersect (via night $t$), and any interval starting after $t$ is disjoint from any interval ending at $t$.


**[THOUGHT_04_02]**

Let $A(t,m)$ be the set of intervals fully within $[1..m]$ that cover $t$. There are $|A(t,m)| = t \cdot (m - t + 1)$ such intervals because the left end can be any $l \in [1..t]$ and the right end any $r \in [t..m]$. Let $B(t)$ be those intervals that end exactly at $t$; thus $|B(t)| = t$.


**[THOUGHT_04_03]**

To ensure $t$ is the earliest finish in a non-empty plan, the chosen subfamily $T \subseteq A(t,m)$ must include at least one interval from $B(t)$. The weighted sum of all such $T$ is
$$
W_t(m) = (1+x)^{|A(t,m)|} - (1+x)^{|A(t,m)| - |B(t)|} = (1+x)^{t(m-t+1)} - (1+x)^{t(m-t)}.
$$
This uses that $\sum_{T \subseteq U} x^{|T|} = (1+x)^{|U|}$ and subtracts those $T$ that avoid $B(t)$.


**[THOUGHT_04_04]**

Potential gap: does conditioning on the earliest finishing $t$ let us express the tier of the entire plan as $1$ plus the tier of the suffix subplan on nights $[t+1..m]$? Since all intervals covering $t$ intersect one another, a maximum pairwise disjoint family from the whole plan can include at most one interval from $A(t,m)$. If $T$ contains at least one interval with right endpoint $t$, picking any such $[l,t]$ is disjoint from every interval whose left endpoint is at least $t+1$. Hence the tier decomposes additively.


**[THOUGHT_04_05]**

Conclusion: the earliest-finish decomposition is valid and yields a multiplicative structure for weights and an additive structure for tiers. This lays the foundation for a dynamic program that sums over $t$ and recurses on the suffix $[t+1..m]$.



---

**[CHAIN_05]**

Constructing a dynamic program using earliest-finish decomposition

**[THOUGHT_05_01]**

Define $dp[m][s]$ as the total spark over all plans using nights $1..m$ whose tier is exactly $s$, computed modulo $M$. Base cases: $dp[m][0]=1$ for all $m \ge 0$ (only the empty set yields tier $0$), and $dp[0][s>0]=0$.


**[THOUGHT_05_02]**

Transition for $m \ge 1$ and $s \ge 1$:
$$
dp[m][s] = \sum_{t=1}^{m} W_t(m) \cdot dp[m-t][s-1],
$$
where
$$
W_t(m) = (1+x)^{t(m-t+1)} - (1+x)^{t(m-t)} \pmod{M}.
$$
Rationale: choose the earliest finish $t$, choose any subfamily $T \subseteq A(t,m)$ that intersects $B(t)$ (contributing total weight $W_t(m)$), and combine with any plan on nights $[t+1..m]$ of tier $s-1$ (contributing $dp[m-t][s-1]$).


**[THOUGHT_05_03]**

Multiplicativity of weights: if the plan decomposes into $T$ on $[1..m]$ that all cover $t$ and a suffix plan $R$ on $[t+1..m]$, then $|T \cup R| = |T|+|R|$, so $x^{|T \cup R|} = x^{|T|}x^{|R|}$. Summing independently over $T$ and $R$ justifies the product of sums.


**[THOUGHT_05_04]**

Computation of exponents: for each pair $(m,t)$, $|A(t,m)| = t(m-t+1)$ and $|A(t,m)| - |B(t)| = t(m-t)$. The largest exponent encountered is when $t \approx \frac{m+1}{2}$, yielding at most $\left\lfloor \frac{(m+1)^2}{4} \right\rfloor \le n^2$. This enables precomputation of all powers of $(1+x)$ up to $n^2$.


**[THOUGHT_05_05]**

Complexity: there are $O(nk)$ states and each transition sums over $t \in [1..m]$ giving $O(n)$ work per state, hence time $O(n^2 k)$, which is $O(n^3)$ in the worst case $k \approx n$. Space is $O(nk)$. With $n \le 500$, this is practical.


**[THOUGHT_05_06]**

Edge conditions naturally fall out: if $k>n$, the DP yields $0$. If $k=0$, we keep $dp[m][0]=1$. If $x=0$, then $(1+x)=1$, so $W_t(m)=1-1=0$ for $m \ge 1$, annihilating all non-empty plans, leaving only the empty plan as a contributor.



---

**[CHAIN_06]**

Preparing modular arithmetic and power precomputation

**[THOUGHT_06_01]**

Let $M=10^9+7$. Define $base = (1 + x) \bmod M$. We need to evaluate $(1+x)^e \bmod M$ for exponents $e$ up to $n^2 + O(1)$. Precompute an array $powBase[e]=base^e \bmod M$ for $e=0..n^2+5$ in $O(n^2)$ time.


**[THOUGHT_06_02]**

For each pair $(m,t)$, compute
$$
W_t(m) = powBase[t(m-t+1)] - powBase[t(m-t)] \pmod{M}.
$$
Perform subtraction with care: implement $a-b$ as $(a-b+M) \bmod M$ to avoid negative residues.


**[THOUGHT_06_03]**

When accumulating $\sum_t W_t(m)\cdot dp[m-t][s-1]$, use 64-bit intermediates to prevent overflow before reduction modulo $M$. A periodic modulo reduction within the inner loop keeps values bounded.


**[THOUGHT_06_04]**

Memory considerations: $dp$ requires $(n+1)\times (k+1)$ integers. The $powBase$ array requires $O(n^2)$ integers. For $n=500$, both fit comfortably within typical memory limits.


**[THOUGHT_06_05]**

Sanity checks: if $x=0$, then $base=1$ and $powBase[e]=1$ for all $e$. This makes $W_t(m)=0$ for $m \ge 1$, and the DP collapses correctly to $dp[n][k]=[k=0]$. If $x=M-1$, then $base=(1+x)\bmod M=0$, so $powBase[0]=1$ and $powBase[e>0]=0$, yielding $W_t(m) = 0 - 0 = 0$ unless $t(m-t+1)=0$ which never happens for $m \ge 1$, again consistent with only the empty plan contributing unless $k=0$.



---

**[CHAIN_07]**

Creating unit tests and probing corner cases

**[THOUGHT_07_01]**

Test $n=1$. Intervals: $\{[1,1]\}$. Plans: $\varnothing$ (tier $0$, weight $1$), $\{[1,1]\}$ (tier $1$, weight $x$). Hence answers: for $k=0$, $1$; for $k=1$, $x$; for $k\ge 2$, $0$. The DP yields $dp[1][0]=1$, $dp[1][1]=W_1(1)\cdot dp[0][0]$ where $W_1(1)=(1+x)^{1}- (1+x)^0 = x$, matching.


**[THOUGHT_07_02]**

Test $n=2$, enumerate tier $1$ plans. Intervals are $[1,1],[2,2],[1,2]$. All non-empty plans have tier $1$ except $\{[1,1],[2,2]\}$ which has tier $2$. Weighted sum over tier $1$ is $3x + 2x^2$ (three singletons and two pairs with $[1,2]$), which for $x=3$ gives $27$. The DP matches this as in the sample.


**[THOUGHT_07_03]**

Verify $k=0$ behavior for any $n$ and any $x$: answer must be $1$. Our base $dp[m][0]=1$ for all $m$ guarantees $dp[n][0]=1$; transitions are not used for $s=0$.


**[THOUGHT_07_04]**

Check $x=1$. The answer becomes the number of plans with tier exactly $k$. The DP reduces to counting with weights equal to $1$ per interval inclusion, which the $W_t(m)$ factors handle as $(1+1)^e - (1+1)^{e'}$.


**[THOUGHT_07_05]**

Check $k>n$. Since at most $n$ pairwise disjoint intervals exist over $n$ nights, $dp[n][k]=0$ for $k>n$. In implementation, we can restrict $s \le m$ during transitions, ensuring no invalid states contribute.


**[THOUGHT_07_06]**

Stress edge case $x=M-1$ where $base=0$. Then $powBase[0]=1$, $powBase[e>0]=0$, so $W_t(m)=0$, and only $dp[n][0]=1$ survives. This matches that $x^{|S|}$ is $1$ if $|S| \equiv 0 \pmod{M-1}$ and $-1$ otherwise, but since $(1+x)=0$, the generating factor correctly nullifies non-empty contributions in our DP sum.



---

**[CHAIN_08]**

Summarizing the final algorithm and its correctness

**[THOUGHT_08_01]**

Algorithm summary:
- Precompute $powBase[e]=(1+x)^e \bmod M$ for $0 \le e \le n^2+5$.
- Initialize $dp[m][0]=1$ for $0 \le m \le n$ and $dp[0][s>0]=0$.
- For $m=1..n$ and $s=1..\min(k,m)$:
  - For $t=1..m$, compute $W_t(m) = powBase[t(m-t+1)] - powBase[t(m-t)]$.
  - Update $dp[m][s] += W_t(m) \cdot dp[m-t][s-1] \pmod{M}$.
- Output $dp[n][k]$.


**[THOUGHT_08_02]**

Correctness sketch:
- Uniqueness: Every non-empty plan over $[1..m]$ has a unique minimum right endpoint $t$. Partition the plan into $T$ (intervals covering $t$) and $R$ (intervals with left $\ge t+1$).
- Tier additivity: Since all intervals in $T$ intersect, any pairwise disjoint selection includes at most one from $T$. If $T$ contains an interval ending at $t$, that interval is disjoint from all in $R$, hence $\operatorname{tier}(T \cup R) = 1 + \operatorname{tier}(R)$.
- Weight multiplicativity: $x^{|T \cup R|} = x^{|T|} x^{|R|}$.
- Summation: Summing over all $T$ intersecting $B(t)$ yields $W_t(m)$; summing over $R$ of tier $s-1$ yields $dp[m-t][s-1]$. Summing over $t$ covers all non-empty plans exactly once by the earliest finish.


**[THOUGHT_08_03]**

Complexity and improvements over failed attempts:
- From $2^{\Theta(n^2)}$ brute force to $O(n^2 k)$ time via decomposition by earliest finish.
- The generating function $(1+x)^{|A|}$ collapses the exponential subset sum over $T$ to two precomputed powers and one subtraction, removing the need to iterate over subsets covering $t$.


**[THOUGHT_08_04]**

Minimal code excerpt for the core transition:
```cpp
int base = int((1 + (x % MOD)) % MOD);
vector<int> powBase(n*n + 6, 1);
for (int e = 1; e < (int)powBase.size(); ++e) powBase[e] = 1LL * powBase[e-1] * base % MOD;

vector<vector<int>> dp(n+1, vector<int>(k+1, 0));
for (int m = 0; m <= n; ++m) dp[m][0] = 1;

for (int m = 1; m <= n; ++m) {
  for (int s = 1; s <= min(k, m); ++s) {
    long long acc = 0;
    for (int t = 1; t <= m; ++t) {
      int e1 = t * (m - t + 1);
      int e2 = t * (m - t);
      int W = (powBase[e1] - powBase[e2] + MOD) % MOD;
      acc += 1LL * W * dp[m - t][s - 1];
      if (acc >= (1LL<<62)) acc %= MOD;
    }
    dp[m][s] = int(acc % MOD);
  }
}
```


**[THOUGHT_08_05]**

Alternative viewpoints: One could view the transition as a convolution across $t$ for each fixed $m$, but the $W_t(m)$ terms depend on both $t$ and $m$ non-separably, limiting FFT-based acceleration. Nevertheless, memoization and pruning to $s \le m$ suffice for the stated constraints.



---

**[CHAIN_09]**

Reflecting on failed approaches and the path to the final DP

**[THOUGHT_09_01]**

Brute force failed due to the exponential number of plans $2^{\Theta(n^2)}$. Even leveraging that the maximum independent set is easy on interval graphs does not help when wrapped around a $2^N$ enumeration.


**[THOUGHT_09_02]**

A classification by tier alone also failed because the weighted sum requires knowledge of $|S|$. Counting plans with tier exactly $k$ without simultaneously tracking sizes does not lead to the required weighted sum.


**[THOUGHT_09_03]**

The key turning point was recognizing that conditioning on the earliest finishing night $t$ makes the set of intervals covering $t$ a "clique" for the intersection relation, which both (i) forces at most one interval from that set to be in any independent subfamily and (ii) cleanly separates the suffix part starting after $t$.


**[THOUGHT_09_04]**

The generating function identity $\sum_{T \subseteq U} x^{|T|} = (1+x)^{|U|}$ enabled collapsing an exponential sum over subsets covering $t$ into a constant-time term $W_t(m)$ per pair $(m,t)$. This removed the exponential barrier and led to the $O(n^2 k)$ DP.

---

**[RESPONSE]**

**1. Problem Understanding**

We have $n$ nights labeled $1$ to $n$. A spectacle is any interval $[l,r]$ with $1 \le l \le r \le n$. A plan is any subset $S$ of all such intervals. Two intervals intersect if they share at least one night. The tier of a plan $S$ is the maximum size of a pairwise non-intersecting subfamily inside $S$. If a plan contains $s$ intervals, its spark is $x^s$.

We must compute the total spark over all plans whose tier is exactly $k$, modulo $M=10^9+7$:
$$
\sum_{S} [\operatorname{tier}(S)=k] \cdot x^{|S|} \pmod{M}.
$$

Key observations:
- The set of all intervals forms an interval graph; within any plan $S$, $\operatorname{tier}(S)$ is the maximum independent set size of the induced subgraph.
- Brute force over all subsets is impossible because there are $N=\frac{n(n+1)}{2}$ intervals and thus $2^N$ plans.
- A structural property of intervals helps: conditioning on the earliest finishing night among selected intervals creates a clean decomposition of the plan and leads to a dynamic programming solution.
- The generating function identity $\sum_{T \subseteq U} x^{|T|} = (1+x)^{|U|}$ allows summing weights over subsets efficiently.

Corner cases:
- If $k=0$, only the empty plan qualifies, so the answer is $1$ for any $x$.
- If $x=0$, only the empty plan contributes nonzero weight, so the answer is $1$ if $k=0$ and $0$ otherwise.
- If $k>n$, the answer is $0$ because at most $n$ disjoint intervals exist over $n$ nights.


**2. Optimal Approach**

We use a dynamic programming (DP) approach based on decomposing plans by the earliest finishing night.

Definitions for nights $1..m$ and a chosen earliest finishing night $t \in [1..m]$:
- $A(t,m)$: all intervals within $[1..m]$ that cover $t$. There are $|A(t,m)| = t \cdot (m - t + 1)$ such intervals.
- $B(t)$: intervals that end exactly at $t$. There are $|B(t)| = t$ such intervals.

To make $t$ the earliest finish in a non-empty plan, the chosen subset $T \subseteq A(t,m)$ must include at least one interval from $B(t)$. The total weight (spark) over all such $T$ is:
$$
W_t(m) = (1+x)^{|A(t,m)|} - (1+x)^{|A(t,m)| - |B(t)|} = (1+x)^{t(m-t+1)} - (1+x)^{t(m-t)} \pmod{M}.
$$

DP state:
- Let $dp[m][s]$ be the total spark over all plans on nights $1..m$ with tier exactly $s$.

Base cases:
- $dp[m][0] = 1$ for all $m \ge 0$ (only the empty plan has tier $0$).
- $dp[0][s>0] = 0$.

Transition for $m \ge 1$ and $s \ge 1$:
$$
dp[m][s] = \sum_{t=1}^{m} W_t(m) \cdot dp[m-t][s-1] \pmod{M}.
$$

Justification:
- Every non-empty plan on $[1..m]$ has a unique minimum right endpoint $t$. Intervals covering $t$ all intersect (a clique), allowing at most one in any non-intersecting set. If at least one interval ends at $t$, then any such interval $[l,t]$ is disjoint from all intervals starting at or after $t+1$. Thus the tier of the plan is $1$ plus the tier of the suffix plan on $[t+1..m]$.
- Weights multiply across the decomposition: $x^{|T \cup R|} = x^{|T|} \cdot x^{|R|}$. Summing independently yields the product $W_t(m) \cdot dp[m-t][s-1]$.

Precomputation:
- Let $base = (1 + x) \bmod M$ and precompute $pow\_base[e] = base^e \bmod M$ for all $0 \le e \le n^2+5$. The largest needed exponent is $t(m-t+1) \le \lfloor (m+1)^2/4 \rfloor \le n^2$.

Complexity:
- States: $O(nk)$ with $s \le m$.
- Transition: $O(n)$ per state due to summation over $t$.
- Total time: $O(n^2 k)$, which is $O(n^3)$ in the worst case $k \approx n$.
- Space: $O(nk)$ for $dp$ and $O(n^2)$ for power precomputation.


**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <cstdint>
#include <algorithm>

static const int MOD = 1000000007;

/**
 * @brief Subtract two integers modulo MOD.
 * @param a Minuend in [0, MOD-1].
 * @param b Subtrahend in [0, MOD-1].
 * @return (a - b) mod MOD in [0, MOD-1].
 */
static inline int mod_sub(int a, int b) {
    a -= b;
    if (a < 0) a += MOD;
    return a;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, k;
    long long x;
    if (!(std::cin >> n >> k >> x)) {
        return 0;
    }

    // Precompute powers of (1 + x) modulo MOD.
    int base = int((1 + (x % MOD)) % MOD);
    int max_exp = n * n + 5;

    std::vector<int> pow_base(max_exp + 1, 1);
    for (int e = 1; e <= max_exp; ++e) {
        pow_base[e] = int((1LL * pow_base[e - 1] * base) % MOD);
    }

    // dp[m][s]: total spark over nights 1..m with tier exactly s.
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(k + 1, 0));
    for (int m = 0; m <= n; ++m) {
        dp[m][0] = 1; // Only the empty plan has tier 0.
    }

    for (int m = 1; m <= n; ++m) {
        int s_max = std::min(k, m);
        for (int s = 1; s <= s_max; ++s) {
            long long acc = 0;
            for (int t = 1; t <= m; ++t) {
                int e1 = t * (m - t + 1); // |A(t,m)|
                int e2 = t * (m - t);     // |A(t,m)| - |B(t)|
                int w = mod_sub(pow_base[e1], pow_base[e2]);
                acc += 1LL * w * dp[m - t][s - 1];
                if (acc >= (1LL << 61)) acc %= MOD; // Guard against overflow.
            }
            dp[m][s] = int(acc % MOD);
        }
    }

    std::cout << dp[n][k] << '\n';
    return 0;
}
```

**4. Code Explanation**

- We compute $base = (1+x) \bmod M$ and precompute powers $pow\_base[e] = base^e \bmod M$ for all needed exponents up to $n^2+5$. These are used to quickly evaluate $W_t(m)$.
- The DP table $dp[m][s]$ stores the total spark sum for nights $1..m$ with tier exactly $s$.
- Initialization: $dp[m][0] = 1$ for all $m$ because only the empty plan has tier $0$; $dp[0][s>0] = 0$ by construction of the table.
- Transition: For each $m$ and $s$, we iterate $t$ from $1$ to $m$ and compute
  - $e1 = t(m-t+1)$ and $e2 = t(m-t)$,
  - $W_t(m) = (1+x)^{e1} - (1+x)^{e2} \pmod{M}$ via the precomputed powers,
  - Accumulate $W_t(m) \cdot dp[m-t][s-1]$ into $dp[m][s]$.
- The inner sum enumerates the unique earliest finishing night $t$ of any non-empty plan, aggregates the weights of all subsets that activate $t$, and multiplies by the spark of suffix plans of tier $s-1$.
- We periodically reduce the accumulator modulo $M$ to stay within 64-bit limits; the product of two modulo-$M$ integers is at most about $10^{18}$, so it fits in 64 bits before reduction.

Example walkthrough for $n=2$, $k=1$, $x=3$:
- $base = 1 + 3 = 4$. Precompute $pow\_base$.
- For $m=1$, $s=1$: $t=1$, $e1=1$, $e2=0$, $W_1(1) = 4^1 - 4^0 = 3$. Then $dp[1][1] = 3 \cdot dp[0][0] = 3$.
- For $m=2$, $s=1$:
  - $t=1$: $e1=2$, $e2=1$, $W_1(2) = 4^2 - 4^1 = 12$, contributes $12 \cdot dp[1][0] = 12$.
  - $t=2$: $e1=2$, $e2=0$, $W_2(2) = 4^2 - 4^0 = 15$, contributes $15 \cdot dp[0][0] = 15$.
  - Sum $= 27$, matching the sample where the weighted sum over tier $1$ plans is $3x + 2x^2$ with $x=3$.

**5. Time and Space Complexity**

- Time complexity: $O(n^2 k)$ due to $O(nk)$ DP states and an $O(n)$ loop over $t$ per state. In the worst case $k \approx n$, this is $O(n^3)$. Precomputation of powers is $O(n^2)$.
- Space complexity: $O(nk)$ for the DP table and $O(n^2)$ for the precomputed powers, for a total of $O(nk + n^2)$.

**6. Conclusion**

By exploiting the earliest finishing night among selected intervals, we uniquely decompose any non-empty plan into a clique part covering that night and a suffix plan. This yields an additive relation on tiers and a multiplicative relation on weights, enabling a clean dynamic program. The generating function identity collapses the exponential subset sum into a constant-time evaluation using precomputed powers of $(1+x)$. The resulting $O(n^2 k)$ algorithm is efficient for $n \le 500$ and correctly handles all edge cases under modulus $10^9+7$.