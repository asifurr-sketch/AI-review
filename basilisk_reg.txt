# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** - ["Convolution/NTT", "Number Theory (NTT)", "Divide and Conquer", "Arrays and Lists", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 4, ($O(n^4)$ → $O(n^3)$ → $O(n^2)$ or $O((\max w)^2)$ → $O((\max w)\log(\max w))$)

**Number of Chains:** - 12

**GitHub URL:** https://github.com/NOI-gen/basilisk_registry_the_fourth_eye_2


---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**Basilisk Registry — The Fourth Eye**

Time Limit: **3 seconds**

Memory Limit: **40 MB**

Deep beneath the ruined amphitheater lies the Basilisk Registry: a ledger of petrified statues, each etched with a gaze weight. Archivists seek Fourth-Eye configurations: one statue whose gaze equals the sum of three others staring in sequence. Since the statues are cataloged by position, the order of the three contributing statues matters. How many such quadruples exist?

You are given $n$ positive integers $w_1, w_2, \dots, w_n$ representing gaze weights. Count the number of ordered quadruples of pairwise distinct indices $(a, b, c, d)$ such that $w_a = w_b + w_c + w_d$. Report the answer modulo $998244353$.

Notes:
- Indices $a, b, c, d$ must be pairwise distinct.
- The triple $(b, c, d)$ is ordered: changing their order counts as a different quadruple if the equality holds.
- Weights may repeat.
- All weights are positive. Consequently, if $w_a = w_b + w_c + w_d$ then $w_b, w_c, w_d < w_a$, so $a \ne b, a \ne c, a \ne d$ automatically.

**Input Format:-**

- The first line contains an integer $n$.
- The second line contains $n$ space-separated integers $w_1, w_2, \dots, w_n$.

**Output Format:-**

- Output a single integer: the number of ordered quadruples $(a, b, c, d)$ with $a, b, c, d$ distinct and $w_a = w_b + w_c + w_d$, modulo $998244353$.

**Constraints:-**

- $4 \le n \le 2 \cdot 10^5$
- $1 \le w_i \le 2 \cdot 10^5$
**Examples:-**
 - **Input:**
```
6
1 2 3 3 6 6
```

 - **Output:**
```
24
```

 - **Input:**
```
4
1 3 5 5
```

 - **Output:**
```
0
```

**Note:-**
  
In the first example, the only possible target weight is $6$ (two indices with $w_a=6$). The only way to form $6$ is $1+2+3$: there is $1$ index with $1$, $1$ with $2$, and $2$ with $3$. For each choice of the index holding $3$ (2 choices), the ordered triples $(b,c,d)$ have $3!=6$ permutations, giving $12$ ordered triples. Each can pair with either target index $a$ (2 choices), yielding $12 \cdot 2 = 24$ valid quadruples.

In the second example, any triple of positive weights sums to at least $1+3+5=9$, but the maximum weight present is $5$. Thus no $w_a$ can equal $w_b+w_c+w_d$, and the answer is $0$.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Interpreting the problem requirements

**[THOUGHT_01_01]**

Given $n$ positive integers $w_1, w_2, \dots, w_n$, the task is to count ordered quadruples $(a,b,c,d)$ of pairwise distinct indices such that $w_a = w_b + w_c + w_d$, and report the result modulo $998244353$. Indices, not values, determine distinctness, so equal values at different positions are counted separately.


**[THOUGHT_01_02]**

Because $w_i > 0$ for all $i$, whenever $w_a = w_b + w_c + w_d$ holds we have $w_b, w_c, w_d < w_a$. This guarantees $a \ne b$, $a \ne c$, and $a \ne d$ automatically, so the distinctness constraint reduces to enforcing that $b, c, d$ are pairwise distinct.



**[THOUGHT_01_03]**

The triple $(b,c,d)$ is ordered, so any permutation of the same indices counts as a different solution if the sum condition holds. Approaches that inherently count unordered triples would undercount and must be adjusted to reflect ordering.



**[THOUGHT_01_04]**

Since values may repeat but counting is by indices, combinatorial expressions should be written in terms of frequency counts $f[v]$ for each value $v$ and then interpreted as counts over indices drawn from the corresponding value-buckets.



**[THOUGHT_01_05]**

The final answer is taken modulo $998244353$. This affects how arithmetic is performed in intermediate and final steps but does not alter the set of valid index quadruples defined by the equality.

---

**[CHAIN_02]**

Designing comprehensive test scenarios

---

**[CHAIN_02]**

Designing comprehensive test scenarios

**[THOUGHT_02_01]**

Input multiset: $[1,1,1,3]$ with $n=4$.

Only possible target is $w_a=3$, and the only triple sum is $1+1+1=3$.  
There are $3$ indices holding value $1$, so the number of ordered triples $(b,c,d)$ with pairwise distinct indices is $_3P_3=3!=6$.  
There is exactly one index with value $3$ for $a$.  
**Answer:** $1 \times 6 = 6$.




**[THOUGHT_02_02]**

Input multiset: $[1,1,2,2,3]$.

The largest available anchor value is $3$, but every triple of positive values has sum at least $1+1+2=4>3$.  
No $w_a$ can equal a triple sum.  
**Answer:** $0$.



**[THOUGHT_02_03]**

Input multiset: $[1,1,1,2,2,4]$.

Only viable anchor is $w_a=4$ via $1+1+2=4$.  
Counts: $f(1)=3$, $f(2)=2$, $f(4)=1$.  
To form ordered $(b,c,d)$:
- Choose the position for the single $2$: $3$ ways.
- Choose which index supplies the $2$: $2$ ways.
- Fill the remaining two positions with two distinct indices from the three $1$’s in order: $_3P_2=6$ ways.  
Total ordered triples: $3 \cdot 2 \cdot 6 = 36$.  
Anchor choices for $a$: $f(4)=1$.  
**Answer:** $36$.



**[THOUGHT_02_04]**

Input multiset: $[2,2,2,2,2,2,6]$.

Only viable anchor is $w_a=6$ via $2+2+2=6$.  
There are $6$ indices with value $2$; ordered triples of distinct indices count as $_6P_3=6\cdot5\cdot4=120$.  
Anchor choices for $a$: one index with value $6$.  
**Answer:** $120$.



**[THOUGHT_02_05]**

Input multiset: $[1,1,2,2,3]$ (frequency-heavy smalls vs. limited large).

Check all candidates for $w_a$: the largest value present is $3$, and the minimum triple sum is $1+1+2=4>3$.  
Therefore no equality $w_a=w_b+w_c+w_d$ can hold.  
**Answer:** $0$.



**[THOUGHT_02_06]**

Input multiset: $[1,1,1,1,2,2,2,6]$.

Only viable anchor is $w_a=6$ via $2+2+2=6$.  
There are exactly $3$ indices with value $2$, so ordered triples using all three distinct indices equal $_3P_3=3!=6$.  
Anchor choices for $a$: one index with value $6$.  
**Answer:** $6$.

---

**[CHAIN_03]**

Implementing brute force

**[THOUGHT_03_01]**

A direct method is to iterate over all ordered quadruples $(a,b,c,d)$ with pairwise distinct indices and check whether $w_a = w_b + w_c + w_d$. This approach mirrors the problem definition exactly and accumulates the count incrementally.




**[THOUGHT_03_02]**

Even though positivity implies $a \notin\{b,c,d\}$ whenever the equality holds, a brute-force enumeration must still enforce $b \ne c$, $c \ne d$, and $b \ne d$ within the loops to ensure pairwise distinctness among $(b,c,d)$.



**[THOUGHT_03_03]**

The runtime is $O(n^4)$, since there are $O(n)$ choices for each of $a,b,c,d$. While memory usage is small, this time complexity is infeasible for $n \le 2 \cdot 10^5$.



**[THOUGHT_03_04]**

Because $O(n^4)$ grows beyond practical limits for the stated constraints, the brute-force approach is not a viable solution despite matching the specification directly.

---

**[CHAIN_04]**

Refining to per-target three-sum enumeration

**[THOUGHT_04_01]**

Fixing an index $a$ and searching for ordered triples $(b,c,d)$ with $b,c,d$ distinct such that $w_b + w_c + w_d = w_a$ reduces one loop and reframes the core task as a per-target ordered three-sum under index distinctness.



**[THOUGHT_04_02]**

Standard two-pointer techniques for three-sum operate on unordered triples of values and do not directly enforce ordered index triples with pairwise distinctness across positions. Adapting them would require substantial duplicate-handling and careful casework that undermines their efficiency and simplicity.



**[THOUGHT_04_03]**

Iterating across all anchors $a$ and counting ordered, index-distinct triples per target remains near $O(n^3)$ in the general case. Data structures that speed up value lookups do not eliminate the cubic blowup caused by preserving ordering and distinctness across all targets.



**[THOUGHT_04_04]**

Given the cubic behavior, this per-target approach is not feasible for $n \le 2 \cdot 10^5$, indicating the need for a value-frequency–based global strategy rather than per-anchor enumeration.

---

**[CHAIN_05]**

Attempting pair-sum precomputation

**[THOUGHT_05_01]**

One idea is to precompute, for each sum $t$, the number of ordered pairs $(b,c)$ with $w_b + w_c = t$, and then for each $d$ combine with $t = w_a - w_d$ to form ordered triples. This attempts to reduce triple counting to a combination of a pair count and a single.




**[THOUGHT_05_02]**

Computing pair sums over indices is $O(n^2)$ in both time and space and is infeasible. Compressing to values helps, but a naive value-wise convolution is $O(A^2)$ for $A \le 2\cdot 10^5$, which is still too slow without transform acceleration.



**[THOUGHT_05_03]**

Enforcing pairwise distinctness among $(b,c,d)$ in this decomposition requires subtracting overlaps such as $b=d$ or $c=d$, which complicates the corrections and is error-prone when mixing pair-counts with singles.



**[THOUGHT_05_04]**

The abstraction suggested by this attempt points to convolution on value frequencies; to achieve both speed and exactness, generating functions combined with fast transforms are a more suitable direction than explicit pair-sum tables.

---

**[CHAIN_06]**

Harnessing generating functions to count triples with repetition

**[THOUGHT_06_01]**

Let $f[v]$ be the frequency of value $v$, and define the generating function $F(x) = \sum_{v \ge 0} f[v]\,x^v$. The coefficient of $x^s$ in $F(x)^3$ equals
$$
T3[s] \;=\; \sum_{v_1+v_2+v_3=s} f[v_1]\,f[v_2]\,f[v_3],
$$
which counts ordered triples $(b,c,d)$ drawn independently from the value-buckets, allowing repeated indices.



**[THOUGHT_06_02]**

Combinatorially, $T3[s]$ includes cases where $b=c$, $c=d$, or $b=d$, because each position chooses its index independently from the appropriate value-bucket.



**[THOUGHT_06_03]**

To enforce pairwise distinctness among $(b,c,d)$, start from $T3[s]$ and remove collisions via inclusion–exclusion over the equalities $b=c$, $c=d$, and $d=b$ so that only triples with three distinct indices remain.



**[THOUGHT_06_04]**

Direct computation of $F^3$ by coefficient summation is too slow, but using a Number Theoretic Transform under modulus $998244353$ allows computation of all coefficients of $F^3$ up to degree $3A$ in $O(A\log A)$ time, where $A=\max w_i$.

---

**[CHAIN_07]**

Enforcing distinctness among b, c, d via inclusion–exclusion

**[THOUGHT_07_01]**

Define the collision sets as triples with $b=c$, with $c=d$, and with $d=b$. Valid triples are precisely those outside the union of these three sets.




**[THOUGHT_07_02]**

For the case $b=c$, pick a value $v$ and one index among $f[v]$ choices, and let $d$ be any index with value $s-2v$ (counted by $f[s-2v]$). Summing over $v$ gives
$$
h[s] \;=\; \sum_v f[v]\,f[s-2v],
$$
which is the coefficient of $x^s$ in $F(x)\cdot F(x^2)$ when $F(x^2)$ has coefficients $g[2v]=f[v]$ and $g[\text{odd}]=0$.



**[THOUGHT_07_03]**

The intersection $b=c=d$ requires $3\mid s$ and contributes
$$
E[s] \;=\; \begin{cases}
f[s/3], & 3\mid s,\\
0, & \text{otherwise.}
\end{cases}
$$



**[THOUGHT_07_04]**

By inclusion–exclusion, the number of ordered distinct-index triples is
$$
\text{DistinctTripleCount}[s] \;=\; T3[s] \;-\; 3\,h[s] \;+\; 2\,E[s],
$$
since each single-collision family has size $h[s]$, each pairwise intersection equals $E[s]$, and the triple intersection also equals $E[s]$.



**[THOUGHT_07_05]**

For each sum $s$, there are $f[s]$ choices for the anchor $a$ with $w_a=s$. Because $w_b,w_c,w_d<s$, the anchor cannot collide with any of $b,c,d$, hence the total number of valid ordered quadruples is
$$
\text{ans} \;=\; \sum_s f[s]\cdot\big(T3[s]-3h[s]+2E[s]\big)\;\bmod 998244353.
$$

---

**[CHAIN_08]**

Executing the NTT-based algorithm end-to-end

**[THOUGHT_08_01]**

Compute $A=\max w_i$ and the frequency array $f[0\ldots A]$. Coefficients up to degree $3A$ are required, so choose the NTT length $L$ as the smallest power of two with $L\ge 3A+1$, and allocate arrays of length $L$.



**[THOUGHT_08_02]**

Initialize $F$ by setting $F[v]=f[v]$ for $0\le v\le A$ and zeros elsewhere. Initialize $G$ to represent $F(x^2)$ by setting $G[2v]=f[v]$ for $0\le v\le A$ and $G[t]=0$ for odd $t$, ensuring $2v<L$.



**[THOUGHT_08_03]**

Take forward NTTs of $F$ and $G$. In the transform domain, compute pointwise $F^3$ (cube each entry of $\widehat F$) to obtain the transform of $F(x)^3$, and compute pointwise $\widehat F\cdot \widehat G$ for the transform of $F(x)\cdot F(x^2)$.



**[THOUGHT_08_04]**

Apply inverse NTT to obtain the coefficient arrays $T3$ for $F^3$ and $h$ for $F\cdot F(x^2)$, valid for indices $0\le s\le 3A$.



**[THOUGHT_08_05]**

For each $s$ with $0\le s\le A$, compute $E[s]=f[s/3]$ when $3\mid s$, else $0$, then form
$$
\text{distinct}[s]=T3[s]-3h[s]+2E[s]\pmod{998244353},
$$
normalize to a nonnegative residue, and accumulate
$$
\text{ans}=\sum_{s=0}^A f[s]\cdot \text{distinct}[s]\pmod{998244353}.
$$



**[THOUGHT_08_06]**

Each NTT is $O(L\log L)$ with $L\le 2^{20}$ for $A\le 2\cdot 10^5$. Two forward and two inverse transforms plus linear scans fit comfortably within the time and memory limits.

---

**[CHAIN_09]**

Validating with targeted unit tests

**[THOUGHT_09_01]**

For input $[1,1,1,3]$, only $s=3$ contributes; inclusion–exclusion over $T3[3]$, $h[3]$, and $E[3]$ yields $3!=6$ ordered distinct triples, multiplied by $f[3]=1$, so the expected output is $6$.




**[THOUGHT_09_02]**

For input $[1,2,3,4,6]$, only $6=1+2+3$ qualifies; with three distinct indices, the ordered permutations give $3!=6$, so the expected output is $6$.



**[THOUGHT_09_03]**

For input $[1,1,1,2,2,4]$, only $4=1+1+2$ contributes; counting ordered triples of indices gives $36$, so the expected output is $36$.



**[THOUGHT_09_04]**

For input $[2,2,2,2,2,2,6]$, only $6=2+2+2$ contributes; the count is $_6P_3=120$, so the expected output is $120$.



**[THOUGHT_09_05]**

For input $[1,1,2,2,3]$, no element equals a sum of three positives from the multiset, so the expected output is $0$.



**[THOUGHT_09_06]**

For input $[1,1,1,1,2,2,2,6]$, only $6=2+2+2$ contributes with exactly three twos: $_3P_3=6$, so the expected output is $6$.

---

**[CHAIN_10]**

Comparing alternatives and trade-offs

**[THOUGHT_10_01]**

Computing $F^2$ by NTT and then multiplying by $F$ is equivalent to pointwise cubing of $\widehat F$ once $\widehat F$ is available; pointwise cubing saves an extra transform pass without changing asymptotic complexity.



**[THOUGHT_10_02]**

Using floating-point FFT with rounding risks precision errors on adversarial inputs and large coefficients; NTT modulo $998244353$ is exact and avoids such instability.



**[THOUGHT_10_03]**

Value-DP formulations typically cost $O(A^2)$ or $O(nA)$ and still need careful handling to count ordered triples and enforce index distinctness, making them slower and more complex than the algebraic transform approach.



**[THOUGHT_10_04]**

The generating-function method yields exact combinatorial counts, the NTT delivers $O(A\log A)$ performance, and inclusion–exclusion enforces pairwise distinctness of $(b,c,d)$ without heavy special-case logic.

---

**[CHAIN_11]**

Resolving implementation caveats and modular arithmetic

**[THOUGHT_11_01]**

Choose the transform length $L$ as a power of two with $L\ge 3A+1$ so that all coefficients of $F^3$ up to degree $3A$ are represented without cyclic overlap.



**[THOUGHT_11_02]**

Use 64-bit intermediates for modular products to avoid overflow before reduction; after subtractions such as $T3[s]-3h[s]$, add $998244353$ as needed to normalize residues to $[0,998244353)$.



**[THOUGHT_11_03]**

Construct $G$ with $G[2v]=f[v]$ and zeros on odd indices, ensuring $2v<L$, so that the coefficient array after inverse NTT matches $h[s]=\sum_v f[v]\,f[s-2v]$ exactly.




**[THOUGHT_11_04]**

Because $w_b,w_c,w_d<s$, the anchor $a$ cannot share an index with any of $b,c,d$; multiplying by $f[s]$ correctly accounts for all anchors with value $s$.



**[THOUGHT_11_05]**

Adopt clear naming: lowerCamelCase for variables/functions, UpperCamelCase for types, and kCamelCase for constants; keep indentation consistent and document helpers briefly.

---

**[CHAIN_12]**

Presenting a concise computation blueprint

**[THOUGHT_12_01]**

The preceding derivations imply a concrete computation pipeline whose steps follow directly from the generating-function identities and inclusion–exclusion corrections; listing them clarifies data flow rather than introducing new results:
1. Read $n$ and $w$, compute $A=\max w_i$ and frequencies $f[0\ldots A]$.
2. Choose $L$ as the smallest power of two with $L\ge 3A+1$.
3. Build $F$ with $F[v]=f[v]$ and $G$ with $G[2v]=f[v]$ (zeros elsewhere).
4. Take forward NTTs of $F$ and $G$.
5. Form pointwise $\widehat F^{\,3}$ and $\widehat F\cdot \widehat G$.
6. Inverse NTT to obtain $T3$ and $h$.
7. For $s\in[0,A]$, set $E[s]=f[s/3]$ if $3\mid s$ else $0$, then compute $\text{distinct}[s]=T3[s]-3h[s]+2E[s]\pmod{998244353}$ and accumulate $\text{ans}=\sum_{s=0}^A f[s]\cdot \text{distinct}[s]\pmod{998244353}$.



**[THOUGHT_12_02]**

The final aggregation iterates only over $s\in[0,A]$ where $f[s]$ may be nonzero; for each such $s$, inclusion–exclusion yields the count of ordered, index-distinct triples summing to $s$, which is then multiplied by the number of anchors $f[s]$.



**[THOUGHT_12_03]**

This pipeline uses two forward and two inverse NTTs with length $L\le 2^{20}$ (for $A\le 2\cdot 10^5$) and linear scans; the resulting $O(L\log L)$ time and $O(L)$ space bounds meet the stated limits, and the modular arithmetic under $998244353$ ensures exactness throughout.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given $n$ positive integers $w_1, w_2, \dots, w_n$. We must count the number of ordered quadruples of pairwise distinct indices $(a, b, c, d)$ such that
$$
w_a = w_b + w_c + w_d,
$$
and report the count modulo $998244353$.

Key observations:
- All $w_i$ are positive. Thus, if $w_a = w_b + w_c + w_d$, then $w_b, w_c, w_d < w_a$. Therefore, $a \ne b$, $a \ne c$, and $a \ne d$ automatically. The distinctness constraint reduces to ensuring $b, c, d$ are pairwise distinct.
- The triple $(b, c, d)$ is ordered, so different permutations of the same indices are counted separately if the equality holds.
- Weights may repeat; counting is over indices, not values, which suits a frequency-based approach.


**2. Optimal Approach**

We use generating functions with inclusion–exclusion to count ordered triples efficiently, and compute convolutions via the Number Theoretic Transform (NTT).

1) Frequency polynomial:
- Let $f[v]$ be the number of indices with value $v$.
- Define
$$
F(x) = \sum_{v \ge 0} f[v] \cdot x^v.
$$
- The coefficient of $x^s$ in $F(x)^3$ is
$$
T3[s] = \sum_{v_1 + v_2 + v_3 = s} f[v_1] f[v_2] f[v_3],
$$
which counts ordered triples $(b, c, d)$ allowing index repetition.

2) Inclusion–exclusion to enforce $b, c, d$ distinct:
- Let $A$ be triples with $b = c$, $B$ with $c = d$, and $C$ with $d = b$.
- The count with exactly one equality (e.g., $b = c$) for sum $s$ is
$$
h[s] = \sum_v f[v] \cdot f[s - 2v],
$$
the coefficient of $x^s$ in $F(x) \cdot F(x^2)$, where $F(x^2)$ has coefficients $G[2v] = f[v]$ and zero at odd positions.
- Triples with $b = c = d$ exist only if $3 \mid s$, contributing
$$
E[s] =
\begin{cases}
f[s/3], & \text{if } 3 \mid s, \\
0, & \text{otherwise.}
\end{cases}
$$
- Inclusion–exclusion yields
$$
\text{DistinctTripleCount}[s] = T3[s] - 3h[s] + 2E[s].
$$

3) Aggregation over anchors:
- For each sum $s$, there are $f[s]$ choices for index $a$ with $w_a = s$.
- Because $w_b, w_c, w_d < s$, the anchor index $a$ cannot collide with $b, c, d$.
- Final answer:
$$
\text{ans} = \sum_s f[s] \cdot \big(T3[s] - 3h[s] + 2E[s]\big) \bmod 998244353.
$$

4) Efficient computation via NTT:
- Build $f[0 \dots A]$ where $A = \max w_i$.
- Let $L$ be the smallest power of two with $L \ge 3A + 1$.
- Compute:
  - $T3$ as the inverse NTT of the pointwise cube of the NTT of $F$.
  - $h$ as the inverse NTT of the pointwise product of the NTT of $F$ and the NTT of $F(x^2)$, where $G[2v] = f[v]$ and $G[\text{odd}] = 0$.
- Compute $E[s]$ directly and sum contributions for $s \in [0, A]$.

This yields an $O(A \log A)$ time solution with $O(A)$ memory.


**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdint>

static const int kMod = 998244353;        // 119 * 2^23 + 1 (NTT-friendly prime)
static const int kPrimitiveRoot = 3;      // A primitive root modulo kMod

// Fast modular exponentiation: computes a^e mod kMod.
static int modPow(int a, int e) {
    long long base = a % kMod;
    long long result = 1;
    while (e > 0) {
        if (e & 1) result = (result * base) % kMod;
        base = (base * base) % kMod;
        e >>= 1;
    }
    return static_cast<int>(result);
}

/*
 * In-place Number Theoretic Transform (NTT).
 * If invert == false: forward transform.
 * If invert == true: inverse transform followed by scaling by n^{-1} mod kMod.
 *
 * Requirements:
 * - poly.size() is a power of two.
 * - Coefficients are modulo kMod.
 */
static void numberTheoreticTransform(std::vector<int>& poly, bool invert) {
    const int transformLength = static_cast<int>(poly.size());

    // Bit-reversal permutation.
    std::vector<int> bitReverseIndex(transformLength);
    int logLength = 0;
    while ((1 << logLength) < transformLength) ++logLength;

    for (int i = 0; i < transformLength; ++i) {
        int x = i, rev = 0;
        for (int b = 0; b < logLength; ++b) {
            rev = (rev << 1) | (x & 1);
            x >>= 1;
        }
        bitReverseIndex[i] = rev;
    }
    for (int i = 0; i < transformLength; ++i) {
        if (i < bitReverseIndex[i]) std::swap(poly[i], poly[bitReverseIndex[i]]);
    }

    // Iterative Cooley–Tukey butterflies.
    for (int blockSize = 1; blockSize < transformLength; blockSize <<= 1) {
        int rootUnity = modPow(kPrimitiveRoot, (kMod - 1) / (blockSize << 1));
        if (invert) rootUnity = modPow(rootUnity, kMod - 2);  // Inverse root.

        for (int base = 0; base < transformLength; base += (blockSize << 1)) {
            long long twiddle = 1;
            for (int j = 0; j < blockSize; ++j) {
                int evenVal = poly[base + j];
                int oddVal  = static_cast<int>((twiddle * poly[base + j + blockSize]) % kMod);

                int add = evenVal + oddVal;
                if (add >= kMod) add -= kMod;

                int sub = evenVal - oddVal;
                if (sub <  0)    sub += kMod;

                poly[base + j]             = add;
                poly[base + j + blockSize] = sub;

                twiddle = (twiddle * rootUnity) % kMod;
            }
        }
    }

    if (invert) {
        const int invN = modPow(transformLength, kMod - 2);
        for (int& x : poly) x = static_cast<int>((1LL * x * invN) % kMod);
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    // Read input.
    int n;
    if (!(std::cin >> n)) return 0;

    std::vector<int> values(n);
    int maxWeight = 0;
    for (int i = 0; i < n; ++i) {
        std::cin >> values[i];
        if (values[i] > maxWeight) maxWeight = values[i];
    }

    // Build frequency array: freqByValue[v] = count of indices with weight v.
    std::vector<int> freqByValue(maxWeight + 1, 0);
    for (int w : values) ++freqByValue[w];

    /*
     * We need coefficients up to degree 3 * maxWeight for F(x)^3.
     * Choose NTT length as the smallest power of two >= (3*maxWeight + 1).
     */
    int requiredCoeffs = 3 * maxWeight + 1;
    int nttLength = 1;
    while (nttLength < requiredCoeffs) nttLength <<= 1;

    // Prepare polynomials:
    // - freqF holds F(x), where F[v] = freqByValue[v].
    // - freqFx2 holds F(x^2): freqFx2[2*v] = freqByValue[v], zeros at odd indices.
    std::vector<int> freqF(nttLength, 0);
    std::vector<int> freqFx2(nttLength, 0);
    for (int v = 0; v <= maxWeight; ++v) {
        freqF[v] = freqByValue[v];
        int indexTimes2 = v << 1;
        if (indexTimes2 < nttLength) freqFx2[indexTimes2] = freqByValue[v];
    }

    // Forward NTTs of F and F(x^2).
    numberTheoreticTransform(freqF, false);
    numberTheoreticTransform(freqFx2, false);

    /*
     * Transform-domain computations:
     * - tripleSpectrum = (FreqHat)^3  -> iNTT => coefficients of F(x)^3 (denoted T3[s]).
     * - fxFx2Spectrum  = FreqHat * Fx2Hat -> iNTT => coefficients of F(x) * F(x^2) (denoted h[s]).
     */
    std::vector<int> tripleSpectrum(nttLength, 0);
    std::vector<int> fxFx2Spectrum(nttLength, 0);
    for (int i = 0; i < nttLength; ++i) {
        long long freqHat = freqF[i];
        long long squared  = (freqHat * freqHat) % kMod;
        tripleSpectrum[i] = static_cast<int>((squared * freqHat) % kMod);
        fxFx2Spectrum[i]  = static_cast<int>((freqHat * 1LL * freqFx2[i]) % kMod);
    }

    // Inverse NTTs to obtain coefficient arrays: T3[sum] and h[sum].
    numberTheoreticTransform(tripleSpectrum, true);
    numberTheoreticTransform(fxFx2Spectrum, true);

    /*
     * Inclusion–Exclusion per sum:
     *   T3[s] = ordered triples (b,c,d) by values allowing index reuse.
     *   h[s]  = size of one single-equality family (e.g., b=c). (Three symmetric families total.)
     *   E[s]  = freqByValue[s/3] if 3 | s, else 0 (triples with b=c=d).
     * Distinct triples: T3[s] - 3*h[s] + 2*E[s].
     *
     * Positivity ensures: if w_a = s then b,c,d < s, so a cannot collide with b,c,d.
     * Final answer: sum over s of freqByValue[s] * (distinct triple count for s).
     */
    long long answer = 0;
    for (int sumValue = 0; sumValue <= maxWeight; ++sumValue) {
        if (freqByValue[sumValue] == 0) continue;

        const int t3Val = tripleSpectrum[sumValue];
        const int hVal  = fxFx2Spectrum[sumValue];

        int eVal = 0;
        if (sumValue % 3 == 0) {
            const int third = sumValue / 3;
            if (third <= maxWeight) eVal = freqByValue[third];
        }

        long long distinctTriples = t3Val;
        distinctTriples = (distinctTriples - 3LL * hVal) % kMod;
        distinctTriples = (distinctTriples + 2LL * eVal) % kMod;
        if (distinctTriples < 0) distinctTriples += kMod;

        answer = (answer + 1LL * freqByValue[sumValue] * distinctTriples) % kMod;
    }
    if (answer < 0) answer += kMod;

    std::cout << static_cast<int>(answer) << '\n';
    return 0;
}
```

**4. Code Explanation**

- Frequency modeling: Build $f[v]$ as counts of value $v$.
- Generating functions:
  - $F(x)$ has coefficients $f[v]$.
  - $F(x)^3$’s coefficients $T3[s]$ count ordered triples allowing repeated indices.
  - $F(x) \cdot F(x^2)$’s coefficients $h[s]$ count triples with exactly one equality (e.g., $b = c$), summed over three symmetric cases.
- Triple-equality term: $E[s] = f[s/3]$ if $3 \mid s$, else $0$.
- Inclusion–exclusion: Distinct triples are $T3[s] - 3h[s] + 2E[s]$.
- Anchors: Multiply by $f[s]$ choices for $a$ with $w_a = s$. Positivity ensures $a \notin \{b, c, d\}$.
- NTT usage: We compute $T3$ and $h$ via NTT for all $s$ in near-linear time in the value range, and aggregate over $s \in [0, A]$.

Illustrative example $[1, 1, 1, 3]$:
- Only $s = 3$ contributes. $T3[3]$ counts all ordered triples summing to $3$, including collisions. Inclusion–exclusion removes collisions and adjusts triple-equality, leaving exactly the $3! = 6$ ordered triples using three distinct indices of value $1$. With one anchor at $w_a = 3$, the total is $6$.

**5. Time and Space Complexity**

- Let $A = \max w_i$, and $L$ be the smallest power of two with $L \ge 3A + 1$.
- Time complexity: $O(L \log L)$ for two forward and two inverse NTTs plus linear passes. With $A \le 2 \cdot 10^5$, $L \le 2^{20}$, which is efficient.
- Space complexity: $O(L)$ for polynomial arrays and intermediate buffers.

**6. Conclusion**

By leveraging generating functions with inclusion–exclusion and computing convolutions via NTT under modulus $998244353$, we count all ordered, index-distinct triples efficiently and safely aggregate over anchor indices. The positivity of weights simplifies distinctness with the anchor, and the approach runs in $O(A \log A)$ time with $O(A)$ space, meeting the problem’s constraints.

**7. Walkthrough (Optimal NTT + PIE) on Example 1**

**Instance.** Input multiset: $[1,2,3,3,6,6]$ with $n=6$.  
Frequencies: $f(1)=1,\ f(2)=1,\ f(3)=2,\ f(6)=2$ (all other $f(v)=0$).  
Let $A=\max w_i=6$. Choose $L$ as the smallest power of two with $L\ge 3A+1=19$, hence $L=32$.

**Generating functions.**  
Define $F(x)=\sum_{v\ge 0} f[v]\,x^v$ and $G(x)=F(x^2)$, i.e., $G[2v]=f[v]$ and $G[\text{odd}]=0$.  
Compute the NTTs: $\widehat F=\text{NTT}(F)$ and $\widehat G=\text{NTT}(G)$ (length $L$).  
Then
- $T3=\text{iNTT}\!\big(\widehat F^{\,3}\big)$ gives coefficients of $F(x)^3$,
- $h=\text{iNTT}\!\big(\widehat F\cdot \widehat G\big)$ gives coefficients of $F(x)\cdot F(x^2)$.

We need the value at sum $s=6$.

**Coefficient $T3[6]$.** This counts **ordered** triples $(b,c,d)$ by values allowing index reuse:
- Permutations of $(1,2,3)$: there are $6$ permutations; each contributes $f(1)\cdot f(2)\cdot f(3)=1\cdot 1\cdot 2=2$.  
  Contribution: $6\cdot 2=12$.
- Triple $(2,2,2)$: contributes $f(2)^3=1$.  
No other value triples sum to $6$. Hence
$$
T3[6]=12+1=13.
$$

**Coefficient $h[6]$.** This corresponds to the set with $b=c$ (and symmetrically for the other equalities) and equals
$$
h[6]=\sum_{v} f[v]\cdot f[6-2v].
$$
Nonzero terms: $v=2$ gives $f(2)\cdot f(2)=1\cdot 1=1$. Thus $h[6]=1$.

**Triple-equality term $E[6]$.** When $3\mid s$, $E[s]=f[s/3]$. Here $E[6]=f[2]=1$.

**Inclusion–exclusion (distinct $(b,c,d)$).**
$$
\text{DistinctTripleCount}[6]\;=\;T3[6]\;-\;3\,h[6]\;+\;2\,E[6]\;=\;13-3\cdot 1+2\cdot 1\;=\;12.
$$

**Aggregate over anchors.**  
For $s=6$, anchors $a$ with $w_a=6$ are $f(6)=2$. Contribution: $2\cdot 12=24$.  
For $s<6$, either no triple of positive values sums to $s$ or the inclusion–exclusion yields $0$ (e.g., for $s=3$, $1+1+1=3$ but there is only one index with value $1$, yielding $0$ after PIE). Thus no other $s$ contributes.

**Final result.**  
$$
\text{ans}\;=\;\sum_{s=0}^{A} f[s]\cdot\big(T3[s]-3h[s]+2E[s]\big)\;\equiv\;24\pmod{998244353}.
$$
So the output is $24$.