# Metadata

**Category:** - Coding

**GitHub URL:** - https://github.com/NOI-gen/emberline_whistleposts

**Topic:** - Competitive Programming

**Subtopic:** - [ Arrays and Lists,"Searching Algorithms", "Algorithm Complexity and Big O Notation" ]





**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** 3, (O(n²) → O(n²) → O(n log n))


**Number of Chains:** - 9

---

**[User]**

*Mark the start of the User's activity*

---

**[Prompt]**

**Emberline Whistleposts**

Time Limit: **1 seconds**

Memory Limit: **32 MB**

Along the ancient Emberline railway, whistleposts stand at distinct kilometer markers. When a post $i$ greets the line, the perceived loudness at another post $j$ is directional and capped:
- If $j$ is west of $i$ ($j < i$), the loudness is $ \min(p_i - p_j, L_i) $.
- If $j$ is east of $i$ ($j > i$), the loudness is $ \min(p_j - p_i, R_i) $.

For each post $i$, compute the total loudness heard by all other posts when only post $i$ greets, that is:
$ \sum_{j \ne i} \begin{cases}
\min(p_i - p_j, L_i), & \text{if } j < i \\
\min(p_j - p_i, R_i), & \text{if } j > i
\end{cases} $.

**Input Format:-**
- The first line contains an integer $n$ ($2 \leq n \leq 200000$) — the number of whistleposts.
- The second line contains $n$ strictly increasing integers $p_1, p_2, \ldots, p_n$ ($-10^9 \leq p_i \leq 10^9$) — the positions of the posts.
- The third line contains $n$ integers $L_1, L_2, \ldots, L_n$ ($0 \leq L_i \leq 10^9$) — the westward (left) damper limits.
- The fourth line contains $n$ integers $R_1, R_2, \ldots, R_n$ ($0 \leq R_i \leq 10^9$) — the eastward (right) damper limits.

**Output Format:-**
- Print $n$ lines.
- The $i$-th line should contain the total loudness emitted by post $i$ toward all other posts.

**Constraints:-**
- Positions are strictly increasing.
- Use 64-bit integers for all sums and results.
**Examples:-**
 - **Input:**
```
3
-1000000000 0 1000000000
1000000000 1000000000 1000000000
1000000000 1000000000 1000000000
```

 - **Output:**
```
2000000000
2000000000
2000000000
```
**Explanation:**    
In the first example, all caps are $10^9$ and positions are at $-10^9, 0, 10^9$. Each post’s total is $2 \times 10^9$:

For the middle post ($i = 2$), both neighbors are at distance $10^9$, so $10^9 + 10^9 = 2 \times 10^9$.

For an endpoint (e.g., $i = 1$), distances are $10^9$ (to 0) and $2 \times 10^9$ (to $10^9$). The $2 \times 10^9$ distance is capped to $10^9$, so $10^9 + 10^9 = 2 \times 10^9$. The same holds for $i = 3$.

 - **Input:**
```
7
0 2 4 8 16 17 40
0 1 10 0 20 1 5
1 0 10 1 0 20 0
```

 - **Output:**
```
6
1
40
3
50
25
30
```

**Explanation:**

In the second example, left and right contributions use $L_i$ and $R_i$ of the speaking post $i$, respectively. A post $j$ contributes its exact distance if it lies within the cap range on that side; otherwise its contribution is the cap on that side.

For $i = 3$ $(p = 4, L_3 = R_3 = 10)$: left gives $(4-0) + (4-2) = 4 + 2 = 6$; right gives $(8-4) + \min(16-4,10) + \min(17-4,10) + \min(40-4,10) = 4 + 10 + 10 + 10 = 34$; total $40$.

For $i = 6$ $(p = 17, L_6 = 1, R_6 = 20)$: left has five posts, each contributing $\min(\text{distance},1) = 1 \to 5$; right has one post at distance $23$ capped to $20 \to$ total $25$.

For $i = 1$ $(p = 0, L_1 = 0, R_1 = 1)$: only the right side counts; all six distances are $\geq 1$, each contributes $1 \to$ total $6$.

---

**[Assistant]**

Mark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarifying the objective and understanding the problem

**[THOUGHT_01_01]**

We are given a line of whistleposts, each positioned at a unique coordinate along a straight track.
Every post emits sound toward both directions, but the sound level diminishes depending on distance and is limited by a maximum value, called the loudness cap.
For each post, there are two separate caps: one for the west side and one for the east side.
The perceived loudness at another post equals the smaller of the physical distance between them and the appropriate directional cap.

**[THOUGHT_01_02]**

Our goal is to determine, for each whistlepost, the total loudness that all other posts would receive if only that specific post made a sound.
In other words, we want the total sum of the loudness contributions from that one post to all others along the track.

**[THOUGHT_01_03]**

Because the post positions are arranged in strictly increasing order, distances to the left of any post increase as we move farther left, and distances to the right increase as we move farther right.
Therefore, the set of neighboring posts that lie within any cap value always forms one contiguous group on either side of that post.

**[THOUGHT_01_04]**

The problem specifies a limited number of whistleposts, each with integer positions and loudness caps.
These limits guarantee that the overall magnitude of the numbers involved will not exceed what can safely be processed using standard integer arithmetic.

**[THOUGHT_01_05]**

The total number of whistleposts lies between two and two hundred thousand.
Each position value is an integer whose magnitude does not exceed one billion, and each loudness cap lies between zero and one billion as well.
Positions are always provided in strictly increasing order, ensuring that no two posts occupy the same location.

---

**[CHAIN_02]**

Building examples and testing early understanding

**[THOUGHT_02_01]**

For three equally spaced posts located at positions -$10^9$, $0$, and +$10^9$, we calculate directly:
- Post 1 contributes $10^9$ west and $10^9$ east → total $2 \times 10^9$
- Post 2 receives $10^9$ from each neighbor → total $2 \times 10^9$
- Post 3 mirrors Post 1 with total $2 \times 10^9$


**[THOUGHT_02_02]**

Now imagine a sequence of posts located at several irregular positions along the track, with different loudness caps for each direction.
For instance, one post might have a very small limit toward the west but a large one toward the east.
When computing loudness totals, we examine one post at a time, measure how far each neighbor lies, and then limit that contribution by whichever directional cap applies.
This setup highlights that asymmetry in cap values leads to noticeably different total loudness outcomes.

**[THOUGHT_02_03]**

If a post has a very small right-side cap but a moderate left-side cap, it will primarily contribute loudness to the west.
Conversely, if a post’s left-side cap is nearly zero, its influence stops immediately on that side.
By working through a few explicit examples, we can verify that these rules behave exactly as described, producing totals that align with the minimum of distance and cap.

**[THOUGHT_02_04]**

Consider posts that are unevenly spaced along the track, where some gaps are much larger than others.
If every post shares the same modest cap value, the effective loudness region for each will extend only a few neighbors to either side.
Thus, even large gaps between distant posts will not matter, because those posts fall outside every other’s capped range.

**[THOUGHT_02_05]**

A special case occurs when another post lies exactly at the distance equal to the loudness cap.
In this situation, the loudness is taken as exactly the cap value itself.
This confirms that equality conditions are inclusive and do not cause discontinuities in loudness totals.

**[THOUGHT_02_06]**

When the input reaches its largest possible scale, positions can be as large as one billion in magnitude and the number of posts can reach two hundred thousand.
Even if every post were to contribute the full maximum loudness to every other post, the resulting sum per post would stay well below the limit that a sixty-four-bit integer can safely represent.
This ensures that no overflow will occur during computation.


**[THOUGHT_02_07]**

Testing on a few small and random configurations helps confirm correctness.
We can manually sum up contributions for each post by comparing distances and caps to ensure that our interpretation of the loudness rule remains consistent.

**[THOUGHT_02_08]**

When only two posts exist, and one or both have a zero cap, the loudness simply becomes zero in the capped direction.
This serves as an easy boundary test for logic correctness.

**[THOUGHT_02_09]**

If all caps are significantly larger than any actual distance between posts, every post effectively contributes the true distance to each other without clipping.
This forms a baseline case where no cap limits are active.

---

**[CHAIN_03]**

Developing the brute-force baseline

**[THOUGHT_03_01]**

The most direct method follows the problem definition literally.
For each post, we examine every other post, determine the distance between them, apply the correct cap for that direction, and add the result to that post’s total loudness.
This guarantees perfect correctness but requires many pairwise comparisons.

**[THOUGHT_03_02]**

Because this approach implements the problem statement exactly, it will always produce the correct answer for any input.
It serves as a reliable reference for testing more advanced methods later.

**[THOUGHT_03_03]**

For two hundred thousand posts, the quadratic algorithm performs roughly forty billion pair evaluations, which already exceeds practical time limits.

**[THOUGHT_03_04]**

Even with highly optimized loops or compiled code, this quadratic runtime is unmanageable.
Moreover, this method ignores helpful properties of the data, such as sorted positions and contiguous regions of influence, which could be exploited to accelerate the computation.

**[THOUGHT_03_05]**

The brute-force algorithm is excellent for verifying correctness on small datasets but fails to meet time constraints for large inputs.
We will therefore need to introduce more structure-aware optimizations such as binary search and prefix-sum techniques.

---

**[CHAIN_04]**

Introducing prefix sum and limitations of naive scanning

**[THOUGHT_04_01]**

We can create an auxiliary array that holds cumulative sums of post positions or any derived quantity.
This allows us to compute totals across any continuous range of posts in constant time by subtracting two entries in the prefix-sum array.

**[THOUGHT_04_02]**

To know where a post’s influence begins and ends, we need to find which neighboring posts lie within its cap distances.
Binary search is an ideal tool for identifying those boundary positions efficiently in the sorted list of post coordinates.

**[THOUGHT_04_03]**

Even if we try to reuse information from previous iterations, the left and right boundaries for each post can shift unpredictably.
In extreme cases, a naive scanning approach might still need to inspect nearly every post for each iteration, which leads back to quadratic behavior.

**[THOUGHT_04_04]**

By combining both directional scans, the total work can still reach the square of the number of posts in unfavorable inputs.
This makes scanning alone insufficient as an optimization strategy, even when aided by prefix sums.

**[THOUGHT_04_05]**

While prefix sums simplify summation over contiguous ranges, they do not solve the boundary identification problem.
To achieve efficiency, we must combine prefix sums with logarithmic-time boundary detection using binary search — an approach that balances speed with clarity.

---

**[CHAIN_05]**

Introducing binary searches over cap boundaries and combining with prefix sum

**[THOUGHT_05_01]**

When we look to the west of a given post, the distances between that post and all earlier ones grow steadily as we move leftward.  
All posts whose distance does not exceed the left-side cap form one continuous block next to the current post.  
The first post in that block can be located efficiently using a binary search that looks for the earliest position not smaller than the current post’s position minus its left-side limit.  
The same logic applies to the east: we search for the earliest position that exceeds the current post’s position plus its right-side limit.  
Each of these binary searches takes logarithmic time.

**[THOUGHT_05_02]**

We create a cumulative array that stores the running total of all post positions.
The first entry is zero, and each subsequent entry adds the next position value.
This structure lets us instantly find the total position value between any two indices by subtracting the prefix-sum value at the start from the prefix-sum value just past the end.
It transforms multiple additions into a constant-time difference operation.

**[THOUGHT_05_03]**

For the west side of a post, the indices within range form a continuous block that ends immediately before the current post.
The total loudness from these posts can be broken down into two parts:

The contribution from posts still within the left-side cap, which depends on the difference between the current position and each earlier position.

The contribution from posts lying farther away, which each contribute the full left-side cap value.
The count of in-cap and out-of-cap posts is derived directly from the binary search results and the index of the current post.

**[THOUGHT_05_04]**

On the east side, the logic mirrors that of the west.
The posts within the right-side cap form a contiguous block that begins immediately after the current post.
Their contribution depends on the difference between each of their positions and the current one.
Posts that fall outside the cap contribute a fixed value equal to the right-side limit.
Again, prefix-sum subtraction allows us to compute the total contribution in constant time once the range boundaries are known.

**[THOUGHT_05_05]**

Combining results for each post

The total loudness for any post is obtained by adding four components:

The in-cap contribution from the west

The out-of-cap contribution from the west

The in-cap contribution from the east

The out-of-cap contribution from the east

Each component can be expressed using counts and prefix-sum differences, all computable in constant time once the two binary searches have been performed.
Thus, the loudness for one post can be derived efficiently without scanning all others.

**[THOUGHT_05_06]**

For each post, only two binary searches are needed, each taking logarithmic time.
The arithmetic per post involves a fixed number of additions and multiplications.
This results in an overall runtime proportional to $n \log n$ and a memory requirement proportional to n, which is perfectly manageable for the problem’s constraints.
Since all calculations follow directly from the problem’s definitions and use mathematically equivalent transformations, correctness is preserved.

**[THOUGHT_05_07]**

When searching for the western limit, we include the post whose position exactly matches the current position minus the left cap.
Similarly, for the eastern limit, we include the post that exactly matches the current position plus the right cap.
These conventions ensure that equality cases are handled consistently and that no posts are skipped or double-counted.

---

**[CHAIN_06]**

Exploring the limits of global two-pointer optimization

**[THOUGHT_06_01]**

It may appear possible to use a pair of moving pointers to track the valid range of posts as we progress from left to right.
This works well when the limits grow or shrink monotonically.
However, in this particular problem, the boundaries are not guaranteed to move in only one direction.

**[THOUGHT_06_02]**

The left boundary for a post depends on its position minus its left cap, and the right boundary depends on its position plus its right cap.
While positions always increase, the cap values vary independently for each post.
This independence allows the boundaries to shift forward or backward arbitrarily, destroying the consistent trend that two-pointer algorithms depend on.

**[THOUGHT_06_03]**

Imagine three posts arranged from left to right, with their left caps set as zero, a large number, and zero respectively.
As we move from one post to the next, the west boundary first jumps to include nearly all earlier posts, then instantly excludes them all.
This behavior shows that there is no predictable pattern we can exploit for continuous sweeping.

**[THOUGHT_06_04]**

Even sorting the posts by adjusted thresholds such as “position minus left limit” or “position plus right limit” does not resolve the issue.
The total loudness depends directly on the current post’s position within those ranges, so the results cannot be combined across multiple posts without recomputing the relevant boundaries.
As a result, any global sweeping method still requires recalculation for each post.

**[THOUGHT_06_05]**

While the two-pointer approach is a powerful tool for problems with consistently expanding or contracting windows, this problem’s per-post variability breaks that assumption.
Therefore, a per-post binary search combined with prefix-sum arithmetic remains the correct and efficient solution.

---

**[CHAIN_07]**

Verifying indexing rules and boundary correctness

**[THOUGHT_07_01]**

The west-side block includes all posts from the identified left boundary up to just before the current one.
If the left boundary coincides with the current post, the range is empty.
If it is one step earlier, only a single neighbor is considered.
When the boundary extends to the very start, all earlier posts are included.
These checks ensure the indices are aligned correctly and prevent off-by-one mistakes.

**[THOUGHT_07_02]**

On the east, the valid range begins immediately after the current post and ends just before the identified right boundary.
If that boundary immediately follows the current post, the range is empty.
If it extends by one position, only the nearest neighbor contributes.
If it reaches the end of the list, all later posts are included.
This mirrors the inclusion and exclusion pattern established on the west.

**[THOUGHT_07_03]**

We confirm that when the left or right boundaries coincide with the post itself, the counts of in-range posts become zero, and when the boundaries reach the dataset limits, the out-of-range counts vanish.
This guarantees that every situation is covered, and no negative counts can occur.

**[THOUGHT_07_04]**

When a neighboring post lies exactly at the distance specified by the cap, it is treated as part of the capped region and contributes its capped value.
This applies symmetrically to both sides, ensuring that equality conditions produce consistent results.

**[THOUGHT_07_05]**

To ensure numerical safety, we perform subtractions and additions in an order that avoids temporary values growing unnecessarily large.
All arithmetic uses 64-bit integers, which are easily sufficient for the problem’s bounds.
This ordering also improves clarity in code but, more importantly, guarantees mathematical stability in reasoning.

---

**[CHAIN_08]**

Implementation verification and testing strategy

**[THOUGHT_08_01]**

We store positions and cap values in standard arrays or lists, and maintain an additional prefix-sum array that starts at zero and accumulates each position value.
Every calculation is performed using a numeric type that supports large integers to eliminate any chance of overflow.

**[THOUGHT_08_02]**

To determine how far the sound reaches on each side, we apply binary searches to the sorted list of positions.
On the west, the search identifies the first post whose position is not less than the current position minus its left-side limit.
On the east, the search finds the first post whose position exceeds the current position plus its right-side limit.
These two boundaries mark exactly where the capped influence begins and ends.

**[THOUGHT_08_03]**

We validate the implementation by comparing its results with those of the brute-force version on small datasets.
Specific tests are constructed to cover zero caps, equality at threshold values, extremely large positions, and random configurations.
We also include large-scale tests with the maximum number of posts to ensure that the optimized approach runs efficiently within time limits.

**[THOUGHT_08_04]**

For each test, the optimized algorithm produces the same total loudness values as the brute-force reference.
This confirms the correctness of the binary search boundaries, the prefix-sum usage, and the overall arithmetic.
The matching results across all scenarios validate the reasoning structure.

**[THOUGHT_08_05]**

The combined approach of binary searches and prefix-sum calculations yields a solution that is both correct and efficient.
All edge cases, equality conditions, and data limits have been examined.
The final method achieves logarithmic scaling per post and is suitable for all problem constraints.

---

**[CHAIN_09]**

Reflecting on alternatives and confirming the chosen method’s suitability

**[THOUGHT_09_01]**

The final approach consolidates the prefix sums and binary searches to efficiently compute total loudness per post.

**[THOUGHT_09_02]**

We rely primarily on arrays for positions, left and right caps, and prefix sums.

**[THOUGHT_09_03]**

Compared with brute-force attempts, this method reduces runtime from $O(n^2)$ to $O(n \log n)$ by exploiting contiguity and efficient boundary location.

**[THOUGHT_09_04]**

The final method thrives precisely because the positions are sorted and distances are monotonic with index. It strikes the right balance: $O(n \log n)$ is efficient within the constraints, simple to implement correctly, and robust against adversarial inputs.

**[THOUGHT_09_05]**

We verified correctness through:
- Brute-force checks on small $n$
- Validation of both sample inputs
- Boundary tests for $L_i$, $R_i$, and large coordinates
The $O(n \log n)$ method matches direct $O(n^2)$ results and stays within $10^{15}$ bounds, confirming correctness and efficiency.


---

**[RESPONSE]**

**1. Problem Understanding**

We are given $n$ whistleposts placed at strictly increasing coordinates $p_1 < p_2 < \cdots < p_n$. Each post $i$ has two directional caps: a westward cap $L_i$ and an eastward cap $R_i$. When post $i$ "greets," the loudness perceived at another post $j$ depends on direction:
- For $j < i$ (west of $i$): the contribution is $ \min(p_i - p_j, L_i) $.
- For $j > i$ (east of $i$): the contribution is $ \min(p_j - p_i, R_i) $.

For each post $i$, we must compute the total loudness heard by all other posts:
$ \text{total}_i = \sum_{j < i} \min(p_i - p_j, L_i) + \sum_{j > i} \min(p_j - p_i, R_i) $.

Key observations:
- Positions are sorted, so distances from $i$ grow monotonically as we move away from $i$.
- For a fixed cap $L_i$ or $R_i$, the indices that fall within the cap form contiguous ranges adjacent to $i$.
- Distances over contiguous ranges can be summed efficiently using prefix sum of positions.
- We must use 64-bit integers for correctness due to large values and sums.

Constraints:
- $2 \le n \le 2 \cdot 10^5$.
- Positions are strictly increasing: $p_1 < p_2 < \cdots < p_n$ and $|p_i| \le 10^9$.
- Caps are bounded: $0 \le L_i, R_i \le 10^9$.


**2. Optimal Approach**

We exploit contiguity and sorted positions to obtain $O(n \log n)$ time:
1. Precompute prefix sum of positions:
   - Let $S[t]$ be the sum of positions $p_0 + p_1 + \cdots + p_{t-1}$ with $S[0] = 0$. Then the sum over a range $[l, r]$ is $S[r+1] - S[l]$.

2. For each index $i$, split the computation into west and east parts:
   - West (indices $j < i$):
     - Find the first index $L$ with $p_L \ge p_i - L_i$ using lower_bound. The in-cap west indices are $[L, i-1]$, and the out-of-cap west indices are $[0, L-1]$.
     - Let $c_w = i - L$. Exact-distance sum to in-cap posts is $c_w \cdot p_i - (S[i] - S[L])$.
     - Out-of-cap posts contribute $L \cdot L_i$.
   - East (indices $j > i$):
     - Find the first index $R$ with $p_R > p_i + R_i$ using upper_bound. The in-cap east indices are $[i+1, R-1]$, and the out-of-cap east indices are $[R, n-1]$.
     - Let $c_e = R - i - 1$. Exact-distance sum to in-cap posts is $(S[R] - S[i+1]) - c_e \cdot p_i$.
     - Out-of-cap posts contribute $((n - 1 - i) - c_e) \cdot R_i$.

3. Sum the four components to get $\text{total}_i$.

Why this works:
- lower_bound and upper_bound locate cap boundaries in $O(\log n)$ due to sorted positions.
- Prefix sum convert a sum of distances over a contiguous block into $O(1)$.
- Equality at thresholds is handled correctly: west uses lower_bound (include equality), east uses upper_bound (include equality).


**3. Code**
```cpp
#include <algorithm>
#include <iostream>
#include <vector>

/**
 * @brief Compute total loudness emitted by one whistlepost toward all others.
 *
 * Uses prefix sums and binary search to calculate the total loudness
 * contributed by a single post considering directional loudness caps.
 *
 * @param positions Sorted positions of all whistleposts.
 * @param leftCaps Westward (left) loudness caps for each post.
 * @param rightCaps Eastward (right) loudness caps for each post.
 * @param prefixSum Prefix sum of positions, where prefixSum[t] = sum of positions[0..t-1].
 * @param index Index of the post currently being processed.
 * @return The total loudness emitted by the given post (64-bit integer).
 */
long long computeTotalLoudness(
    const std::vector<long long>& positions,
    const std::vector<long long>& leftCaps,
    const std::vector<long long>& rightCaps,
    const std::vector<long long>& prefixSum,
    int index) {
    
    const int n = static_cast<int>(positions.size());
    const long long currentPosition = positions[index];
    const long long currentLeftCap = leftCaps[index];
    const long long currentRightCap = rightCaps[index];

    // ---------- WEST (left side) ----------
    int leftIndex = static_cast<int>(
        std::lower_bound(positions.begin(), positions.end(),
                         currentPosition - currentLeftCap) - positions.begin());

    long long inCapWest = index - leftIndex;
    long long outCapWest = leftIndex;
    if (inCapWest < 0) inCapWest = 0;
    if (outCapWest < 0) outCapWest = 0;

    // Sum of (p_i - p_j) for j in [leftIndex, index - 1]
    long long westSumInCap =
        inCapWest * currentPosition - (prefixSum[index] - prefixSum[leftIndex]);
    long long totalWest = westSumInCap + outCapWest * currentLeftCap;

    // ---------- EAST (right side) ----------
    int rightIndex = static_cast<int>(
        std::upper_bound(positions.begin(), positions.end(),
                         currentPosition + currentRightCap) - positions.begin());

    long long inCapEast = rightIndex - (index + 1);
    long long outCapEast = (n - 1 - index) - inCapEast;
    if (inCapEast < 0) inCapEast = 0;
    if (outCapEast < 0) outCapEast = 0;

    // Sum of (p_j - p_i) for j in [index + 1, rightIndex - 1]
    long long eastSumInCap =
        (prefixSum[rightIndex] - prefixSum[index + 1]) - inCapEast * currentPosition;
    long long totalEast = eastSumInCap + outCapEast * currentRightCap;

    // ---------- TOTAL ----------
    return totalWest + totalEast;
}

/**
 * @brief Program entry point.
 *
 * Reads input for whistlepost positions and caps, computes total loudness for
 * each post, and outputs results. Runs in O(n log n) using prefix sums and
 * binary search for efficient range processing.
 *
 * Input format:
 *  n
 *  p1 p2 ... pn
 *  L1 L2 ... Ln
 *  R1 R2 ... Rn
 *
 * Output format:
 *  One line per post containing its total loudness.
 */
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    if (!(std::cin >> n)) {
        return 0;
    }

    std::vector<long long> positions(n);
    std::vector<long long> leftCaps(n);
    std::vector<long long> rightCaps(n);

    for (int i = 0; i < n; ++i) std::cin >> positions[i];
    for (int i = 0; i < n; ++i) std::cin >> leftCaps[i];
    for (int i = 0; i < n; ++i) std::cin >> rightCaps[i];

    // Prefix sum of positions
    std::vector<long long> prefixSum(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + positions[i];
    }

    // Compute total loudness per post
    for (int i = 0; i < n; ++i) {
        long long result =
            computeTotalLoudness(positions, leftCaps, rightCaps, prefixSum, i);
        std::cout << result << '\n';
    }

    return 0;
}

```

**4. Code Explanation**

- We precompute prefix sum of positions to allow constant-time range sum queries of positions.
- For each index $i$, we:
  - Use lower_bound on $p_i - L_i$ to find the first index $L$ on the west that is within the cap. Indices $[L, i-1]$ are in-cap and contribute exact distances; indices $[0, L-1]$ are out-of-cap and each contribute $L_i$.
  - Use upper_bound on $p_i + R_i$ to find the first index $R$ on the east that exceeds the cap. Indices $[i+1, R-1]$ are in-cap and contribute exact distances; indices $[R, n-1]$ are out-of-cap and each contribute $R_i$.
- Exact-distance sums are computed via prefix sum:
  - West in-cap: $ (i - L) \cdot p_i - (S[i] - S[L]) $.
  - East in-cap: $ (S[R] - S[i+1]) - (R - i - 1) \cdot p_i $.
- We add the out-of-cap contributions and print the total for each $i$.
- Edge cases like zero caps and threshold equalities are naturally handled by the chosen bounds (lower_bound includes equality on the west, upper_bound includes equality on the east).

Example walkthrough (detailed, using the optimal algorithm):

- Example A (from the statement): $n = 3$, $p = [-10^9, 0, 10^9]$, $L = [10^9,10^9,10^9]$, $R = [10^9,10^9,10^9]$.
  - Build prefix sum $S$: $S = [0, -10^9, -10^9, 0]$.
  - Index $i = 1$ (0-based), $p_i = 0$, $L_i = R_i = 10^9$:
    - West: threshold $p_i - L_i = -10^9$, $L = \text{lower\_bound}(p, -10^9) = 0$.
      - $c_w = i - L = 1$, $o_w = L = 0$.
      - $\text{sumInCapWest} = c_w\,p_i - (S[i] - S[L]) = 1\cdot 0 - (S[1]-S[0]) = 10^9$.
    - East: threshold $p_i + R_i = 10^9$, $R = \text{upper\_bound}(p, 10^9) = 3$.
      - $c_e = R - i - 1 = 1$, $o_e = (n-1-i) - c_e = 1 - 1 = 0$.
      - $\text{sumInCapEast} = (S[R] - S[i+1]) - c_e\,p_i = (S[3]-S[2]) - 1\cdot 0 = 10^9$.
    - Total $= 10^9 + 0\cdot 10^9 + 10^9 + 0\cdot 10^9 = 2\cdot 10^9$.
  - Index $i = 0$ (endpoint), $p_i = -10^9$, $L_i = R_i = 10^9$:
    - West: none ($L = 0$, $c_w = 0$, $o_w = 0$), $\text{sumInCapWest} = 0$.
    - East: $R = \text{upper\_bound}(p, 0) = 2$, $c_e = 1$, $o_e = 1$.
      - $\text{sumInCapEast} = (S[2]-S[1]) - 1\cdot p_i = 0 - (-10^9) = 10^9$.
    - Total $= 0 + 0 + 10^9 + 1\cdot 10^9 = 2\cdot 10^9$ (symmetric for $i=2$). Matches expected outputs (all $2\cdot 10^9$).

- Example B (from the statement):
  $p = [0,2,4,8,16,17,40]$, $L = [0,1,10,0,20,1,5]$, $R = [1,0,10,1,0,20,0]$.
  - Prefix sum $S$: $S=[0,0,2,6,14,30,47,87]$.
  - Index $i = 2$ ($p_i = 4$, $L_i = R_i = 10$):
    - West: threshold $p_i - L_i = -6$, $L = 0$.
      - $c_w = 2$, $o_w = 0$.
      - $\text{sumInCapWest} = 2\cdot 4 - (S[2]-S[0]) = 8 - 2 = 6$.
    - East: threshold $p_i + R_i = 14$, $R = 4$ (first index with $p_R > 14$ is $p_4 = 16$).
      - $c_e = 4 - 2 - 1 = 1$, $o_e = (6 - 2) - 1 = 3$.
      - $\text{sumInCapEast} = (S[4]-S[3]) - 1\cdot 4 = (14 - 6) - 4 = 4$.
    - Total $= 6 + 0\cdot 10 + 4 + 3\cdot 10 = 40$ (matches expected for the 3rd post).
  - Index $i = 5$ ($p_i = 17$, $L_i = 1$, $R_i = 20$):
    - West: threshold $p_i - L_i = 16$, $L = 4$.
      - $c_w = 5 - 4 = 1$, $o_w = 4$.
      - $\text{sumInCapWest} = 1\cdot 17 - (S[5]-S[4]) = 17 - (30 - 14) = 1$.
    - East: threshold $p_i + R_i = 37$, $R = 6$ (first $>37$ is $p_6 = 40$).
      - $c_e = 6 - 5 - 1 = 0$, $o_e = (6 - 5) - 0 = 1$.
      - $\text{sumInCapEast} = 0$.
    - Total $= 1 + 4\cdot 1 + 0 + 1\cdot 20 = 25$ (matches expected for the 6th post).
  - Index $i = 0$ ($p_i = 0$, $L_i = 0$, $R_i = 1$):
    - West: none ($L = 0$, $c_w = 0$, $o_w = 0$).
    - East: $R = \text{upper\_bound}(p, 1) = 1$.
      - $c_e = 1 - 0 - 1 = 0$, $o_e = (6 - 0) - 0 = 6$.
      - $\text{sumInCapEast} = 0$.
    - Total $= 0 + 0 + 0 + 6\cdot 1 = 6$ (matches expected for the 1st post).

These step-by-step computations demonstrate prefix-sum construction, boundary discovery via lower_bound/upper_bound, in-cap vs out-of-cap splits, counts $(c_w, o_w, c_e, o_e)$, and the final arithmetic matching the expected outputs.

**5. Time and Space Complexity**

- Time complexity:
  - Building prefix sum: $O(n)$.
  - For each index $i$, two binary searches and $O(1)$ arithmetic: $O(\log n)$ per $i$.
  - Total: $O(n \log n)$.
- Space complexity:
  - Arrays for positions, caps, and prefix sum: $O(n)$.

**6. Conclusion**

By leveraging sorted positions, binary searches to find cap boundaries, and prefix sum to aggregate distances over contiguous ranges, we compute each post’s total loudness in $O(\log n)$ time per post. The method is simple, robust to edge cases, and efficient for $n \le 200000$, while adhering to 64-bit arithmetic requirements for correctness.
