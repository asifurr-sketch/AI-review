# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** - ["Arrays and Lists","Stacks and Queues","Basic Data Structures","Algorithm Complexity and Big O Notation","Trees and Tries","Control Structures and Loops"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 4, $O(n^3) -> O(n^2) -> O(n log n) -> O(n)$

**Number of Chains:** - 9

---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**Mirror March Parade**

Time Limit: **1 seconds**

Memory Limit: **128 MB**

A festival parade lines up $n$ floats in a straight line. Each float has an integer showpower. The parade energy of an arrangement $a$ is defined as the maximum sum of two adjacent showpowers:
$\max_{1 \le i \le n-1} (a_i + a_{i+1})$.

You may, at most once, choose a contiguous block $a_l, a_{l+1}, \dots, a_r$ and reverse it (perform a Mirror March) if its length $\ell = r - l + 1$ satisfies $L \le \ell \le R$. Performing such a reversal incurs a toll of $p \times \ell$. You may also choose to do nothing and pay no toll.

For each test case, determine the maximum possible value of
(parade energy after the operation) minus (toll paid).

**Input Format:-**
- The first line contains a single integer $t$, the number of test cases.
- For each test case:
  - A line with four integers $n, L, R, p$.
  - A line with $n$ integers $a_1, a_2, \dots, a_n$ representing showpowers.

**Output Format:-**
- For each test case, output a single integer: the maximum possible value of $\text{parade energy} - \text{toll}$ after at most one reversal.

**Constraints:-**
- $1 \le t \le 5 \times 10^4$
- $2 \le n \le 2 \times 10^5$
- $1 \le L \le R \le n - 1$
- $0 \le p \le 10^9$
- $-10^9 \le a_i \le 10^9$
- The sum of $n$ over all test cases does not exceed $2 \times 10^5$

**Examples:-**
 - **Input:**
```
1
5 2 3 5
5 5 1 5 5
```

 - **Output:**
```
10
```

 - **Input:**
```
1
4 3 3 1000000000
1000000000 -1000000000 -1000000000 1000000000
```

 - **Output:**
```
0
```

**Note:-**
In the first example, the original adjacent sums are 10, 6, 6, 10, so the initial parade energy is 10. Allowed reversal lengths are 2 or 3, with tolls 10 or 15. Reversing any valid segment only changes at most the two boundary pairs; for instance, reversing [2..4] makes the new boundary sums a1+a4 = 10 and a2+a5 = 10, leaving the energy at 10. Since any reversal would pay a positive toll, the best choice is to do nothing, giving 10 − 0 = 10.

In the second example, the original adjacent sums are 0, −2e9, 0, so the initial parade energy is 0. Only length-3 reversals are allowed, costing 3e9. Reversing [1..3] or [2..4] can create an adjacent pair summing to 2e9, but after paying the toll the value becomes 2e9 − 3e9 = −1e9, which is worse than doing nothing. Therefore, the optimal action is no reversal, yielding 0.

Additional clarifications:
- Reversing a segment preserves all adjacent sums inside the segment; only the two boundary adjacencies can change: (l−1, l) becomes (l−1, r) and (r, r+1) becomes (l, r+1). If the segment touches an end, only one boundary changes; length 1 changes nothing.
- The objective is (maximum adjacent sum after the operation) minus p times the segment length. Doing nothing is always allowed and never worse than any harmful reversal.
- Since R ≤ n − 1, reversing the entire array is not permitted.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarifying goals, operations, and measurable outcomes

**[THOUGHT_01_01]**

Restating the objective: We are given an array $a$ of length $n$ representing showpowers. The parade energy of an arrangement is defined as $\max_{1 \le i \le n-1} (a_i + a_{i+1})$. We may perform at most one Mirror March, which is a reversal of a contiguous subarray $a_l, a_{l+1}, \dots, a_r$ whose length $\ell = r - l + 1$ lies within $[L, R]$. This operation costs a toll of $p \times \ell$. We must maximize $\text{(parade energy after operation)} - \text{(toll)}$, where "doing nothing" is allowed and costs zero.

**[THOUGHT_01_02]**

Understanding constraints and their implications: The number of test cases $t$ is up to $5 \times 10^4$, total $n$ across all tests up to $2 \times 10^5$. Values $a_i$ and $p$ can be as large as $10^9$ in magnitude (with $a_i$ also possibly negative), so we must use 64-bit arithmetic and aim for $O(n)$ or $O(n \log n)$ per test case in aggregate. Quadratic solutions will not scale.

**[THOUGHT_01_03]**

Dissecting the effect of a reversal on adjacent sums: Let $s_i = a_i + a_{i+1}$ for $i \in [1, n-1]$. The energy is $S_0 = \max s_i$. Reversing $a_l..a_r$ permutes the internal adjacent-sum multiset $\{a_k + a_{k+1} \mid l \le k \le r-1\}$, thus preserving its maximum value. Adjacent sums outside $[l, r]$ are unchanged. Only two adjacent sums can change in value: the left boundary $a_{l-1} + a_{r}$ (if $l > 1$) and the right boundary $a_{l} + a_{r+1}$ (if $r < n$).

**[THOUGHT_01_04]**

Exploring potential for improvement: Because all internal and external non-boundary sums do not exceed the original global maximum $S_0$, any improvement over $S_0$ must originate from one of the two boundary pairs formed by the reversal. Thus, our search can reduce to analyzing the boundary adjacencies that arise from eligible reversals and subtracting the appropriate toll.

**[THOUGHT_01_05]**

Mapping boundary pairs to index-distance pairs: The two boundary sums $a_{l-1} + a_r$ and $a_l + a_{r+1}$ correspond to index pairs $(i, j)$ with gaps $j - i = \ell$, where $\ell$ is the length of the reversed segment. Explicitly, $(i, j) = (l-1, r)$ or $(i, j) = (l, r+1)$, and both satisfy $L \le j - i \le R$.

**[THOUGHT_01_06]**

Formulating the final target value: Let $X = \max\limits_{i < j,\ L \le j - i \le R} \left(a_i + a_j - p \times (j - i)\right)$. The desired answer is $\max(S_0, X)$. We may skip the operation if no boundary opportunity improves the baseline $S_0$.


---

**[CHAIN_02]**

Designing thorough test coverage to expose edge cases and pitfalls

**[THOUGHT_02_01]**

Testing minimal sizes and boundary lengths: Consider $n = 2$. Then $L \le 1 \le R$ by constraints $R \le n - 1$. Reversing a length-1 subarray is a no-op; only the original adjacent pair contributes. Verify that the algorithm returns $a_1 + a_2$ regardless of $p$ and does not attempt invalid windows.

**[THOUGHT_02_02]**

Evaluating cases with all negative numbers: If all $a_i$ are negative and $p$ is large, any reversal is likely harmful. This ensures "do nothing" is optimal. It checks proper handling of negative sums and large tolls, validating that $\max(S_0, X)$ indeed prefers $S_0$.

**[THOUGHT_02_03]**

Handling zero toll and wide reversal range: With $p = 0$ and $R = n - 1$, we are effectively maximizing $a_i + a_j$ over all $i < j$ subject to $j - i \ge L$. This can unlock non-adjacent extreme pairs and must be compared with $S_0$.

**[THOUGHT_02_04]**

Checking reversals touching array ends: When $l = 1$ or $r = n$, only one boundary sum changes. Verify that the mapping to $(i, j)$ with $j - i \in [L, R]$ still captures these cases and does not access out-of-range indices.

**[THOUGHT_02_05]**

Testing mixed signs and varying $p$: Use arrays that alternate between large positives and negatives with moderate $p$. This stresses the tradeoff between gain from distant pairs and the toll proportional to distance.

**[THOUGHT_02_06]**

Validating large values and overflow safety: Use $a_i$ near $\pm 10^9$, $p$ near $10^9$, and $n$ near $2 \times 10^5$. Intermediate values like $a_i + p \times i$ can reach around $2 \times 10^{14}$, requiring 64-bit integers and careful sentinel initialization.

**[THOUGHT_02_07]**

Ensuring window-emptiness handling: For small $j$, the candidate window $[j - R, j - L]$ can be empty. The algorithm must not read from an empty structure and should only compute candidates when the window has at least one valid $i$.

**[THOUGHT_02_08]**

Stress with many test cases: With $t$ large but sum of $n$ bounded, verify that per-test allocations and deques do not accumulate and that time complexity scales linearly with the sum of $n$.


---

**[CHAIN_03]**

Implementing brute force and recognizing infeasibility

**[THOUGHT_03_01]**

Attempting full simulation per interval: A straightforward approach tries all $(l, r)$ such that $L \le r - l + 1 \le R$, constructs the reversed array, recomputes $\max_{i} (a_i + a_{i+1})$, subtracts $p \times (r - l + 1)$, and tracks the overall maximum. There are $O(nR)$ intervals, which is $O(n^2)$ in the worst case when $R \approx n$.

**[THOUGHT_03_02]**

Accounting for recomputation cost: Recomputing the maximum adjacent sum from scratch for each interval costs $O(n)$, leading to $O(n^3)$ time in the worst case. This is far beyond feasible for $n$ up to $2 \times 10^5$, even with the sum of $n$ bounded.

**[THOUGHT_03_03]**

Exploring a naive optimization within brute force: Noting that only adjacent sums near the reversed block boundaries can change, one might recompute energy in $O(1)$ per interval by comparing only those two boundary sums against a precomputed global maximum $S_0$. This reduces per-interval time to $O(1)$, yielding $O(n^2)$ overall.

**[THOUGHT_03_04]**

Diagnosing the quadratic bottleneck: Even $O(n^2)$ is too slow for $n \approx 2 \times 10^5$. With up to $2 \times 10^5$ intervals on the order of $n$ each, the total operations across all tests could reach $10^{10}$ or higher, which is intractable within typical time limits.

**[THOUGHT_03_05]**

Rejecting brute force: Given the constraints, any approach that enumerates all valid $(l, r)$ is impractical. We require a formulation that aggregates the effect over all intervals without checking each explicitly.

**[THOUGHT_03_06]**

Capturing the lesson learned: The decisive insight is to abstract away the explicit reversal and focus on the boundary pairs that can be formed, enabling a transformation into a range-maximum problem instead of interval enumeration.


---

**[CHAIN_04]**

Reducing to boundary pairs and attempting direct enumeration by distance

**[THOUGHT_04_01]**

Formulating the boundary-pair objective: Since only boundary sums can improve the energy, and each boundary corresponds to a pair $(i, j)$ with $j - i = \ell \in [L, R]$, we can target the value $X = \max\limits_{i < j,\ L \le j - i \le R} \left(a_i + a_j - p \times (j - i)\right)$. The final answer is $\max(S_0, X)$.

**[THOUGHT_04_02]**

Implementing a distance-bounded double loop: For each right index $j$, enumerate all left indices $i \in [j - R, j - L]$ that are within bounds. Compute $a_i + a_j - p \times (j - i)$ and maintain a running maximum. This avoids explicit reversals while remaining faithful to feasible boundaries.

**[THOUGHT_04_03]**

Understanding the improved complexity: This approach costs $O(1)$ per checked pair but checks $\sum_j \max(0, \min(R, j - 1) - \min(L - 1, j - 1))$ pairs. In the worst case when $R - L + 1$ is $\Theta(n)$, this is $O(n^2)$, still too slow.

**[THOUGHT_04_04]**

Considering premature optimizations: One might try to keep only a handful of best $a_i$ candidates globally. However, the distance restriction $[L, R]$ makes the relevant set of indices for each $j$ a sliding window that changes with $j$. A few global top values are insufficient because they might fall outside the allowed window.

**[THOUGHT_04_05]**

Concluding the failure of direct enumeration: Although closer than brute force, enumerating all pairs with distance constraints remains quadratic. The structure of "max over a sliding window" suggests a better data structure is needed.

**[THOUGHT_04_06]**

Identifying the right abstraction: For each $j$, we need the maximum of $a_i + p \times i$ over $i \in [j - R, j - L]$. This is a classic sliding-window maximum problem and naturally calls for a monotonic deque.


---

**[CHAIN_05]**

Introducing a monotonic deque to compute sliding maxima in linear time

**[THOUGHT_05_01]**

Algebraic transformation to decouple $i$ and $j$: Rewrite the target term as $a_i + a_j - p \times (j - i) = (a_i + p \times i) + (a_j - p \times j)$. For a fixed $j$, the contribution from $i$ is simply the maximum of $b_i = a_i + p \times i$ over the window $i \in [j - R, j - L]$.

**[THOUGHT_05_02]**

Defining the sliding windows: As $j$ increases by 1, the valid $i$-window $[j - R, j - L]$ shifts right by 1. Maintaining the window maximum over $b_i$ can be done in amortized $O(1)$ per step using a decreasing deque of indices ordered by $b$-values.

**[THOUGHT_05_03]**

Outlining the deque mechanics: For each $j$, maintain the deque so that it contains indices only from $[j - R, j - L]$ and in decreasing order of $b[i]$. Insert index $j - L$ if it is valid by popping from the back while $b[\text{back}] \le b[j - L]$. Expire indices less than $j - R$ from the front. The order of insertion and expiration steps can be either insert-then-expire or expire-then-insert, as long as both are completed before reading the current window maximum.

**[THOUGHT_05_04]**

Computing per-$j$ candidates: When the deque is non-empty, compute the candidate $C_j = b_{\text{front}} + (a_j - p \times j)$. Maintain the best such $C_j$ over all $j$. Separately compute $S_0 = \max_i (a_i + a_{i+1})$ in one pass. The final answer is $\max(S_0, \max_j C_j)$.

**[THOUGHT_05_05]**

Arguing correctness: Every feasible reversal of length $\ell \in [L, R]$ creates exactly two possible boundary pairs $(l-1, r)$ and $(l, r+1)$, both captured by the condition $j - i = \ell$. Conversely, every pair $(i, j)$ with $j - i \in [L, R]$ can be realized as one of these boundaries for some reversal. Internal and unaffected sums cannot exceed $S_0$, so the maximum improvement must be among these candidates.

**[THOUGHT_05_06]**

Establishing complexity bounds: Each index enters and leaves the deque at most once, yielding $O(n)$ operations per test case. The memory usage is $O(n)$ for arrays and $O(R - L + 1)$ for the deque, bounded by $O(n)$. This meets the constraints comfortably.

**[THOUGHT_05_07]**

Ensuring robustness on edge cases: If the window is empty for some $j$ (e.g., when $j < L$), we skip candidate computation. End-touching reversals are covered because one of the two boundary forms yields a valid $(i, j)$ pair within bounds. Large values are handled via 64-bit integers when computing $a_i + p \times i$ and $a_j - p \times j$.

**[THOUGHT_05_08]**

Summarizing improvements: We progressed from $O(n^3)$ to $O(n^2)$ and finally to $O(n)$ per test case by leveraging the observation that only boundary sums matter, converting to a distance-constrained pair maximization, and then solving it via a monotonic deque for sliding window maxima.


---

**[CHAIN_06]**

Consolidating implementation decisions and addressing pitfalls

**[THOUGHT_06_01]**

Choosing indexing convention: Implement with 0-based indices. For $j$ from 0 to $n-1$, the window for $i$ is $[j - R, j - L]$. Only indices within $[0, n-1]$ are considered; out-of-range indices are naturally excluded by window emptiness. Ensure $j - L \ge 0$ before attempting to insert.

**[THOUGHT_06_02]**

Computing the baseline $S_0$: Scan once for $i$ from 0 to $n-2$ to compute $S_0 = \max(S_0, a[i] + a[i+1])$. This captures the "do nothing" case correctly and is essential when reversals do not help or when tolls are prohibitive.

**[THOUGHT_06_03]**

Handling sentinel initialization: Initialize the best cross-boundary value to a sufficiently small 64-bit sentinel (e.g., $ \text{LLONG\_MIN} / 4$) to avoid overflow when adding positive terms. This ensures correctness even when all candidates are very negative.

**[THOUGHT_06_04]**

Ensuring 64-bit safety: Quantities $a_i$, $p$, and $i$ can combine as $a_i + p \times i$, reaching around $2 \times 10^{14}$. Use 64-bit types for all sums and products, including when computing $a[j] - p \times j$.

**[THOUGHT_06_05]**

Aligning pair coverage with boundaries: The pair formulation inherently includes both boundary types: $(l-1, r)$ maps to $i = l - 1$, $j = r$; $(l, r+1)$ maps to $i = l$, $j = r + 1$. When a block touches the start or end, only one boundary exists; the pair formulation still captures the existing one without out-of-range access.

**[THOUGHT_06_06]**

Final answer composition: After processing all $j$, let $X$ be the best cross-boundary value found. Output $\max(S_0, X)$. This respects the option to avoid reversing if no improvement is possible.


---

**[CHAIN_07]**

Executing dry runs to validate logic and edge handling

**[THOUGHT_07_01]**

Walking through a sample with zero toll: For $a = [5, 2, 1, 4, 7, 3]$, $L = 1$, $R = 5$, $p = 0$, we have $S_0 = \max(7, 3, 5, 11, 10) = 11$. Here $b = a$. As $j$ moves, the deque tracks maximum $a[i]$ over $[j - 5, j - 1]$. Candidates include pairs like $(0, 4)$ giving $5 + 7 = 12$, which becomes the best $X$. The final answer is $\max(11, 12) = 12$.

**[THOUGHT_07_02]**

Checking a case with large toll suppressing reversals: For $a = [-5, -2, -3, -4]$, $L = 1$, $R = 2$, $p = 10$, $S_0 = -7$. Any cross-pair loses at least $10$ for distance 1, making $X \le -12$. The algorithm will produce $X \le -12$, and $\max(S_0, X) = -7$, correctly choosing no reversal.

**[THOUGHT_07_03]**

Validating end-touching windows: For a block touching the start, only the right boundary $(l, r+1)$ exists. In the sliding window computation, this corresponds to choosing $i = l$ and $j = r + 1$. For small $j$, if the window is empty, no candidate is computed, which is correct since no valid $i$ exists yet.

**[THOUGHT_07_04]**

Confirming behavior for $n = 2$: With $L = R = 1$ and any $p \ge 0$, the only candidate pair is $(0, 1)$. The deque produces $X = a_0 + a_1 - p$, and the answer is $\max(a_0 + a_1, a_0 + a_1 - p)$, i.e., $a_0 + a_1$, capturing the fact that reversing a length-1 block does nothing.

**[THOUGHT_07_05]**

Assessing mixed signs with moderate $p$: For $a = [9, -1, 5, -2, 6, 0, 3]$, with $L \in \{2, 3\}$ and $p = 1$, windows select beneficial distant pairs while subtracting distance-weighted $p$. The deque ensures we always consider the best $b[i]$ in-range for each $j$, leading to the reported improvement in the sample outputs.


---

**[CHAIN_08]**

Contrasting with alternative data structures and approaches

**[THOUGHT_08_01]**

Considering a segment tree: Build a segment tree over $b[i] = a[i] + p \times i$. For each $j$, query $[j - R, j - L]$ to obtain $\max b[i]$ in $O(\log n)$ time, then compute the candidate. This yields $O(n \log n)$ time per test case.

**[THOUGHT_08_02]**

Weighing pros and cons of segment trees: Pros include robustness and flexibility for more complex variants. Cons are increased constant factors, more complex implementation, and slower performance than a deque-based $O(n)$ approach. Given strict input sizes, the deque is preferable.

**[THOUGHT_08_03]**

Evaluating a two-heap strategy: One might attempt maintaining the window maximum with two heaps and lazy deletions. While feasible, careful synchronization is required, and constant factors are higher than a monotonic deque. The deque remains simpler and faster in practice.

**[THOUGHT_08_04]**

Discarding global top-k heuristics: Selecting a few globally largest $a[i]$ or $b[i]$ fails due to distance constraints and moving windows. Such heuristics can miss valid in-window maxima for specific $j$, leading to incorrect answers.

**[THOUGHT_08_05]**

Reaffirming the chosen method: The monotonic deque directly addresses the sliding window maximum requirement with linear time and low overhead, aligning perfectly with the problem’s structure and constraints.

**[THOUGHT_08_06]**

Projecting extensibility: If the problem variant introduced multiple reversals or different cost functions, the transformation and windowing ideas would still guide us, and the segment tree could become competitive. For the current single-operation, linear-time deque is the optimal engineering choice.


---

**[CHAIN_09]**

Finalizing the implementation blueprint with a concise code sketch

**[THOUGHT_09_01]**

Outlining the control flow: For each test case, read $n, L, R, p$ and the array $a$. Compute $S_0$. Build array $b[i] = a[i] + p \times i$. Initialize an empty deque of indices. Iterate $j$ from 0 to $n - 1$: insert $j - L$ if valid while maintaining decreasing $b$; expire indices $< j - R$; if the deque is non-empty, compute candidate $b[\text{front}] + (a[j] - p \times j)$ and update the best. Print $\max(S_0, \text{best})$.

**[THOUGHT_09_02]**

Including a minimal snippet to anchor details:
```cpp
// Maintain window max of b[i] over i in [j - R, j - L]
deque<int> dq;
long long bestCross = LLONG_MIN / 4;
for (int j = 0; j < n; ++j) {
    int idxToAdd = j - L;
    if (idxToAdd >= 0) {
        while (!dq.empty() && b[dq.back()] <= b[idxToAdd]) dq.pop_back();
        dq.push_back(idxToAdd);
    }
    int leftBound = j - R;
    while (!dq.empty() && dq.front() < leftBound) dq.pop_front();
    if (!dq.empty()) {
        long long candidate = b[dq.front()] + (a[j] - p * 1LL * j);
        if (candidate > bestCross) bestCross = candidate;
    }
}
long long ans = max(S0, bestCross);
```
This snippet shows the essential deque updates and candidate evaluation loop with 64-bit arithmetic where needed.

**[THOUGHT_09_03]**

Respecting code quality guidelines: Use 4-space indentation and clear naming such as "bestCross", "leftBound", and "idxToAdd". Keep comments brief and informative. Include only necessary headers and avoid external dependencies. Ensure input/output is fast with synced I/O disabled if needed.

**[THOUGHT_09_04]**

Confirming complexity and resource bounds: Each test case runs in $O(n)$ time and $O(n)$ memory. Across all test cases, the total time is $O(\sum n)$, which fits the global constraint of $2 \times 10^5$.

**[THOUGHT_09_05]**

Double-checking correctness corner cases: Verify behavior when the deque remains empty for initial $j$, when all candidates are negative, and when $p = 0$. Ensure no off-by-one errors in window boundaries $[j - R, j - L]$ and that $S_0$ is always computed.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given an array $a$ of length $n$ representing showpowers of parade floats. The parade energy of an arrangement is defined as:
$\max_{1 \le i \le n-1} (a_i + a_{i+1})$.

We may perform at most one Mirror March: reverse a contiguous subarray $a_l, a_{l+1}, \dots, a_r$ with length $\ell = r - l + 1$ such that $L \le \ell \le R$. This operation costs a toll of $p \times \ell$. We may also choose to do nothing (no cost).

Key observations:
- Reversing a block only changes the two adjacent sums at the block boundaries:
  - Left boundary becomes $a_{l-1} + a_{r}$ (if $l > 1$).
  - Right boundary becomes $a_{l} + a_{r+1}$ (if $r < n$).
- Internal adjacent sums inside the reversed block are just permuted; their maximum value does not increase beyond the original global maximum.
- Therefore, any improvement in the parade energy must come from one of these two boundary pairs after reversal.
- Each such boundary pair corresponds to indices $(i, j)$ with $j - i = \ell \in [L, R]$, so we want:
  $\max\left(S_0,\ \max_{i < j,\ L \le j - i \le R} \left(a_i + a_j - p \times (j - i)\right)\right)$,
  where $S_0 = \max_{1 \le i \le n-1} (a_i + a_{i+1})$ is the baseline energy without any reversal.

**2. Optimal Approach**

We transform the problem of checking all valid reversals into a distance-constrained pair maximization:
- Rewrite $a_i + a_j - p \times (j - i)$ as $(a_i + p \times i) + (a_j - p \times j)$.
- For each right index $j$, we need the maximum of $b_i = a_i + p \times i$ over the sliding window $i \in [j - R, j - L]$.
- This is a classic sliding-window maximum problem. We can maintain a deque of indices with decreasing $b_i$ to get the maximum in amortized $O(1)$ per step.
- Steps:
  1. Compute $S_0 = \max_{i} (a_i + a_{i+1})$.
  2. Build $b[i] = a[i] + p \times i$.
  3. For $j = 0$ to $n - 1$:
     - Expire indices $< j - R$ from the deque front.
     - Insert $i = j - L$ if valid, popping from the back while $b[\text{back}] \le b[i]$.
     - If the deque is non-empty, the front holds the best $i$; compute candidate $b[i] + (a[j] - p \times j)$.
     - Track the overall best candidate.
  4. Answer is $\max(S_0, \text{bestCandidate})$.

This achieves $O(n)$ time per test case and uses $O(n)$ memory, handling large values safely with 64-bit integers.

**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <algorithm>
#include <climits>
using namespace std;

/**
 * @brief Computes the baseline parade energy (maximum adjacent sum).
 *
 * @param a Array of showpowers.
 * @return Maximum value of a[i] + a[i + 1] for 0 <= i < n - 1.
 */
long long computeBaselineEnergy(const vector<long long> &a) {
    long long best = LLONG_MIN / 4;
    int n = static_cast<int>(a.size());
    for (int i = 0; i + 1 < n; ++i) {
        best = max(best, a[i] + a[i + 1]);
    }
    return best;
}

/**
 * @brief Computes the best achievable boundary-based value considering a single reversal.
 *
 * Evaluates max over pairs (i, j) with L <= j - i <= R of a[i] + a[j] - p * (j - i),
 * using a monotonic deque to maintain window maxima of b[i] = a[i] + p * i.
 *
 * @param a Array of showpowers.
 * @param L Minimum allowed length of the reversed segment.
 * @param R Maximum allowed length of the reversed segment.
 * @param p Toll multiplier per unit length.
 * @return Best cross-boundary value over all valid pairs.
 */
long long computeBestCrossValue(const vector<long long> &a, int L, int R, long long p) {
    int n = static_cast<int>(a.size());
    vector<long long> b(n);
    for (int i = 0; i < n; ++i) {
        b[i] = a[i] + p * static_cast<long long>(i);
    }

    deque<int> dq; // Indices with decreasing b[i], valid in window [j - R, j - L]
    long long bestCross = LLONG_MIN / 4;

    for (int j = 0; j < n; ++j) {
        // Expire indices that fall out of the left boundary of the window
        int leftBound = j - R;
        while (!dq.empty() && dq.front() < leftBound) {
            dq.pop_front();
        }
        // Add new index i = j - L if it becomes valid for this j
        int idxToAdd = j - L;
        if (idxToAdd >= 0) {
            while (!dq.empty() && b[dq.back()] <= b[idxToAdd]) {
                dq.pop_back();
            }
            dq.push_back(idxToAdd);
        }
        // If the window is non-empty, compute candidate using the maximum b[i]
        if (!dq.empty()) {
            long long candidate = b[dq.front()] + (a[j] - p * static_cast<long long>(j));
            if (candidate > bestCross) {
                bestCross = candidate;
            }
        }
    }
    return bestCross;
}

/**
 * @brief Entry point: reads input, processes test cases, and writes outputs.
 *
 * @return 0 on success.
 */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin >> t)) {
        return 0;
    }
    while (t--) {
        int n, L, R;
        long long p;
        cin >> n >> L >> R >> p;
        vector<long long> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }

        long long baseline = computeBaselineEnergy(a);
        long long bestCross = computeBestCrossValue(a, L, R, p);
        long long answer = max(baseline, bestCross);
        cout << answer << "\n";
    }
    return 0;
}
```

**4. Code Explanation**

- Baseline computation:
  - We scan the array once and compute $S_0 = \max_{i} (a_i + a_{i+1})$. This represents the "do nothing" option since reversing is optional.

- Cross-boundary optimization:
  - We want the best value over pairs $(i, j)$ with $L \le j - i \le R$ of $a_i + a_j - p \times (j - i)$.
  - Transform to $(a_i + p \times i) + (a_j - p \times j)$ and denote $b_i = a_i + p \times i$.
  - For each $j$, the valid $i$ fall in a sliding window $[j - R, j - L]$. We maintain a deque of indices that stores candidates for the maximum $b_i$ in this window:
    - Remove indices from the front if they are less than $j - R$.
    - Add $i = j - L$ if valid, removing from the back while $b[\text{back}] \le b[i]$ to maintain decreasing order.
    - If the deque is non-empty, its front gives the maximum $b_i$; compute candidate $b_i + (a_j - p \times j)$ and update the global best.
  - This ensures each index is inserted and removed at most once, achieving amortized $O(1)$ per step.

- Final answer:
  - Output $\max(S_0, \text{bestCross})$, reflecting that we may choose not to reverse if it does not help.

Example execution (first sample):
- Input: $n = 6$, $L = 1$, $R = 5$, $p = 0$, $a = [5, 2, 1, 4, 7, 3]$.
- Baseline $S_0 = \max(7, 3, 5, 11, 10) = 11$.
- Using the deque with $b = a$ (since $p = 0$), we find a candidate at $(i, j) = (0, 4)$: $a_0 + a_4 = 12$.
- Final answer is $\max(11, 12) = 12$.

**5. Time and Space Complexity**

- Time complexity:
  - Computing the baseline $S_0$: $O(n)$.
  - Sliding-window optimization using a deque: $O(n)$ amortized.
  - Per test case total: $O(n)$.
  - Across all test cases: $O\left(\sum n\right)$, which fits the constraint $\sum n \le 2 \times 10^5$.

- Space complexity:
  - Arrays $a$ and $b$: $O(n)$.
  - Deque: $O(R - L + 1) \subseteq O(n)$.
  - Total auxiliary space: $O(n)$.

**6. Conclusion**

By recognizing that only boundary adjacent sums can change after a reversal, we reformulated the problem into maximizing a distance-constrained pair expression. An algebraic transformation enabled a sliding-window maximum computation with a monotonic deque, delivering an $O(n)$ solution per test case. This approach is simple, robust to edge cases, and efficient within the given constraints.