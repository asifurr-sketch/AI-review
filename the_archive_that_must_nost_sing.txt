# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** - ["Sorting Algorithms", "Arrays and Lists", "Dynamic Programming", "Greedy Algorithms", "Divide and Conquer"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 4, \(O(2^n)\) (infeasible) -> \(O(2^D)\) (infeasible) -> Greedy \(O(n \log n)\) (incorrect) -> DP \(O(n \log n)\) (optimal)

**Number of Chains:** - 7

---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**The Archive That Must Not Sing**

Time Limit: **1 seconds**

Memory Limit: **32 MB**

In a vast underground archive, every scroll has an integer pitch. If at least one scroll of each of three consecutive pitches is present at the same time, a dangerous resonance occurs. You may discard scrolls to prevent this. What is the smallest number of scrolls you must remove so that no such three-pitch resonance can ever occur?

You are given \(n\) scrolls. The \(i\)-th scroll has an integer pitch \(t_i\) (not necessarily distinct). A resonance occurs if you can choose one scroll of pitch \(x\), one of pitch \(x+1\), and one of pitch \(x+2\) for some integer \(x\). You may discard any subset of scrolls. Find the minimum number of scrolls you must discard so that no resonance can be formed from the remaining scrolls.

**Input Format:-**
- The first line contains an integer \(n\).
- The second line contains \(n\) integers \(t_1, t_2, \ldots, t_n\).

**Output Format:-**
- Print a single integer: the minimum number of scrolls to discard so that no resonance (three consecutive pitches) exists.

**Constraints:-**
- \(1 \le n \le 200000\)
- \(1 \le t_i \le 10^9\)
**Examples:-**
 - **Input:**
```
3
1 1 3
```

 - **Output:**
```
0
```

 - **Input:**
```
3
999999998 999999999 1000000000
```

 - **Output:**
```
1
```

**Note:-**
In the first example, the pitches are {1, 1, 3}. Since 2 is missing, there is no triple of consecutive pitches. No deletion is needed, so the answer is 0.

In the second example, the pitches are {999999998, 999999999, 1000000000}, which are three consecutive values. To prevent resonance, at least one of these must be removed. Deleting any single scroll works, so the answer is 1.

Additional clarifications:
- A resonance needs exactly three consecutive integer values.
- Only the presence/absence of each pitch matters for forming a triple, but multiplicities affect deletion cost.
- To break all resonances, ensure that for every \(x\), at least one of \(x\), \(x+1\), \(x+2\) is absent.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarifying objectives, constraints, and the resonance condition

**[THOUGHT_01_01]**

 There are \(n\) scrolls, each labeled with an integer pitch \(t_i\). A dangerous resonance exists if there are three pitches \(x, x+1, x+2\) such that at least one scroll of each pitch remains. We may discard any subset of scrolls. The goal is to remove the minimum number of scrolls so that no such triple of consecutive pitches is simultaneously present.


**[THOUGHT_01_02]**

 Let \(c[s]\) denote the count of scrolls with pitch \(s\). A resonance exists if there is an \(x\) with \(c[x] \ge 1\), \(c[x+1] \ge 1\), and \(c[x+2] \ge 1\). The decision we control is which scrolls to discard. The cost is the total number of removed scrolls.


**[THOUGHT_01_03]**

 \(1 \le n \le 200000\) and \(1 \le t_i \le 10^9\). The pitch domain is large, so direct frequency arrays are infeasible. Many identical pitches may exist, so duplicates matter for cost but only presence matters for creating a resonance. Overlaps among triples \((x, x+1, x+2)\) create global dependencies.


**[THOUGHT_01_04]**

 Removing a single scroll from a pitch often does not help because as long as at least one scroll of a pitch remains, that pitch can still contribute to resonance with adjacent pitches. Overlapping triples imply local choices can have global effects. We must find a strategy that globally enforces the absence of any three consecutive present pitches while minimizing the total removals.


**[THOUGHT_01_05]**

 One can think of this as hitting all consecutive triples among present pitches. If we view each distinct pitch \(s\) as a position and each triple \((s, s+1, s+2)\) as a constraint, we need to choose deletions that intersect every constraint. The weights are \(c[s]\) since deleting pitch \(s\) entirely costs removing all \(c[s]\) scrolls. Whether we truly must delete entire pitches or can do partial deletions optimally is not obvious yet and needs investigation.


**[THOUGHT_01_06]**

We have a crisp objective and the root difficulty identified: overlapping constraints on a line of distinct pitches. Next, we will build a robust test suite to ensure any approach we try can be validated across typical and adversarial cases.


---

**[CHAIN_02]**

Designing comprehensive tests to guide development and catch corner cases

**[THOUGHT_02_01]**

 Input with \(n = 3\) and pitches \([1, 1, 3]\). The distinct pitches are \(\{1, 3\}\) with counts \(c[1] = 2\) and \(c[3] = 1\). There is no pitch with value 2, so no three consecutive pitches exist. The triple \((1, 2, 3)\) cannot be formed because pitch 2 is missing. Since no resonance is possible, no deletions are needed. The expected answer is 0.


**[THOUGHT_02_02]**

 Input with \(n = 3\) and pitches \([999999998, 999999999, 1000000000]\). The distinct pitches are \(\{999999998, 999999999, 1000000000\}\) with each having count 1. These form exactly one consecutive triple \((999999998, 999999999, 1000000000)\). Any single deletion breaks the only possible resonance since we need all three consecutive pitches to form a resonance. Since all pitches have count 1, removing any one pitch costs 1. The expected answer is 1.


**[THOUGHT_02_03]**

 Input with single pitch \([5]\). Only one distinct pitch exists, so it's impossible to form any triple since resonance requires exactly three consecutive pitches. With less than 3 distinct pitches, no resonance can occur regardless of their values. The expected answer is 0.


**[THOUGHT_02_04]**

 Input with pitches \([5, 6]\). Only two distinct pitches exist, which is insufficient to form any triple since resonance requires exactly three consecutive pitches. Even though 5 and 6 are consecutive, we need a third consecutive pitch to create a resonance. With exactly 2 distinct pitches, no resonance can occur. The expected answer is 0.


**[THOUGHT_02_05]**

 Input with \(n = 200000\) and all pitches \([7, 7, 7, ..., 7]\). All scrolls have the same pitch value 7, so there is only one distinct pitch. No consecutive sequence can be formed with identical pitches since consecutive requires different values. With only one distinct pitch, no resonance is possible regardless of the large count. The expected answer is 0.


**[THOUGHT_02_06]**

 Input with \(n = 3\) and pitches \([10^9, 10^9+1, 10^9+2]\). The distinct pitches are \(\{10^9, 10^9+1, 10^9+2\}\) with each having count 1. These form exactly one consecutive triple \((10^9, 10^9+1, 10^9+2)\). Even though the values are very large, they are still consecutive integers. The problem depends on relative ordering rather than absolute values. Any single deletion breaks the only possible resonance since we need all three consecutive pitches to form a resonance. The expected answer is 1.


**[THOUGHT_02_07]**

 Input with \(n = 6\) and pitches \([1, 1, 2, 3, 4, 4]\) where counts are \(c[1] = 2\), \(c[2] = 1\), \(c[3] = 1\), \(c[4] = 2\). This creates two overlapping triples \((1,2,3)\) and \((2,3,4)\) that share common pitches. Both triples contain pitch 2 and pitch 3, creating interdependencies. To break both triples, we need to remove at least one pitch from each triple, but since they overlap, removing certain pitches can break multiple triples simultaneously. The expected answer is 1.


---

**[CHAIN_03]**

Implementing brute force to explore the solution space and observe infeasibility

**[THOUGHT_03_01]**

 Consider all subsets of the \(n\) scrolls to keep, check if the remaining set contains any triple of consecutive pitches, and track the minimum number removed. Complexity is \(2^n\), which is utterly infeasible for \(n\) up to \(200000\).


**[THOUGHT_03_02]**

 A slightly improved model enumerates, for each distinct pitch value, whether we keep at least one scroll or delete all scrolls of that pitch. This reduces the search to \(2^D\) where \(D\) is the number of distinct pitches, but \(D\) can still be up to \(n\), leading to \(2^{200000}\), which is impossible.


**[THOUGHT_03_03]**

 Even if checking feasibility for a given subset is linear in the number of distinct pitches, the exponential decision space dominates. Memory is also prohibitive for tracking states or memoizing over an enormous combinatorial space.


**[THOUGHT_03_04]**

 Brute force approaches, whether per scroll or per distinct pitch, collapse under the input limits. We must seek structure in the problem to reduce complexity by orders of magnitude, not constant factors.


---

**[CHAIN_04]**

Applying a greedy heuristic and identifying its correctness pitfalls

**[THOUGHT_04_01]**

 Sort pitches and scan for any triple \((x, x+1, x+2)\). When found, delete one scroll from the pitch among these three with the largest count or smallest count, hoping to reduce future conflicts. Repeat until no triple remains. Time complexity can be made near \(O(n \log n)\) with appropriate data structures.


**[THOUGHT_04_02]**

 Deleting one scroll often does not change feasibility. As long as at least one scroll remains for each of \(x, x+1, x+2\), the triple persists. Example: \(c[1] = 100\), \(c[2] = 1\), \(c[3] = 1\). Removing one from pitch 1 leaves the triple intact; to destroy the triple, we must zero out at least one pitch among the three.


**[THOUGHT_04_03]**

Upon encountering \((x, x+1, x+2)\), remove all scrolls from the pitch among these three with the smallest \(c[\cdot]\). Intuition: this is the cheapest local action to break the triple now.


**[THOUGHT_04_04]**

 Consider counts on pitches \(\{1, 2, 3, 4\}\) as \(c = [2, 1, 1, 2]\). The triple \((1, 2, 3)\) tempts deleting pitch 2 (cost 1), and the triple \((2, 3, 4)\) tempts deleting pitch 3 (cost 1). Doing both costs 2. However, deleting pitch 3 alone already breaks both triples at cost 1. Local greedy decisions can double-count costs because they fail to anticipate overlaps.


**[THOUGHT_04_05]**

 Greedy heuristics that focus on immediate triples cannot guarantee a global minimum due to interdependencies between overlapping triples. A principled method must reason globally across the entire block of consecutive pitches.


---

**[CHAIN_05]**

Adopting pitch-level all-or-nothing deletions and decomposing into independent blocks

**[THOUGHT_05_01]**

 If any scroll of pitch \(s\) remains, then pitch \(s\) can participate in a triple with neighbors \(s-1\) and \(s+1\) as long as those neighbors are present. Therefore, partially reducing \(c[s]\) without dropping it to zero does not change feasibility. Any optimal plan can be transformed to one that, for each pitch, either deletes none or deletes all its scrolls, without increasing cost.


**[THOUGHT_05_02]**

 After adopting all-or-nothing, define a binary decision \(x[s]\) for each present pitch \(s\), where \(x[s] = 1\) means delete pitch \(s\) entirely and \(x[s] = 0\) means keep all of it. The cost is \(\sum_{s} x[s] \cdot c[s]\). The constraints require that for every consecutive triple \((s, s+1, s+2)\) that exists in the data, \(x[s] + x[s+1] + x[s+2] \ge 1\). Equivalently, the binary sequence \(x\) cannot contain the substring "000" across present consecutive pitches.


**[THOUGHT_05_03]**

 If some integer \(v\) has \(c[v] = 0\), then triples cannot cross \(v\). Thus, the set of distinct pitches partitions into maximal blocks of consecutive values. Each block is independent because triples are fully contained within a single block. Blocks of length \(L < 3\) require no deletions.


**[THOUGHT_05_04]**

 Sort all pitches \(t_i\) and compress them into arrays \(val[k]\) and \(cnt[k]\), where \(val[k]\) is the \(k\)-th distinct pitch and \(cnt[k]\) is its multiplicity. Then scan \(val\) to identify maximal runs where \(val[k+1] = val[k] + 1\). Each run forms a block. This is \(O(n \log n)\) for sorting and \(O(D)\) for compression and scanning, where \(D\) is the number of distinct pitches.


**[THOUGHT_05_05]**

 We turned the original problem into minimizing a weighted sum under local window constraints on a line. The states of different blocks are independent, enabling divide-and-conquer. Within a block, the constraint depends only on short-range interactions, preparing the ground for dynamic programming with small memory.


**[THOUGHT_05_06]**

 We still need a method to select \(x[s]\) within a block that minimizes \(\sum x[s] \cdot c[s]\) subject to forbidding the substring "000". The next section builds a linear-time DP that achieves this.


---

**[CHAIN_06]**

Building a linear dynamic programming solution per block to hit every triple at minimum cost

**[THOUGHT_06_01]**

 Consider a block of \(L\) consecutive pitches with weights \(w[0..L-1]\), where \(w[i]\) is the count at the \(i\)-th pitch in the block. Define \(x[i] \in \{0,1\}\) to indicate deletion of the entire \(i\)-th pitch (1 means delete, 0 means keep). The cost is \(\sum_{i=0}^{L-1} x[i] \cdot w[i]\). The constraint is that for all \(i \in [0, L-3]\), we must not have \(x[i] = x[i+1] = x[i+2] = 0\).


**[THOUGHT_06_02]**

 To decide \(x[i]\), we need to ensure that the sequence \(x[i-2], x[i-1], x[i]\) does not form the forbidden pattern "000". The constraint only depends on three consecutive positions, and we're making the decision for position \(i\). Since we already know the values at positions \(i-2\) and \(i-1\) from previous decisions, we only need to check if setting \(x[i] = 0\) would create the forbidden "000" pattern. If \(x[i-2] = 0\) and \(x[i-1] = 0\), then we must set \(x[i] = 1\) to avoid "000". Otherwise, we can choose either 0 or 1 for \(x[i]\). This analysis shows that knowing only the last two decisions \(x[i-1]\) and \(x[i-2]\) is sufficient to make the optimal choice for \(x[i]\). Thus, a DP state can be defined by the last two binary decisions, ensuring constant-size state per position and linear time across the block.


**[THOUGHT_06_03]**

 Let the DP state be the pair \((a, b)\) representing the last two decisions at indices \(i-1\) and \(i\). To process the next index \(i+1\), try \(c \in \{0,1\}\) and transition from \((a, b)\) to \((b, c)\). The transition is legal unless \((a, b, c) = (0, 0, 0)\). The new cost adds \(c \cdot w[i+1]\).


**[THOUGHT_06_04]**

 If \(L \le 2\), the answer is 0 because no triple exists. Otherwise, initialize the DP after setting \(x[0]\) and \(x[1]\) for all four combinations \((a, b) \in \{0,1\}^2\) with costs \(a \cdot w[0] + b \cdot w[1]\). Then iterate \(i\) from 1 up to \(L-2\), appending \(x[i+1]\) via the transition rule.


**[THOUGHT_06_05]**

 After processing the last index in a block, the block's answer is the minimum over all terminal states \((a, b)\). The global minimal removals equal the sum of block answers because blocks are independent by construction.


**[THOUGHT_06_06]**

 Each block of length \(L\) takes \(O(L)\) time and \(O(1)\) memory (a constant-size DP table). Over all blocks, this is \(O(D)\) total after sorting and compression. The dominant cost is the initial sort \(O(n \log n)\). The memory footprint is linear to store the compressed arrays and constant working memory per block.


---

**[CHAIN_07]**

Validating correctness, handling edge cases, and summarizing complexity improvements

**[THOUGHT_07_01]**

 Suppose an optimal solution deletes some but not all scrolls of a pitch \(s\). If any remain, the presence of \(s\) still satisfies the presence condition for triples with \(s\). Replacing the partial deletion with keeping all of \(s\) does not worsen feasibility and strictly reduces cost; replacing it with deleting all of \(s\) preserves feasibility wherever zeroing \(s\) was intended. Since constraints depend only on presence, restricting to binary \(x[s]\) is without loss of optimality.


**[THOUGHT_07_02]**

 The only forbidden event is encountering three consecutive keeps, i.e., substring "000" in \(x\). Because this property depends only on triples of adjacent decisions, knowing the last two decisions is sufficient to decide the legality of appending the next one. The DP enumerates all feasible sequences and aggregates minimal costs, ensuring global optimality within a block.


**[THOUGHT_07_03]**

 If two groups of pitches are separated by a gap of at least one integer where no pitch is present, no triple involves elements from both groups. Any deletion decisions in one group do not affect constraints in the other. Therefore, summing independently optimized block answers yields the global minimum.


**[THOUGHT_07_04]**

 For \(L \in \{0, 1, 2\}\), there is no triple, so the DP returns 0 immediately. For large counts, 64-bit integers avoid overflow in cumulative sums, though the final answer never exceeds \(n\). Arbitrary pitch values up to \(10^9\) are handled by sorting and compression rather than direct indexing.


**[THOUGHT_07_05]**

 The brute force \(2^n\) or \(2^D\) methods are infeasible by many orders of magnitude. Greedy local deletions mis-handle overlaps and can be arbitrarily suboptimal. The DP achieves \(O(n \log n)\) time due to sorting and linear passes thereafter, with \(O(D)\) memory for compression and \(O(1)\) working space per block, and is provably optimal.


**[THOUGHT_07_06]**

 Ensure stable counting after sorting, careful formation of consecutive blocks, and correct forbidding of the \((0, 0, 0)\) transition. Validate with the earlier test suite, including no-resonance inputs, single triple cases, overlapping triples, duplicate-heavy scenarios, and extreme sizes. This guards against off-by-one errors in block boundaries and DP initialization.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given \(n\) scrolls, each with an integer pitch \(t_i\). A dangerous resonance occurs if three consecutive pitches \(x, x+1, x+2\) are all present among the remaining scrolls (i.e., at least one scroll of each of these pitches remains). We may discard any subset of scrolls. The goal is to minimize the number of scrolls removed so that no such triple of consecutive pitches can be formed from the remaining set.

Key observations:
- Resonance depends on the presence of pitches, not on how many of each pitch remain. However, multiplicities determine removal cost.
- Partially removing a pitch is not helpful for feasibility: if any scroll of a pitch remains, that pitch can still participate in a triple. Therefore, it is optimal to either delete all scrolls of a pitch or keep all of them.
- Pitches can be partitioned into maximal consecutive blocks. No triple crosses a gap, so each block can be solved independently.

The problem reduces to: for each consecutive block with counts \(w[i]\), choose a binary decision \(x[i] \in \{0,1\}\) where 1 means delete the entire pitch, to minimize \(\sum x[i] \cdot w[i]\) subject to forbidding the substring "000" in \(x\) (i.e., among any three consecutive pitches, at least one is deleted). Blocks of length \(L < 3\) contribute zero cost.

**2. Optimal Approach**

We solve the problem as follows:

1) Sort and compress the pitches:
- Sort array \(t\).
- Compress to arrays \(values\) and \(counts\) holding distinct pitches and their multiplicities.

2) Partition into consecutive blocks:
- Scan \(\text{distinctPitches}\) to form maximal runs where consecutive values differ by 1.
- Each block is independent. Blocks of length less than 3 cannot form a triple and contribute 0.

3) Dynamic programming per block:
- For a block with \(\text{pitchWeights}\), choose binary decisions with cost minimization, forbidding "000".
- Use a DP over the last two decisions:
  - Initialize costs for the first two decisions.
  - For each next index, try appending 0 or 1 and skip the transition if it would form "000".
  - The block answer is the minimum terminal DP value.

4) Sum answers over all blocks:
- Add the optimal costs from each block to obtain the final minimum number of scrolls to delete.

This is optimal due to:
- All-or-nothing per pitch preserves feasibility and can only reduce cost compared to partial deletions.
- Gaps isolate constraints, making blocks independent.
- The DP enumerates all feasible sequences avoiding "000" and finds the minimum weighted cost.

**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>

/**
 * @brief Computes minimal total deletions for a block of consecutive pitches.
 *
 * Given a block of consecutive pitches with multiplicities, chooses for each pitch
 * whether to delete it entirely (1) or keep it (0) to minimize the sum of deleted
 * counts while ensuring no three consecutive kept pitches exist.
 *
 * @param pitchWeights Counts for each pitch in the consecutive block.
 * @return Minimal number of scrolls to delete within this block.
 */
static long long solveBlock(const std::vector<long long>& pitchWeights) {
    int blockLength = static_cast<int>(pitchWeights.size());
    if (blockLength <= 2) {
        return 0;
    }

    const long long kInfinity = std::numeric_limits<long long>::max() / 4;

    long long stateTable[2][2];
    for (int firstDecision = 0; firstDecision <= 1; ++firstDecision) {
        for (int secondDecision = 0; secondDecision <= 1; ++secondDecision) {
            stateTable[firstDecision][secondDecision] = static_cast<long long>(firstDecision) * pitchWeights[0] + static_cast<long long>(secondDecision) * pitchWeights[1];
        }
    }

    for (int pitchIndex = 2; pitchIndex < blockLength; ++pitchIndex) {
        long long newStateTable[2][2];
        newStateTable[0][0] = newStateTable[0][1] = newStateTable[1][0] = newStateTable[1][1] = kInfinity;
        for (int firstDecision = 0; firstDecision <= 1; ++firstDecision) {
            for (int secondDecision = 0; secondDecision <= 1; ++secondDecision) {
                if (stateTable[firstDecision][secondDecision] >= kInfinity) {
                    continue;
                }
                for (int thirdDecision = 0; thirdDecision <= 1; ++thirdDecision) {
                    if (firstDecision == 0 && secondDecision == 0 && thirdDecision == 0) {
                        continue;
                    }
                    long long cost = stateTable[firstDecision][secondDecision] + static_cast<long long>(thirdDecision) * pitchWeights[pitchIndex];
                    if (cost < newStateTable[secondDecision][thirdDecision]) {
                        newStateTable[secondDecision][thirdDecision] = cost;
                    }
                }
            }
        }
        stateTable[0][0] = newStateTable[0][0];
        stateTable[0][1] = newStateTable[0][1];
        stateTable[1][0] = newStateTable[1][0];
        stateTable[1][1] = newStateTable[1][1];
    }

    long long answer = stateTable[0][0];
    answer = std::min(answer, stateTable[0][1]);
    answer = std::min(answer, stateTable[1][0]);
    answer = std::min(answer, stateTable[1][1]);
    return answer;
}

/**
 * @brief Entry point. Reads input, compresses values, partitions into blocks,
 *        runs DP per block, and prints the total minimal deletions.
 *
 * @return Exit status code.
 */
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int numberOfScrolls;
    if (!(std::cin >> numberOfScrolls)) {
        return 0;
    }
    std::vector<long long> scrollPitches(numberOfScrolls);
    for (int scrollIndex = 0; scrollIndex < numberOfScrolls; ++scrollIndex) {
        std::cin >> scrollPitches[scrollIndex];
    }

    std::sort(scrollPitches.begin(), scrollPitches.end());

    std::vector<long long> distinctPitches;
    std::vector<long long> pitchCounts;
    for (int scrollIndex = 0; scrollIndex < numberOfScrolls; ) {
        int endIndex = scrollIndex;
        while (endIndex < numberOfScrolls && scrollPitches[endIndex] == scrollPitches[scrollIndex]) {
            ++endIndex;
        }
        distinctPitches.push_back(scrollPitches[scrollIndex]);
        pitchCounts.push_back(static_cast<long long>(endIndex - scrollIndex));
        scrollIndex = endIndex;
    }

    long long totalAnswer = 0;
    int numberOfDistinctPitches = static_cast<int>(distinctPitches.size());
    int blockStart = 0;
    while (blockStart < numberOfDistinctPitches) {
        int blockEnd = blockStart;
        while (blockEnd + 1 < numberOfDistinctPitches && distinctPitches[blockEnd + 1] == distinctPitches[blockEnd] + 1) {
            ++blockEnd;
        }
        int blockLength = blockEnd - blockStart + 1;
        if (blockLength >= 3) {
            std::vector<long long> blockWeights;
            blockWeights.reserve(blockLength);
            for (int pitchIndex = blockStart; pitchIndex <= blockEnd; ++pitchIndex) {
                blockWeights.push_back(pitchCounts[pitchIndex]);
            }
            totalAnswer += solveBlock(blockWeights);
        }
        blockStart = blockEnd + 1;
    }

    std::cout << totalAnswer << "\n";
    return 0;
}
```

**4. Code Explanation**

- Sorting and compression: We sort the \(\text{scrollPitches}\) array and compress them into \(\text{distinctPitches}\) and \(\text{pitchCounts}\) arrays, capturing each unique pitch and its multiplicity without building a massive array indexed by pitch value.
- Block formation: We scan \(\text{distinctPitches}\) to form maximal consecutive runs using \(\text{blockStart}\) and \(\text{blockEnd}\) indices. No triple crosses a gap, so each block is independent. Blocks with \(\text{blockLength}\) fewer than 3 cannot form a triple and contribute zero deletions.
- Per-block DP: For each block, we build a binary sequence where 1 means deleting the entire pitch and 0 means keeping it. We minimize the weighted sum while forbidding "000" pattern. The \(\text{stateTable}\) stores the last two decisions (\(\text{firstDecision}\), \(\text{secondDecision}\)), and we append the next decision (\(\text{thirdDecision}\)) if it does not produce "000". After processing all positions, the minimal terminal state is the block's answer.
- Aggregation: We sum \(\text{totalAnswer}\) across all blocks to get the global optimal number of deletions.

Illustrative example:
- Input: \(\text{numberOfScrolls} = 5\), \(\text{scrollPitches} = [1, 1, 2, 3, 3]\).
- Compression yields \(\text{distinctPitches} = [1, 2, 3]\) with \(\text{pitchCounts} = [2, 1, 2]\), a single block of \(\text{blockLength} = 3\).
- DP chooses to delete pitch 2 entirely (cost 1), preventing the triple \(\{1, 2, 3\}\).

**5. Time and Space Complexity**

- Sorting: \(O(n \log n)\).
- Compression and block partitioning: \(O(n)\) to scan, \(O(D)\) overall where \(D\) is the \(\text{numberOfDistinctPitches}\).
- DP across all blocks: \(O(D)\) time and \(O(1)\) extra memory per block.
- Overall time: \(O(n \log n)\).
- Space: \(O(D)\) for compressed arrays plus \(O(1)\) working memory per block. The answer fits in 64-bit signed integers and never exceeds \(\text{numberOfScrolls}\).

**6. Conclusion**

By leveraging the fact that only presence matters for resonance while multiplicities determine cost, we reduce the problem to deleting entire pitches within independent consecutive blocks. A constant-state DP per block that forbids the "000" pattern yields the minimum total deletions. The solution is optimal, efficient with \(O(n \log n)\) time due to sorting, and uses linear space in the number of distinct pitches.