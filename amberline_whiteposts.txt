# Metadata

**Category:** - Coding

**GitHub URL:** - https://github.com/NOI-gen/emberline_whistleposts

**Topic:** - Competitive Programming

**Subtopic:** - ["Arrays and Lists", "Searching Algorithms", "Basic Data Structures", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 3, $O(n^2) -> O(n^2) -> O(n log n)$

**Number of Chains:** - 9

---

**[User]**

*Demark the start of the User's activity*

---



**[Prompt]**

**Emberline Whistleposts**

Time Limit: **1 seconds**

Memory Limit: **32 MB**

Along the ancient Emberline railway, whistleposts stand at distinct kilometer markers. When a post i greets the line, the perceived loudness at another post j is directional and capped:
- If j is west of i ($j < i$), the loudness is $ \min(p_i - p_j, L_i) $.
- If j is east of i ($j > i$), the loudness is $ \min(p_j - p_i, R_i) $.

For each post i, compute the total loudness heard by all other posts when only post i greets, that is:
$ \sum_{j \ne i} \begin{cases}
\min(p_i - p_j, L_i), & \text{if } j < i \\
\min(p_j - p_i, R_i), & \text{if } j > i
\end{cases} $.

**Input Format:-**
- The first line contains an integer $n$ ($2 \le n \le 200000$) ‚Äî the number of whistleposts.
- The second line contains $n$ strictly increasing integers $p_1, p_2, \ldots, p_n$ ($-10^9 \le p_i \le 10^9$) ‚Äî the positions of the posts.
- The third line contains $n$ integers $L_1, L_2, \ldots, L_n$ ($0 \le L_i \le 10^9$) ‚Äî the westward (left) damper limits.
- The fourth line contains $n$ integers $R_1, R_2, \ldots, R_n$ ($0 \le R_i \le 10^9$) ‚Äî the eastward (right) damper limits.

**Output Format:-**
- Print $n$ lines.
- The $i$-th line should contain the total loudness emitted by post $i$ toward all other posts.

**Constraints:-**
- Positions are strictly increasing.
- Use 64-bit integers for all sums and results.
**Examples:-**
 - **Input:**
```
3
-1000000000 0 1000000000
1000000000 1000000000 1000000000
1000000000 1000000000 1000000000
```

 - **Output:**
```
2000000000
2000000000
2000000000
```
**Explanation:**    
In the first example, all caps are 1e9 and positions are at ‚àí1e9, 0, 1e9. Each post‚Äôs total is 2e9:

For the middle post (i = 2), both neighbors are at distance 1e9, so 1e9 + 1e9 = 2e9.

For an endpoint (e.g., i = 1), distances are 1e9 (to 0) and 2e9 (to 1e9). The 2e9 distance is capped to 1e9, so 1e9 + 1e9 = 2e9. The same holds for i = 3.

 - **Input:**
```
7
0 2 4 8 16 17 40
0 1 10 0 20 1 5
1 0 10 1 0 20 0
```

 - **Output:**
```
6
1
40
3
50
25
30
```

**Explanation:**

In the second example, left and right contributions use L_i and R_i of the speaking post i, respectively. A post j contributes its exact distance if it lies within the cap range on that side; otherwise its contribution is the cap on that side.

For i = 3 (p = 4, L_3 = R_3 = 10): left gives (4‚àí0) + (4‚àí2) = 4 + 2 = 6; right gives (8‚àí4) + min(16‚àí4,10) + min(17‚àí4,10) + min(40‚àí4,10) = 4 + 10 + 10 + 10 = 34; total 40.

For i = 6 (p = 17, L_6 = 1, R_6 = 20): left has five posts, each contributing min(distance,1) = 1 ‚Üí 5; right has one post at distance 23 capped to 20 ‚Üí total 25.

For i = 1 (p = 0, L_1 = 0, R_1 = 1): only the right side counts; all six distances are ‚â• 1, each contributes 1 ‚Üí total 6.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarifying the objective and problem understanding

**[THOUGHT_01_01]**

We restate the setting: there are $n$ whistleposts positioned at strictly increasing coordinates $p_1 < p_2 < \cdots < p_n$. For each post $i$, its sound toward the west (indices $j < i$) is capped by $L_i$, and toward the east (indices $j > i$) is capped by $R_i$. The loudness from post $i$ perceived at post $j$ is
$$
\min(p_i - p_j, L_i) \quad \text{if } j < i, \quad \min(p_j - p_i, R_i) \quad \text{if } j > i.
$$

**[THOUGHT_01_02]**

The task is to compute, for every post $i$, the total loudness received by all other posts when only $i$ greets. In other words, the output for each $i$ is the sum of the loudness values from $i$ to all other posts.

**[THOUGHT_01_03]**

Because the positions are strictly increasing, distances to the left of a post, $d_{ij} = p_i - p_j$ for $j < i$, grow larger as we move further left. Distances to the right, $d_{ij} = p_j - p_i$ for $j > i$, also grow larger as we move further right. For any cap $L_i$ or $R_i$, the posts within the cap always form a contiguous block next to $i$.

**[THOUGHT_01_04]**

The input also specifies constraints on the number of posts and the ranges of positions and caps. These constraints determine how large the problem instances can be and ensure that the definition of loudness remains consistent across all posts.

**[THOUGHT_01_05]**

The problem input consists of up to $n = 2 \cdot 10^5$ whistleposts, with positions $p_i$ given as strictly increasing integers bounded by $|p_i| \le 10^9$, and with individual loudness caps $L_i, R_i$ each constrained to the range $0 \le L_i, R_i \le 10^9$.  

---

**[CHAIN_02]**

Designing thorough tests and Example analysis

**[THOUGHT_02_01]**

In the first example with three posts at ‚àí1e9, 0, and 1e9, all damping limits are 1e9. Any distance beyond that is clipped, so every interaction contributes exactly 1e9. Each post collects two such contributions, giving totals of 2e9 for all three.

**[THOUGHT_02_02]**

In the second example with seven posts, the limits vary per post. For instance, post 3 (position 4) gathers 6 from the left and 34 from the right, giving 40; post 6 (position 17) is capped heavily to the left (all 1‚Äôs) and clipped on the right (20), giving 25. This variation across posts explains the diverse output sequence 6, 1, 40, 3, 50, 25, 30.

**[THOUGHT_02_03]**

Test asymmetric extremes:
- Mix $L_i = 0$ with large $R_i$ and vice versa across posts.
- Ensure west-only or east-only contributions are handled correctly, particularly at boundary indices $i = 1$ and $i = n$.

**[THOUGHT_02_04]**

Test non-uniform spacing:
- Positions like $p = [-4, 0, 3, 10, 13]$ create uneven distance gaps; pair with varied caps to ensure boundary detection works in the presence of clustered and far-apart neighbors.

**[THOUGHT_02_05]**

Test boundary equalities:
- Construct cases where $p_i - p_j = L_i$ for some $j < i$, and $p_k - p_i = R_i$ for some $k > i$. These check the correct use of lower_bound versus upper_bound and correct inclusion of equal distances within the cap.

**[THOUGHT_02_06]**

Test scalability and overflow control:
- Large $n$ (e.g., $n = 200000$) with worst-case positions and caps to ensure 64-bit accumulation suffices and performance is within limits. For instance, arithmetic bounds on total sums should not exceed $\approx 10^{14}$ to $10^{15}$, well within int64.

**[THOUGHT_02_07]**

Test randomness and cross-validation:
- For small $n$ (e.g., $n \le 2000$), compare the optimized method against the brute force for many random seeds of positions and caps, verifying equality within exact arithmetic.

**[THOUGHT_02_08]**

Test minimality and zeros:
- $n = 2$, with various combinations of zero and nonzero caps. For example:
  - $p = [-3, 4]$, $L = [0, 0]$, $R = [5, 7]$. Confirms that a zero cap nullifies contribution on one side and verifies handling across signs.

**[THOUGHT_02_09]**

Test uniform large caps that dominate all distances:
- $p = [-10^9, 0, 10^9]$, $L = [10^{12}, 10^{12}, 10^{12}]$, $R = [10^{12}, 10^{12}, 10^{12}]$. All contributions should equal the true distances since caps are never reached. This validates distance summation logic.

---

**[CHAIN_03]**

Implementing brute force

**[THOUGHT_03_01]**

Basic idea: for every index $i$, iterate over all $j \ne i$, compute the distance $d = |p_i - p_j|$, apply the directional cap $L_i$ if $j < i$ or $R_i$ if $j > i$, and add $ \min(d, \text{cap}) $ to the running sum for $i$. This directly matches the definition.

**[THOUGHT_03_02]**

Correctness is straightforward because we compute exactly what the problem states without any abstraction or optimization. No special data structures are needed beyond basic loops and 64-bit accumulation.

**[THOUGHT_03_03]**

Time complexity analysis: two nested loops produce $O(n^2)$ operations. With $n = 200000$, this is $4 \cdot 10^{10}$ pair evaluations, which is not tractable in typical time limits. Space complexity is $O(1)$ aside from input storage.

**[THOUGHT_03_04]**

Practical limitations: even with aggressive micro-optimizations, $O(n^2)$ is multiple orders of magnitude too slow. Furthermore, this approach provides no immediate insight into structural properties like contiguity or monotonicity that could reduce work per $i$.

**[THOUGHT_03_05]**

Conclusion: while the brute force is a reliable correctness oracle for small $n$, it fails to meet the performance requirements for the given constraints. We must leverage the sorted nature of positions and contiguous cap regions.

---

**[CHAIN_04]**

Using prefix sums and linearly scanning per index

**[THOUGHT_04_01]**

Initial refinement attempt: precompute prefix sums of positions to speed up distance sums over contiguous ranges. For each $i$, we would still find the cap boundary on each side by scanning outward from $i$, then use prefix sums to compute the exact-distance totals in $O(1)$ once the boundary is known.

**[THOUGHT_04_02]**

Why this underperforms: although prefix sums accelerate the sum calculation itself, discovering the boundary by walking from $i-1$ leftward until $p_i - p_j \le L_i$ fails in worst-case scenarios. If many $L_i$ are small across all $i$, each scan can take $O(i)$, leading still to $O(n^2)$ total runtime.

**[THOUGHT_04_03]**

Even attempting to reuse scan positions within an iteration of $i$ is not sufficient. When moving to the right side, a similar outward scan to locate where $p_j - p_i \le R_i$ also degenerates to $O(n)$ per $i$ in pathological configurations, such as caps that place the boundary at one end for most $i$.

**[THOUGHT_04_04]**

Thus, combining both sides, the total work can reach quadratic scale: each post potentially scanning across nearly all others. This results in $O(n^2)$ operations in the worst case and it require $O(n)$ space.

**[THOUGHT_04_05]**

Conclusion: prefix sums help with summation but do not on their own fix boundary detection. We need an $O(\log n)$ method per index to locate the split points, capitalizing on the sorted positions and monotonic distances.

---

**[CHAIN_05]**

Introducing binary searches over cap boundaries and combining with prefix sums

**[THOUGHT_05_01]**

Rationale for binary search: to the west of $i$, distances $p_i - p_j$ strictly increase as $j$ decreases. The set of indices where $p_i - p_j \le L_i$ is a contiguous suffix of $[0, i-1]$. Thus, the first index $L$ satisfying $p_L \ge p_i - L_i$ can be found via lower_bound in $O(\log n)$. Symmetrically to the east, the set where $p_j - p_i \le R_i$ is a contiguous prefix of $[i+1, n-1]$, and the first index $R$ with $p_R > p_i + R_i$ can be found via upper_bound in $O(\log n)$.

**[THOUGHT_05_02]**

Prefix sums setup: define $S[t] = \sum_{u=0}^{t-1} p_u$ with $S[0] = 0$. Then for any contiguous block $[l, r]$, the sum $\sum_{u=l}^{r} p_u = S[r+1] - S[l]$. This lets us express sums of distances to a fixed $p_i$ as linear combinations of $p_i$ and a contiguous sum of positions.

**[THOUGHT_05_03]**

West side computation details:
- Let $L$ be the first index such that $p_L \ge p_i - L_i$ via lower_bound.
- In-cap indices are $[L, i-1]$, with count $c_w = i - L$.
- Exact-distance sum to in-cap posts: $ \sum_{j=L}^{i-1} (p_i - p_j) = c_w \cdot p_i - (S[i] - S[L]) $.
- Out-of-cap indices are $[0, L-1]$, count $o_w = L$, each contributes $L_i$: total $o_w \cdot L_i$.

**[THOUGHT_05_04]**

East side computation details:
- Let $R$ be the first index such that $p_R > p_i + R_i$ via upper_bound.
- In-cap indices are $[i+1, R-1]$, with count $c_e = R - i - 1$.
- Exact-distance sum to in-cap posts: $ \sum_{j=i+1}^{R-1} (p_j - p_i) = (S[R] - S[i+1]) - c_e \cdot p_i $.
- Out-of-cap indices are $[R, n-1]$, count $o_e = (n - 1 - i) - c_e$, each contributes $R_i$: total $o_e \cdot R_i$.

**[THOUGHT_05_05]**

Total for index $i$ is the sum of the four parts:
$ \text{total}_i = \big(c_w \cdot p_i - (S[i] - S[L])\big) + (o_w \cdot L_i) + \big((S[R] - S[i+1]) - c_e \cdot p_i\big) + (o_e \cdot R_i) $.
Each term is computable in $O(1)$ after two binary searches and uses only prefix sums and counts.

**[THOUGHT_05_06]**

Complexity and correctness:
- For each $i$, two binary searches contribute $O(\log n)$, and arithmetic is $O(1)$, so the total runtime is $O(n \log n)$.
- Memory is $O(n)$ for positions, caps, and the prefix sum array.

Time and space summary:

$$
\text{Time complexity: } O(n \log n) \quad (\text{two binary searches per index})
$$
$$
\text{Space complexity: } O(n) \quad (\text{positions, caps, prefix sum array})
$$

This confirms the method is efficient for $n \le 2 \cdot 10^5$ and safely handles 64-bit sums.

**[THOUGHT_05_07]**

Boundary handling:
- West uses lower_bound on $p_i - L_i$, so indices with $p_j \ge p_i - L_i$ are treated as in-cap, correctly including the equality case $p_i - p_j = L_i$.
- East uses upper_bound on $p_i + R_i$, so indices with $p_j \le p_i + R_i$ are in-cap, again including equality. This resolves off-by-one concerns cleanly.

---

**[CHAIN_06]**

Exploring a global two-pointer sweep optimization

**[THOUGHT_06_01]**

Attempting to optimize further: as $ùëñ$
increases from left to right, it is natural to try maintaining two global pointers for the west and east boundaries.

**[THOUGHT_06_02]**

Why monotonicity fails: the boundary for the west depends on $p_i - L_i$, and for the east on $p_i + R_i$.  
While $p_i$ increases with $i$, the caps $L_i$ and $R_i$ are arbitrary per-index values.  
This means the thresholds can move both left and right in the coordinate sense, causing corresponding boundary indices to move non-monotonically across $i$.

**[THOUGHT_06_03]**

Concrete counterexample:  
- Suppose $p = [0, 10, 20]$, $L = [0, 100, 0]$.  
- For $i = 1$ (position 10), the west threshold is $p_1 - L_1 = -90$, so all west posts are in-cap.  
- For $i = 2$ (position 20), the west threshold is $p_2 - L_2 = 20$, so none are in-cap.  
The west boundary jumps left-to-right drastically with no monotonic trend that can be exploited in a single sweep.

**[THOUGHT_06_04]**

Even sorting by thresholds like $p_i - L_i$ or $p_i + R_i$ does not decouple the computation.  
The sums depend on the center $p_i$ multiplicatively through terms such as $c_w \cdot p_i$ and $c_e \cdot p_i$,  
making it difficult to aggregate contributions for multiple $i$ simultaneously without recomputing the boundary determination for each $i$.  
Final time complexity is $\mathcal{O}(n \log n)$.

**[THOUGHT_06_05]**

Conclusion: while two-pointer methods are powerful for problems with globally monotone windows, the per-index cap variability here breaks the required monotonicity.

---

**[CHAIN_07]**

Verifying summation identities and resolving off-by-one indexing

**[THOUGHT_07_01]**

West-side identity derivation: for in-cap indices $j \in [L, i-1]$,
$ \sum_{j=L}^{i-1} (p_i - p_j) = \sum_{j=L}^{i-1} p_i - \sum_{j=L}^{i-1} p_j = (i - L) \cdot p_i - (S[i] - S[L]) $.
This relies on the contiguous nature of indices and the definition of the prefix sums.

**[THOUGHT_07_02]**

East-side identity derivation: for in-cap indices $j \in [i+1, R-1]$,
$ \sum_{j=i+1}^{R-1} (p_j - p_i) = \sum_{j=i+1}^{R-1} p_j - \sum_{j=i+1}^{R-1} p_i = (S[R] - S[i+1]) - (R - i - 1) \cdot p_i $.
The inclusive-exclusive bounds match the upper_bound convention for $R$.

**[THOUGHT_07_03]**

Edge cases:
- If $L = i$, then $c_w = 0$ and the in-cap west sum is zero; all west posts are out-of-cap.
- If $L = 0$, then $o_w = 0$; no west posts are out-of-cap.
- If $R = i+1$, then $c_e = 0$ and the in-cap east sum is zero.
- If $R = n$, then $o_e = 0$ and there are no out-of-cap posts on the east. These ensure counts never go negative.

**[THOUGHT_07_04]**

Equality at thresholds:
- West uses $p_j \ge p_i - L_i$ as in-cap. When $p_j = p_i - L_i$, the distance equals $L_i$, which correctly goes into the in-cap exact-distance sum.
- East uses $p_j \le p_i + R_i$ as in-cap. When $p_j = p_i + R_i$, the distance equals $R_i$, also in-cap. This eliminates double-counting or missing boundary elements.

**[THOUGHT_07_05]**

Overflow safety:
- Each component like $c_w \cdot p_i$ is bounded by $n \cdot 10^9 \approx 2 \cdot 10^{14}$, and prefix sums of positions are bounded similarly. Summing a constant number of such terms yields results within approximately $10^{15}$, well within 64-bit signed integer range.

---

**[CHAIN_08]**

Implementing and validating the final method with clean code practices

**[THOUGHT_08_01]**

Data representation choices:
- Use std::vector<long long> for positions and caps.
- Build a prefix sum array $S$ of size $n + 1$ with $S[0] = 0$ and $S[i+1] = S[i] + p[i]$.
- Ensure all arithmetic uses 64-bit to avoid overflow.

**[THOUGHT_08_02]**

Binary searches:
- For west, compute $L = \text{lower\_bound}(p.begin(), p.end(), p[i] - L_i) - p.begin()$.
- For east, compute $R = \text{upper\_bound}(p.begin(), p.end(), p[i] + R_i) - p.begin()$.
This exactly encodes the inclusive boundary on the left and exclusive boundary on the right derived earlier.

**[THOUGHT_08_03]**

Testing strategy:
- Cross-validate against the brute-force solution for small $n$ and many random seeds.
- Include targeted unit tests for zero caps, equality thresholds, and extreme positions.
- For performance, test with $n = 200000$, evenly spaced positions, and random caps to ensure the $O(n \log n)$ implementation runs efficiently.

**[THOUGHT_08_04]**

A small, focused code excerpt demonstrates how a single index $i$ is processed. It adheres to naming conventions, includes, indentation, and comment style. The full program would loop over all $i$ and print the result per line.

**[THOUGHT_08_05]**

The implementation for computing total loudness per post should be placed in the **solution section**, not within reasoning.  
Conceptually, it performs the following:

1. For each post $i$, determine the west and east boundaries using binary search on the sorted positions array.  
2. Use prefix sums to compute cumulative contributions on each side in $\mathcal{O}(\log n)$.  
3. Combine the west and east contributions to obtain the total loudness for post $i$.  

This logical outline corresponds to an efficient implementation in $\mathcal{O}(n \log n)$ overall,  
avoiding any need to revisit or overlap boundary computations across different $i$.

---

**[CHAIN_09]**

Reflecting on alternatives and confirming the chosen method‚Äôs suitability

**[THOUGHT_09_01]**

Alternative data structures like segment trees or Fenwick trees were considered for range sum queries. However, because the summand is a linear function of positions and counts over contiguous ranges adjacent to index $i$, a simple prefix sum suffices. There is no need for dynamic updates or arbitrary range queries.

**[THOUGHT_09_02]**

Sweep-line or divide-and-conquer approaches do not naturally fit because contributions couple to $p_i$ for each $i$ in a way that resists aggregation across indices without re-evaluating cap-dependent boundaries. This coupling undermines attempts to amortize work across $i$ beyond binary searches.

**[THOUGHT_09_03]**

Preprocessing precomputed nearest indices at certain distance thresholds would either be too coarse (losing exactness for specific $L_i$, $R_i$) or too large (requiring per-index tables), giving no scalable advantage over on-demand binary searches.

**[THOUGHT_09_04]**

The final method thrives precisely because the positions are sorted and distances are monotonic with index. It strikes the right balance: $O(n \log n)$ is efficient within the constraints, simple to implement correctly, and robust against adversarial inputs.

**[THOUGHT_09_05]**

Given these considerations, the prefix sums plus binary searches approach is the most suitable: it is fast, memory-light, and straightforward to verify through algebraic identities and targeted tests.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given $n$ whistleposts placed at strictly increasing coordinates $p_1 < p_2 < \cdots < p_n$. Each post $i$ has two directional caps: a westward cap $L_i$ and an eastward cap $R_i$. When post $i$ "greets," the loudness perceived at another post $j$ depends on direction:
- For $j < i$ (west of $i$): the contribution is $ \min(p_i - p_j, L_i) $.
- For $j > i$ (east of $i$): the contribution is $ \min(p_j - p_i, R_i) $.

For each post $i$, we must compute the total loudness heard by all other posts:
$ \text{total}_i = \sum_{j < i} \min(p_i - p_j, L_i) + \sum_{j > i} \min(p_j - p_i, R_i) $.

Key observations:
- Positions are sorted, so distances from $i$ grow monotonically as we move away from $i$.
- For a fixed cap $L_i$ or $R_i$, the indices that fall within the cap form contiguous ranges adjacent to $i$.
- Distances over contiguous ranges can be summed efficiently using prefix sums of positions.
- We must use 64-bit integers for correctness due to large values and sums.


**2. Optimal Approach**

We exploit contiguity and sorted positions to obtain $O(n \log n)$ time:
1. Precompute prefix sums of positions:
   - Let $S[t]$ be the sum of positions $p_0 + p_1 + \cdots + p_{t-1}$ with $S[0] = 0$. Then the sum over a range $[l, r]$ is $S[r+1] - S[l]$.

2. For each index $i$, split the computation into west and east parts:
   - West (indices $j < i$):
     - Find the first index $L$ with $p_L \ge p_i - L_i$ using lower_bound. The in-cap west indices are $[L, i-1]$, and the out-of-cap west indices are $[0, L-1]$.
     - Let $c_w = i - L$. Exact-distance sum to in-cap posts is $c_w \cdot p_i - (S[i] - S[L])$.
     - Out-of-cap posts contribute $L \cdot L_i$.
   - East (indices $j > i$):
     - Find the first index $R$ with $p_R > p_i + R_i$ using upper_bound. The in-cap east indices are $[i+1, R-1]$, and the out-of-cap east indices are $[R, n-1]$.
     - Let $c_e = R - i - 1$. Exact-distance sum to in-cap posts is $(S[R] - S[i+1]) - c_e \cdot p_i$.
     - Out-of-cap posts contribute $((n - 1 - i) - c_e) \cdot R_i$.

3. Sum the four components to get $\text{total}_i$.

Why this works:
- lower_bound and upper_bound locate cap boundaries in $O(\log n)$ due to sorted positions.
- Prefix sums convert a sum of distances over a contiguous block into $O(1)$.
- Equality at thresholds is handled correctly: west uses lower_bound (include equality), east uses upper_bound (include equality).


**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

/**
 * @brief Computes total loudness emitted by a single whistlepost toward all others.
 *
 * @param whistlePositions Strictly increasing positions of whistleposts.
 * @param westCaps Westward loudness caps for each post.
 * @param eastCaps Eastward loudness caps for each post.
 * @param positionPrefixSum Prefix sums of positions: positionPrefixSum[t] = sum of whistlePositions[0..t-1].
 * @param postIndex The index of the post to evaluate.
 * @return Total loudness for the given post as a 64-bit integer.
 */
long long computeTotalLoudnessForPost(
    const std::vector<long long>& whistlePositions,
    const std::vector<long long>& westCaps,
    const std::vector<long long>& eastCaps,
    const std::vector<long long>& positionPrefixSum,
    int postIndex
) {
    const int numPosts = static_cast<int>(whistlePositions.size());
    const long long currentPosition = whistlePositions[postIndex];
    const long long currWestCap = westCaps[postIndex];
    const long long currEastCap = eastCaps[postIndex];

    // West side: [0..postIndex-1]
    int westBoundaryIndex = static_cast<int>(
        std::lower_bound(whistlePositions.begin(), whistlePositions.end(), currentPosition - currWestCap)
        - whistlePositions.begin()
    );
    long long inCapWestCount = postIndex - westBoundaryIndex;
    long long sumInCapWest = inCapWestCount * currentPosition - (positionPrefixSum[postIndex] - positionPrefixSum[westBoundaryIndex]);
    long long outCapWestCount = westBoundaryIndex;
    long long totalWestLoudness = sumInCapWest + outCapWestCount * currWestCap;

    // East side: [postIndex+1..numPosts-1]
    int eastBoundaryIndex = static_cast<int>(
        std::upper_bound(whistlePositions.begin(), whistlePositions.end(), currentPosition + currEastCap)
        - whistlePositions.begin()
    );
    long long inCapEastCount = eastBoundaryIndex - postIndex - 1;
    long long sumInCapEast = (positionPrefixSum[eastBoundaryIndex] - positionPrefixSum[postIndex + 1]) - inCapEastCount * currentPosition;
    long long outCapEastCount = (numPosts - 1 - postIndex) - inCapEastCount;
    long long totalEastLoudness = sumInCapEast + outCapEastCount * currEastCap;

    return totalWestLoudness + totalEastLoudness;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int numPosts;
    if (!(std::cin >> numPosts)) {
        return 0;
    }

    std::vector<long long> whistlePositions(numPosts), westCaps(numPosts), eastCaps(numPosts);
    for (int postIdx = 0; postIdx < numPosts; ++postIdx) {
        std::cin >> whistlePositions[postIdx];
    }
    for (int postIdx = 0; postIdx < numPosts; ++postIdx) {
        std::cin >> westCaps[postIdx];
    }
    for (int postIdx = 0; postIdx < numPosts; ++postIdx) {
        std::cin >> eastCaps[postIdx];
    }

    // Build prefix sums: positionPrefixSum[t] = sum of whistlePositions[0..t-1], positionPrefixSum[0] = 0
    std::vector<long long> positionPrefixSum(numPosts + 1, 0);
    for (int sumIdx = 0; sumIdx < numPosts; ++sumIdx) {
        positionPrefixSum[sumIdx + 1] = positionPrefixSum[sumIdx] + whistlePositions[sumIdx];
    }

    for (int postIdx = 0; postIdx < numPosts; ++postIdx) {
        long long totalLoudness = computeTotalLoudnessForPost(
            whistlePositions, westCaps, eastCaps, positionPrefixSum, postIdx
        );
        std::cout << totalLoudness << "\n";
    }

    return 0;
}

```

**4. Code Explanation**

- We precompute prefix sums of positions to allow constant-time range sum queries of positions.
- For each index $i$, we:
  - Use lower_bound on $p_i - L_i$ to find the first index $L$ on the west that is within the cap. Indices $[L, i-1]$ are in-cap and contribute exact distances; indices $[0, L-1]$ are out-of-cap and each contribute $L_i$.
  - Use upper_bound on $p_i + R_i$ to find the first index $R$ on the east that exceeds the cap. Indices $[i+1, R-1]$ are in-cap and contribute exact distances; indices $[R, n-1]$ are out-of-cap and each contribute $R_i$.
- Exact-distance sums are computed via prefix sums:
  - West in-cap: $ (i - L) \cdot p_i - (S[i] - S[L]) $.
  - East in-cap: $ (S[R] - S[i+1]) - (R - i - 1) \cdot p_i $.
- We add the out-of-cap contributions and print the total for each $i$.
- Edge cases like zero caps and threshold equalities are naturally handled by the chosen bounds (lower_bound includes equality on the west, upper_bound includes equality on the east).

Example walkthrough (brief):
- Suppose $p = [0, 5, 9, 11]$, $L = [2, 6, 0, 100]$, $R = [3, 1, 10, 0]$.
- For $i = 0$ at $p_0 = 0$: west has no elements. East uses upper_bound with $0 + 3 = 3$, so no in-cap east indices. Out-of-cap east are all posts and each contributes $3$, total $3 \cdot 3 = 9$. This matches the sample output.

**5. Time and Space Complexity**

- Time complexity:
  - Building prefix sums: $O(n)$.
  - For each index $i$, two binary searches and $O(1)$ arithmetic: $O(\log n)$ per $i$.
  - Total: $O(n \log n)$.
- Space complexity:
  - Arrays for positions, caps, and prefix sums: $O(n)$.

**6. Conclusion**

By leveraging sorted positions, binary searches to find cap boundaries, and prefix sums to aggregate distances over contiguous ranges, we compute each post‚Äôs total loudness in $O(\log n)$ time per post. The method is simple, robust to edge cases, and efficient for $n \le 200000$, while adhering to 64-bit arithmetic requirements for correctness.