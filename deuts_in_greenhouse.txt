# Metadata

**Category:** - Coding

**GitHub URL:** - https://github.com/NOI-gen/duets_in_the_greenhouse

**Topic:** - Competitive Programming

**Subtopic:** - ["Sorting Algorithms", "Hash Tables", "Arrays and Lists", "Basic Data Structures", "Control Structures and Loops", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 4, O(M^2) -> O(K log K) -> O(∑K_t) -> O(∑K_t log K_t)

**Number of Chains:** - 10

---

**[User]**

*Demark the start of the User's activity*

---

**Duets in the Greenhouse**

**Time Limit:** **1 second**

**Memory Limit:** **32 MB**

Within the labyrinthine enclave of a bioluminescent conservatory, a cohort of $N$ ethereal pollinators, each adorned with a cryptic sigil, is scrutinized across $T$ temporal shards.
In each shard, these enigmatic entities either retreat into a state of mute resonance (denoted by the null cipher, $0$) or project a spectral frequency code—a positive integer woven into the aether.

Each non-null frequency code manifests as a singular *canticle*, a harmonic phenomenon bound by the following arcane edicts:

* A canticle persists through an unbroken continuum of temporal shards; its essence may never be fractured by silence or resurgence.
* Its chorus is sustained by a fixed coterie of either one (a *soliloquy*) or two (a *dyadic hymn*) pollinators, their sigils eternally bound to the canticle’s duration.
* No canticle may be intoned by a triad or greater assembly in any shard, lest the harmonic fabric unravel.

Your task is to divine whether the conservatory's chronicle aligns with these mystic tenets.
If the chronicle is sound, unveil the count of *dyadic hymns* (codes chanted by exactly two pollinators).
If the chronicle is tainted by discord, proclaim the verdict of $-1$.

---

### **Input Format:**

* The first line bears two integers $N$ and $T$, the number of sigil-bearing pollinators and temporal shards, respectively.
* The next $T$ lines each encode $N$ integers, representing the conservatory's chronicle:

  * For shard $t$ and pollinator $i$, a value of $0$ signifies mute resonance, while a positive integer denotes a frequency code projected into the aether.

---

### **Output Format:**

* Emit a solitary integer — the tally of *dyadic hymns* if the chronicle is harmonious; otherwise, inscribe $-1$.

---

### **Constraints:**

* $(1 \le N, T)$
* $(N \cdot T \le 2 \cdot 10^6)$
* $(0 \le \text{code} \le 10^9)$
* In any single shard, no frequency code may be intoned by more than two pollinators; otherwise, the chronicle is deemed dissonant.

---

### **Examples:**

**Input:**

```
2 5
9 9
9 9
0 0
0 0
9 9
```

**Output:**

```
-1
```

---

**Input:**

```
1 3
1000000000
1000000000
1000000000
```

**Output:**

```
0
```

---

### **Exegesis of Examples:**

In the first chronicle, two pollinators weave frequency code $9$ through shards $1$–$2$, then lapse into silence across shards $3$–$4$, only to resurrect the same code $9$ in shard $5$.
The mystic edict demands that a canticle's essence endure through a single, unbroken continuum; its resurgence after silence rends the harmonic fabric, rendering the chronicle dissonant, thus yielding $-1$.

In the second chronicle, a lone pollinator intones frequency code $10^9$ across all three shards, forming a single *soliloquy* (a canticle with one emitter).
The chronicle is harmonious, yet no *dyadic hymns* (codes with exactly two emitters) exist, so the tally is $0$.

---

### **Additional Arcana:**

* The null cipher (0) signifies mute resonance and does not kindle a canticle.
* Each positive frequency code corresponds to exactly one canticle, defined by:

  * A singular, unbroken continuum of shards.
  * A fixed coterie of one (*soliloquy*) or two (*dyadic hymn*) pollinators.
  * Never more than two emitters in any shard; otherwise the chronicle is invalid.
* For a *dyadic hymn*, both pollinators must intone the code in every shard of the canticle’s continuum; the absence of either in any shard disrupts the harmony, invalidating the chronicle.
* The output counts distinct *dyadic hymn* codes, not the shards where dual emissions occur.
* A single pair of pollinators may weave multiple *dyadic hymns* using distinct codes at different continua, each counted once.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

This section clarifies the rules and the goal of the verification task.

**[THOUGHT_01_01]**

We are given a grid of size $T \times N$ where $T$ is the number of frames and $N$ is the number of pollinators. Each cell holds a non-negative integer: $0$ means silent, and a positive integer is a frequency code. We must verify if these observations could arise from songs where each positive code corresponds to exactly one contiguous activity interval and a fixed emitter set of size either $1$ (solo) or $2$ (duet).

**[THOUGHT_01_02]**

The constraints to enforce are threefold: per-frame limit, fixed participants, and contiguity. Per-frame limit: in any frame, a given code may appear at most twice. Fixed participants: throughout the entire active interval of a code, the exact set of emitters is constant and has size \(1\) or \(2\). Contiguity: the frames in which a given code appears must form a single contiguous interval; once a code disappears, it must never reappear later.

**[THOUGHT_01_03]**

The output is either \(-1\) if any rule is violated, or the count of distinct codes that are duets (i.e., codes whose emitter set has size exactly \(2\)). This reduces the task to verifying all codes and then counting those with participant-set size \(2\).

**[THOUGHT_01_04]**

The input bounds are $1 \le N, T$ with $N \cdot T \le 2 \cdot 10^6$. The raw data size is large but still manageable for linear or near-linear solutions, while any algorithm with superlinear passes in the total input $M = N \cdot T$ can be risky.

---

**[CHAIN_02]**

This section designs a comprehensive test plan to cover all rules and edge cases thoroughly.

**[THOUGHT_02_01]**

Valid basic cases:
- All zeros across all frames should yield \(0\).
- A single solo contiguous over multiple frames should yield \(0\).
- A single duet appearing in one or more consecutive frames should yield \(1\).

**[THOUGHT_02_02]**

Per-frame violation cases:

A frame where a code appears three times must be rejected. For example, $N = 3, T = 1$ with entries $9, 9, 9$ yields $-1$.
A frame with multiple different codes is valid as long as no single code exceeds two simultaneous emitters.

**[THOUGHT_02_03]**

Fixed-participants violation cases:
- A code used by one pollinator in some frame and by a different pollinator in a later frame violates fixed participants.
- A code used by a duet in one frame and by only one of them (or by a different pair) in another frame violates fixed participants.

**[THOUGHT_02_04]**

Contiguity violation cases:
- A code appears, disappears for one or more frames, and then reappears; this must be rejected for non-contiguity.
- A code that appears only in non-adjacent frames but with identical participants still violates contiguity and must be rejected.

**[THOUGHT_02_05]**

Edge and boundary cases:

$N = 1$ with various $T$, including alternating $0$ and a positive code to test contiguity.
$T = 1$ with many codes, ensuring per-frame limit detection.
Large code values near $10^9$, ensuring type safety and hashing robustness.
Many distinct codes each appearing once to stress the global state size.

---

**[CHAIN_03]**

This section implements brute force and identifies its infeasibility.

**[THOUGHT_03_01]**

First naive thought: for every distinct positive code, scan the entire grid to collect its occurrences, then verify all three rules by checking counts per frame, comparing participant sets across frames, and verifying that the set of frames with appearances is contiguous. This implies building, per code, a presence list across all \(T\) frames and counting occurrences per frame by scanning all \(N\) columns.

**[THOUGHT_03_02]**

Complexity analysis: Let $M = N \cdot T$. If we traverse the entire grid for each distinct code $D$, we face $O(D \cdot M)$ time in the worst case. Since $D$ can be $O(M)$ when many codes are unique, this degenerates to $O(M^2)$, which is prohibitive for $M \le 2 \cdot 10^6$.

**[THOUGHT_03_03]**

Memory implications: While the naive approach can stream without extra storage by re-scanning, the cost is in time, not memory. Attempting to reduce time by caching per-frame code counts for reuse would still entail $O(M)$ space and complex coordination across codes.

**[THOUGHT_03_04]**

Conclusion and failure reason: This brute force approach fails due to time complexity. Repeatedly scanning the entire grid for each code is not viable under the given constraints, prompting a different strategy.


---

**[CHAIN_04]**

This section aggregates all occurrences per code and recognizes memory and overhead issues.

**[THOUGHT_04_01]**

Second attempt: perform a single pass over the grid to build a dictionary mapping code to a vector of occurrences $(t, i)$. After reading all data, sort each vector by $(t, i)$, then validate per code by scanning its timeline: check at most two occurrences per frame, fixed participants over consecutive frames, and contiguity by detecting gaps in $t$.

**[THOUGHT_04_02]**

Complexity analysis: The total number of stored pairs is $K$, the count of non-zero cells, with $K \le M$. Sorting all vectors across all codes is bounded by sorting $K$ items overall, i.e., $O(K \log K)$. The validation pass per code is linear in the size of each vector, summing to $O(K)$. Time-wise, this can meet the limits.

**[THOUGHT_04_03]**

Space and overhead concerns: The number of distinct codes can be as high as \(K\). Holding an unordered map with up to \(K\) independently allocated vectors incurs significant per-bucket and per-vector overhead, allocator fragmentation, and poor cache locality. In worst cases with \(K \approx 2 \cdot 10^6\), overhead alone can become large, risking memory pressure and performance instability.

**[THOUGHT_04_04]**

Maintainability and simplicity: Per-code post-processing complicates bookkeeping for the per-frame limit and encourages multiple small sorts. We are motivated to seek a streaming per-frame method that uses only transient per-frame buffers and a single global state per code, thus improving locality and lowering allocator churn.

**[THOUGHT_04_05]**

Conclusion and rejection rationale: Although asymptotically acceptable, this design is fragile on memory and constants at the scale of \(2 \cdot 10^6\) entries. We prefer a design that streams frames and avoids storing all occurrences for all codes at once.


---

**[CHAIN_05]**

This section tracks participants without contiguity enforcement and discovers correctness gaps.

**[THOUGHT_05_01]**

Third attempt: process input frame by frame. For each frame, compute the set of emitters per code and ensure no code appears more than twice in that frame. Maintain a global dictionary code to fixed participants. On each appearance, require the participants to match the recorded set; reject if they differ. This enforces the per-frame limit and fixed participants.

**[THOUGHT_05_02]**

Missed constraint: contiguity is not enforced here. If a code appears in frame $t$, vanishes in frame $t+1$, and reappears in frame $t+2$ with the same participants, this approach would accept it, but the rules require a single continuous interval of activity.

**[THOUGHT_05_03]**

Frame 1: code $5$ appears at index $1$.
Frame 2: no code $5$.
Frame 3: code $5$ appears again at index $1$. The participant set is consistent, but there is a gap, so it must be rejected; this attempt would wrongly accept it.

**[THOUGHT_05_04]**

Complexity assessment and conclusion: With a per-frame hash aggregation, time is $O\!\left(\sum_t K_t\right)$ for building per-frame maps plus hash operations, and space is $O(D)$ globally plus $O(K_t)$ transiently. Although efficient, it fails correctness due to not tracking temporal contiguity, so we must augment it with time-aware state.

---

**[CHAIN_06]**

This section enforces contiguity with last-seen tracking while streaming per frame.

**[THOUGHT_06_01]**

Final approach overview: process frames sequentially and, within each frame, group equal codes to determine their participant sets and check the per-frame limit of at most two. Maintain a global mapping code to a record containing its participants and the last frame it appeared in. This enables verification of both fixed participants and contiguity.

**[THOUGHT_06_02]**

Within-frame grouping: For each frame $t$, form a temporary list of pairs $(\text{code}, i)$ for all non-zero entries. Sort this list by code so that equal codes are adjacent. Sweep the sorted list to form groups for each code. If a group size exceeds two, reject. Otherwise, convert the group to a normalized participant set: either $(a, -1)$ for solos or $(\min(a,b), \max(a,b))$ for duets.

**[THOUGHT_06_03]**

Global state verification: For a new code, insert its participant set and set last-seen frame to \(t\). For a previously seen code, require that the last-seen frame equals \(t - 1\) (to enforce contiguity) and that the participant set matches exactly (to enforce fixed emitters). If either check fails, reject. Then update last-seen to \(t\).

**[THOUGHT_06_04]**

Counting duets: After processing all frames without a violation, scan the global map and count codes whose participant record indicates two distinct indices, i.e., the stored second participant is not \(-1\). Output this count as the number of duets.

**[THOUGHT_06_05]**

Complexity and practicality: Let $K_t$ be the number of non-zero entries in frame $t$. Sorting costs $\sum_t O(K_t \log K_t)$, bounded by $O(M \log M)$ in the worst case where $M = N \cdot T$. The global map size is bounded by the number of distinct positive codes $D \le K = \sum_t K_t \le M$. This comfortably meets the constraints and streams the data with small transient memory.

---

**[CHAIN_07]**

This section refines implementation details to reduce constants and improve robustness.

**[THOUGHT_07_01]**

Choosing grouping strategy: Sorting the per-frame list $(\text{code}, i)$ avoids building a hash map per frame and yields excellent cache locality with a single linear sweep to form groups. An alternative of using a per-frame unordered map for counts is $O(K_t)$ amortized, but relies on more hash operations, more allocations, and more branches; the sort-based grouping uses contiguous memory and simple comparisons.

**[THOUGHT_07_02]**

Normalizing participants: Always store duet participants as $(\min(i,j), \max(i,j))$. This normalization guarantees consistent comparisons across frames and prevents false mismatches due to ordering.

**[THOUGHT_07_03]**

Reserving capacities: Reserve $N$ for the per-frame buffer and a large capacity for the global unordered map based on expected distinct codes to reduce rehashing. This improves constant factors with large datasets near the $2 \cdot 10^6$ limit.

**[THOUGHT_07_04]**

Using appropriate types: Read codes as 64-bit integers to accommodate up to \(10^9\) safely and future-proof against larger values. Store indices as 32-bit integers since \(N \le 2 \cdot 10^6\) implies 32-bit is sufficient. Use signed sentinel \(-1\) to represent solos.

**[THOUGHT_07_05]**

Adhering to clean structure definitions: A concise record per code improves clarity. For example:
```cpp
/**
 * @brief State stored for each code.
 *
 * @param a First participant index (1-based).
 * @param b Second participant index, or -1 if solo.
 * @param last Last frame index in which this code appeared (0-based).
 */
struct Node {
    int a;
    int b;
    int last;
};
```
This struct makes comparisons and updates straightforward, and the sentinel \(-1\) for solos simplifies duet counting.

**[THOUGHT_07_06]**

I/O and early exits: Stream input frame by frame and exit immediately upon detecting a violation to avoid unnecessary work. Disable synchronization with stdio and untie streams for speed, which is standard in large-input problems.


---

**[CHAIN_08]**

This section validates invariants and argues correctness systematically.

**[THOUGHT_08_01]**

Per-frame limit enforcement: By grouping identical codes within a frame and rejecting any group of size greater than two, we ensure that no code is ever emitted by three or more pollinators in the same frame. This directly enforces the per-frame rule.

**[THOUGHT_08_02]**

Fixed participants enforcement: For each code, the first time we see it we record its participant set. Thereafter, we require exact equality of the set whenever the code appears. Since we normalize duet order and store solos distinctly with $-1$, any change in participants or in solo/duet status is detected and rejected.Per-frame limit enforcement: By grouping identical codes within a frame and rejecting any group of size greater than two, we ensure that no code is ever emitted by three or more pollinators in the same frame. This directly enforces the per-frame rule.

**[THOUGHT_08_03]**

Contiguity enforcement: The last-seen check requires that any subsequent appearance occurs in the immediate next frame, $t = \text{last} + 1$. If a code disappears for at least one frame, the equality fails and we reject reappearance. This enforces that all appearances form one continuous interval.

**[THOUGHT_08_04]**

No false rejections: If a code is seen consecutively across some interval $[L, R]$ with a fixed participant set and never appears outside that interval, the algorithm admits it because each step satisfies both the fixed-participants and last-seen adjacency checks. Codes appearing only once are also correctly handled, as their insertion does not require adjacency checks.

---

**[CHAIN_09]**

This section analyses time and space complexity across approaches to justify the final choice.

**[THOUGHT_09_01]**

Brute force scan per code: Time $O(D \cdot M)$ with $D \le M$ yields $O(M^2)$; space $O(1)$ extra besides input. This is infeasible for $M \le 2 \cdot 10^6$.

**[THOUGHT_09_02]**

Aggregate-all-then-validate: Time $O(K \log K + K)$ where $K \le M$; space $O(K)$ plus significant overhead for $O(K)$ container objects. Asymptotically acceptable but memory-heavy and fragmentation-prone when $D$ is large.

**[THOUGHT_09_03]**

Streaming without contiguity: Time approximately $O\!\left(\sum_t K_t\right)$ with per-frame hashing; space $O(D)$ globally and $O(K_t)$ per frame. Fails correctness due to allowing reappearances after gaps.

**[THOUGHT_09_04]**

Final streaming with last-seen and per-frame grouping: Time $\sum_t O(K_t \log K_t)$ with worst case $O(M \log M)$; space $O(D)$ for the global map plus $O(N)$ temporary per frame. Meets constraints robustly and passes all correctness conditions.

---

**[CHAIN_10]**

This section performs lightweight hand-traces to build confidence in the solution.

**[THOUGHT_10_01]**

Single duet in one frame:

Frame 1: indices $2$ and $3$ emit code $10$.
Group size is $2$ and participants are $(2, 3)$. Insert with last $= 0$.
No further frames. Count duets $= 1$. Valid.

**[THOUGHT_10_02]**

Reappearance after a gap:

Frame 1: index $1$ emits code $5$ $\rightarrow$ insert with last $= 0$.
Frame 2: silent.
Frame 3: index $1$ emits code $5$. Lookup finds last $= 0$, but current $t = 2$; not contiguous. Reject. Output is $-1$.

**[THOUGHT_10_03]**


Reappearance after a gap:

Frame 1: index $1$ emits code $5$ $\rightarrow$ insert with last $= 0$.
Frame 2: silent.
Frame 3: index $1$ emits code $5$. Lookup finds last $= 0$, but current $t = 2$; not contiguous. Reject. Output is $-1$.

**[THOUGHT_10_04]**

Participant change across frames:

Frame 1: indices $1$ and $2$ emit code $8$. Record participants $(1, 2)$, last $= 0$.
Frame 2: only index $1$ emits code $8$. Group size $= 1$ and participants $(1, -1)$ differ from $(1, 2)$. Reject. Output is $-1$.

---

**[RESPONSE]**

**1. Problem Understanding**

We observe $N$ pollinators across $T$ frames. In each frame, every pollinator either stays silent (value $0$) or emits a positive integer frequency code. Each positive code corresponds to exactly one song that:
- Is active over a single contiguous block of frames.
- Has a fixed set of emitters (participants) throughout its active period, and this set is either of size $1$ (solo) or size $2$ (duet).
- Is never emitted by three or more pollinators in the same frame.

Task:
- Verify whether the log satisfies all rules.
- If valid, output the number of duets (codes with exactly two fixed participants).
- Otherwise, output $-1$.

Key observations:
- Validity checks can be performed per code, but to remain efficient we must process the log in a streaming fashion across frames.
- We need to enforce three conditions: per-frame limit (at most two simultaneous emitters per code), fixed participants for each code across its active interval, and contiguity (no gaps in the frames where a code appears).


**2. Optimal Approach**

We process the log frame by frame, grouping identical codes within each frame and maintaining per-code global state to enforce both fixed participants and contiguity.

Steps:
1. For each frame $t$, collect all non-zero entries into a list of pairs $(\text{code}, i)$, where $i$ is the pollinator index.
2. Sort this list by code to group identical codes together for the current frame. Sweep the list:
   - If any code appears more than twice in the same frame, it violates the per-frame rule; return $-1$.
   - Otherwise, derive the participant set for that code in the frame:
     - If it appears once, record as $(a, -1)$ for a solo.
     - If it appears twice, record as $(\min(a, b), \max(a, b))$ for a duet.
3. Maintain a global hash map: code $\to$ {participants, lastSeenFrame}.
   - If a code is new, insert its participants with lastSeenFrame set to the current frame.
   - If the code exists, enforce:
     - Contiguity: its lastSeenFrame must be the previous frame ($t - 1$).
     - Fixed participants: the current participants must equal the stored participants.
     - If either check fails, return $-1$. Otherwise, update lastSeenFrame to the current frame.
4. After processing all frames without violations, count how many codes have two participants (i.e., the second participant is not $-1$) and print that count.

This approach is efficient and memory-conscious: sorting per frame groups instances locally, while the global map ensures continuity and participant consistency over time.


**3. Code**
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <utility>
using namespace std;

/**
 * @brief State stored for each distinct positive code.
 *
 * @param a First participant index (1-based).
 * @param b Second participant index, or -1 if solo.
 * @param last Last frame index in which this code appeared (0-based).
 */
struct CodeState {
    int a;
    int b;
    int last;
};

/**
 * @brief Entry point. Reads the log, validates all constraints, and outputs
 *        the number of duets if valid, or -1 if any rule is violated.
 *
 * @return 0 on successful termination.
 */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int numberOfPollinators, numberOfFrames;
    if (!(cin >> numberOfPollinators >> numberOfFrames)) {
        return 0;
    }

    unordered_map<long long, CodeState> codeStateMap;
    codeStateMap.reserve(1 << 20);

    vector<pair<long long, int>> frameBuffer;
    frameBuffer.reserve(numberOfPollinators);

    for (int frameIndex = 0; frameIndex < numberOfFrames; ++frameIndex) {
        frameBuffer.clear();

        for (int pollinatorIndex = 1; pollinatorIndex <= numberOfPollinators; ++pollinatorIndex) {
            long long code;
            cin >> code;
            if (code != 0) {
                frameBuffer.emplace_back(code, pollinatorIndex);
            }
        }

        sort(frameBuffer.begin(), frameBuffer.end(),
            [](const pair<long long, int> &x, const pair<long long, int> &y) {
                if (x.first != y.first) {
                    return x.first < y.first;
                }
                return x.second < y.second;
            });

        for (size_t groupStart = 0; groupStart < frameBuffer.size(); ) {
            long long code = frameBuffer[groupStart].first;
            int count = 0;
            int a = -1, b = -1;

            size_t groupEnd = groupStart;
            while (groupEnd < frameBuffer.size() && frameBuffer[groupEnd].first == code) {
                ++count;
                if (count == 1) {
                    a = frameBuffer[groupEnd].second;
                } else if (count == 2) {
                    b = frameBuffer[groupEnd].second;
                } else {
                    cout << -1 << '\n';
                    return 0;
                }
                ++groupEnd;
            }

            if (b != -1 && a > b) {
                swap(a, b);
            }

            auto it = codeStateMap.find(code);
            if (it == codeStateMap.end()) {
                codeStateMap.emplace(code, CodeState{a, b, frameIndex});
            } else {
                CodeState &st = it->second;
                if (st.last != frameIndex - 1) {
                    cout << -1 << '\n';
                    return 0;
                }
                if (st.a != a || st.b != b) {
                    cout << -1 << '\n';
                    return 0;
                }
                st.last = frameIndex;
            }

            groupStart = groupEnd;
        }
    }

    long long duetCount = 0;
    for (const auto &kv : codeStateMap) {
        if (kv.second.b != -1) {
            ++duetCount;
        }
    }

    cout << duetCount << '\n';
    return 0;
}
```

**4. Code Explanation**

- Data structures:
  - frameBuffer collects non-zero $(\text{code}, \text{pollinator})$ pairs for the current frame.
  - codeStateMap maintains, for each code, its fixed participant set and the last frame it appeared in.

- Per-frame processing:
  - Sort frameBuffer by code to cluster identical codes. For each cluster, count occurrences.
  - If a cluster exceeds two occurrences, the per-frame rule is violated; print $-1$.
  - Otherwise, determine the participant set: a single index for solos $(a, -1)$ or two sorted indices $(\min(a, b), \max(a, b))$ for duets.

- Global validation:
  - If a code is new, store its participants and mark the current frame as last seen.
  - If previously seen, enforce contiguity by requiring last seen frame to be the immediate predecessor, and enforce fixed participants by requiring exact equality of the participant set. Reject if any check fails.

- Final result:
  - Count codes with two participants (second participant not $-1$) as duets and print the count.

Example execution sketch:
- Suppose frames:
  - Frame 1: pollinator 1 emits code 1.
  - Frame 2: pollinator 1 emits code 1.
  - Frame 3: pollinators 2 and 3 emit code 2.
- Code 1 is a solo across two consecutive frames with fixed participants, valid.
- Code 2 is a duet appearing once, valid.
- Output is $1$, the number of duets.

**5. Time and Space Complexity**

- Let $M = N \cdot T$ and $K_t$ be the number of non-zero entries in frame $t$.
- Time complexity:
  - Sorting within each frame takes $O(K_t \log K_t)$.
  - The total across frames is $\sum_{t=1}^{T} K_t \log K_t \le O(M \log M)$ in the worst case.
  - The grouping and map operations are linear in the number of non-zero entries.
- Space complexity:
  - Global map stores one record per distinct code: $O(D)$ where $D$ is the number of distinct positive codes.
  - Per-frame buffer uses $O(N)$ space.
  - Total additional space is $O(D + N)$.

**6. Conclusion**

By streaming each frame, grouping identical codes per frame, and maintaining per-code participants with a last-seen frame index, we rigorously enforce all constraints: at most two simultaneous emitters per code, fixed participants across the active interval, and contiguity of appearances. If a violation is detected, we output $-1$; otherwise, we count and output the number of duets. This solution is efficient and robust for inputs where $N \cdot T \le 2 \cdot 10^6$.