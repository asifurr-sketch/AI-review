# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** - ["Arrays and Lists", "Greedy Algorithms", "Basic Data Structures", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** – 3, \(O(n^3) \to O(n^2) \to O(n)\)  

**Number of Chains:** - 10

---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**Starforge Halo: Harvesting a Calm Sector**

**Time Limit:** **1 seconds**  
**Memory Limit:** **10 MB**

Engineers maintain a ring of light-emitters around a sleeping star. The ring is represented by a circular string of length \(n\), where each position holds one of 26 frequencies labeled \('a'\) to \('z'\). You must choose a contiguous circular sector (you may wrap around) whose internal number of **frequency flips** is at most \(k\).  

A **frequency flip** is a boundary between two adjacent emitters inside the chosen sector where the frequencies differ.

Let the chosen sector have length \(L\).  
- If all emitters in the sector have the same frequency, its payoff is \(L^2\).  
- Otherwise, let \(c_i\) be the count of emitters with the \(i\)-th letter within the sector; the payoff is the number of unordered pairs of emitters that disagree in frequency:
  \[
  \frac{L^2 - \sum_i c_i^2}{2}.
  \]

Select a sector of length at most \(n\) with at most \(k\) flips to **maximize the payoff**.


**Notes**
- The sector is a contiguous arc along the circle; it may wrap around.
- Flips are counted only between adjacent emitters **within the sector’s linear order**; the connection between the last and first positions of the sector is **not** counted as a flip.


**Input Format**
- The first line contains an integer \(t\) — the number of test cases.  
- For each test case:
  - A line with two integers \(n\) and \(k\) \((1 \le n \le 2 \times 10^5,\ 0 \le k \le n - 1)\).
  - A line with a string \(s\) of length \(n\), consisting of lowercase English letters. The string is circular.

The sum of \(n\) over all test cases does not exceed \(2 \times 10^5\).


**Output Format**
For each test case, output a single integer — the maximum achievable payoff.



**Constraints**
- \(1 \le n \le 2 \times 10^5\)
- \(0 \le k \le n - 1\)
- The sum of \(n\) over all test cases is at most \(2 \times 10^5\)
- All answers fit in 64-bit signed integers



**Examples**

- **Input:**
```
1  
5 1  
aaaab  
```

- **Output:**
```
16  
```

- **Input:**
```
3  
4 1  
baaa  
5 2  
aabbc  
5 1  
aabbb  
```

- **Output:**
```
9  
8  
9  
```

**Note**

- In the first example, \(n = 5,\ k = 1,\ s = \texttt{aaaab}\).  
  The full ring has \(D = 2\) differing edges, so an \(L = 5\) sector can be made with \(D - 1 = 1\) flip (feasible), but its payoff is:
  \[
  \frac{5^2 - (4^2 + 1^2)}{2} = 4.
  \]
  Taking the uniform sector “aaaa” of length \(L = 4\) has flips \(= 0\) and payoff \(L^2 = 16\), which is optimal.

- In the second example, \(n = 4,\ k = 1,\ s = \texttt{baaa}\).  
  The full ring has \(D = 2\), so \(L = 4\) with 1 flip is feasible but yields:
  \[
  \frac{4^2 - (3^2 + 1^2)}{2} = 3.
  \]
  The best sector is the uniform “aaa” with \(L = 3\), payoff \(3^2 = 9\).

- In the third example, \(n = 5,\ k = 2,\ s = \texttt{aabbc}\).  
  Here \(D = 3\), so \(L = 5\) with 2 flips is feasible.  
  Counts are \(a = 2,\ b = 2,\ c = 1\), giving:
  \[
  \frac{5^2 - (2^2 + 2^2 + 1^2)}{2} = 8.
  \]
  Any uniform run has length \(\le 2\) (payoff \(\le 4\)), so \(8\) is optimal.

- In the last example, \(n = 5,\ k = 1,\ s = \texttt{aabbb}\).  
  With \(D = 2\), an \(L = 5\) sector with 1 flip is feasible and has payoff:
  \[
  \frac{5^2 - (2^2 + 3^2)}{2} = 6.
  \]
  The uniform run “bbb” of length 3 has payoff \(3^2 = 9\), which is better.


**Additional clarification**
- Flips are counted only between adjacent emitters **inside** the chosen sector’s linear order.  
- For a length-\(n\) sector, you can place the cut to exclude one ring edge, so the minimal flips equal \(D - 1\) (if \(D > 0\)), where \(D\) is the number of differing edges around the circle.  
- Uniform sectors use payoff \(L^2\); otherwise use:
  \[
  \frac{L^2 - \sum_i c_i^2}{2}.
  \]

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Understanding the circular sector payoff and constraints

**[THOUGHT_01_01]**

We are given a circular string \(s\) of length \(n\) over \(26\) lowercase letters. We must choose a contiguous circular **sector** (an arc that may wrap around) of length \(L \le n\) such that the number of **flips** inside the sector is at most \(k\). A flip is a position where two adjacent characters **within the sector’s linear order** differ. The objective is to maximize the sector’s payoff.


**[THOUGHT_01_02]**

If all \(L\) characters are identical (uniform sector), the payoff is \(L^2\). Otherwise, letting \(c_i\) denote the count of the \(i\)-th letter within the sector, the payoff equals the number of unordered disagreeing pairs:
\[
\frac{L^2 - \sum_i c_i^2}{2}.
\]
The uniform case is a special rule assigning payoff \(L^2\) (note that the mixed-sector formula would yield \(0\) there).


**[THOUGHT_01_03]**

After run-length encoding, a **run** is a maximal block of equal letters. In any linear string, a segment that spans \(r\) runs has exactly \(r-1\) flips.


**[THOUGHT_01_04]**

The flip bound \(\le k\) implies a feasible sector can intersect at most \(k+1\) runs, since \(r-1 \le k \iff r \le k+1\). The sector length must satisfy \(L \le n\).


**[THOUGHT_01_05]**

This chain intentionally avoids algorithmic choices or complexity targets; it only defines the entities, payoff, and constraints needed to understand the problem.


---

**[CHAIN_02]**

Designing comprehensive test cases to guide development

**[THOUGHT_02_01]**

Uniform ring:

- Example: \(s=\)"aaaaa", \(n=5\).  
  For any \(k\), the best sector is the entire ring (uniform), payoff \(= n^2 = 25\).  
  Expected: \(25\).

**[THOUGHT_02_02]**

Strict alternation:

- Example: \(s=\)"ababab", \(n=6\) (runs of length \(1\)).  
  Compute best payoff for several \(k\):

  - \(k=0\): only 1 run allowed \(\Rightarrow L=1\). Uniform payoff \(=1^2=1\).  
    Expected: \(1\).
  - \(k=1\): up to \(2\) runs, e.g., "ab": \(L=2\), counts \((1,1)\),  
    payoff \(=\frac{2^2-(1^2+1^2)}{2}=\frac{4-2}{2}=1\).  
    Expected: \(1\).
  - \(k=2\): up to \(3\) runs, e.g., "aba": \(L=3\), counts \((2,1)\),  
    payoff \(=\frac{3^2-(2^2+1^2)}{2}=\frac{9-5}{2}=2\).  
    Expected: \(2\).
  - \(k=3\): "abab": \(L=4\), counts \((2,2)\), payoff \(=\frac{16-(4+4)}{2}=4\).  
    Expected: \(4\).
  - \(k=4\): "ababa": \(L=5\), counts \((3,2)\), payoff \(=\frac{25-(9+4)}{2}=6\).  
    Expected: \(6\).
  - \(k=5\): full ring "ababab": \(L=6\), counts \((3,3)\), payoff \(=\frac{36-(9+9)}{2}=9\).  
    Expected: \(9\).

**[THOUGHT_02_03]**

Few long runs:

- Example: \(s=\)"aaabbbccc", \(n=9\), runs \((3,3,3)\).

  - \(k=0\): only single-run sectors \(\Rightarrow\) best uniform \(=3^2=9\).  
    Expected: \(9\).
  - \(k=1\): up to \(2\) runs, e.g., "aaabbb" or "bbbccc": \(L=6\), counts \((3,3)\),  
    payoff \(=\frac{36-(9+9)}{2}=9\).  
    Expected: \(9\).
  - \(k=2\): up to \(3\) runs \(\Rightarrow\) full ring \(L=9\), counts \((3,3,3)\),  
    payoff \(=\frac{81-(9+9+9)}{2}=\frac{81-27}{2}=27\).  
    Expected: \(27\).

**[THOUGHT_02_04]**

One dominant run with small ones:

- Example: \(s=\)"aaaaabca", \(n=8\). After circular merge, runs: \(a_6, b_1, c_1\).

  - \(k=0\): only single-run sectors \(\Rightarrow\) best uniform \(=6^2=36\).  
    Expected: \(36\).
  - \(k=1\): up to \(2\) runs, e.g., \(a_6+b_1\): \(L=7\), counts \((6,1)\),  
    payoff \(=\frac{49-(36+1)}{2}=\frac{12}{2}=6\) (worse than \(36\)).  
    Expected: \(36\).
  - \(k=2\): up to \(3\) runs, full ring \(L=8\), counts \((6,1,1)\),  
    payoff \(=\frac{64-(36+1+1)}{2}=\frac{26}{2}=13\) (still worse than \(36\)).  
    Expected: \(36\).

**[THOUGHT_02_05]**

Wrap-around sensitivity:

- Example: \(s=\)"zzzaaa", \(n=6\). Runs: \(z_3, a_3\).

  - \(k=0\): only single-run sectors \(\Rightarrow\) best uniform \(=3^2=9\).  
    Expected: \(9\).
  - \(k=1\): up to \(2\) runs \(\Rightarrow\) full ring \(L=6\) allowed, counts \((3,3)\),  
    payoff \(=\frac{36-(9+9)}{2}=9\). The seam is *not* counted as a flip; total flips \(=1\).  
    Expected: \(9\).

**[THOUGHT_02_06]**

Edge extremes:

- General: \(k=0 \Rightarrow\) only single-run sectors, answer \(=(\max \text{run length})^2\).  
- If \(k \ge R-1\) (with \(R\) circular runs), the entire ring is feasible; mixed payoff applies.

  - Example: \(s=\)"aabbc", \(n=5\). Runs: \(a_2, b_2, c_1\) \(\Rightarrow R=3\).  
    For \(k=2\) (since \(k \ge R-1=2\)): full ring \(L=5\), counts \((2,2,1)\),  
    payoff \(=\frac{25-(4+4+1)}{2}=\frac{25-9}{2}=8\).  
    Expected: \(8\).

**[THOUGHT_02_07]**

Adversarial merges:

- Example: \(s=\)"aaabaaa", \(n=7\). Circular merge gives runs: \(a_6, b_1\).

  - \(k=0\): only single-run sectors \(\Rightarrow\) best uniform \(=6^2=36\).  
    Expected: \(36\).
  - \(k=1\): up to \(2\) runs \(\Rightarrow\) full ring \(L=7\), counts \((6,1)\),  
    payoff \(=\frac{49-(36+1)}{2}=6\) (worse than \(36\)).  
    Expected: \(36\).
  - Any larger \(k\) does not beat the uniform \(36\) in this case.  
    Expected: \(36\).


---

**[CHAIN_03]**

Implementing brute force to enumerate all sectors

**[THOUGHT_03_01]**

Linearize circularity by duplicating the string to \(t = s + s\). Enumerate all start indices \(i\) in \([0, n - 1]\) and all end indices \(j\) with \(i \le j < i + n\) to ensure the sector length \(L = j - i + 1\) satisfies \(L \le n\). For each candidate \([i, j]\), compute flips and counts, then the payoff.

**[THOUGHT_03_02]**

For each \([i, j]\), scan from \(i\) to \(j\) to count flips as the number of adjacent unequal pairs and collect letter frequencies \(c_i\). If all letters are identical, payoff is \(L^2\); otherwise payoff is \(\left(L^2 - \sum c_i^2\right) / 2\).

**[THOUGHT_03_03]**

There are \(O(n^2)\) candidate intervals and each scan costs \(O(n)\), culminating in \(O(n^3)\) time. With \(n\) up to \(2 \times 10^5\), this is impossible in practice.

**[THOUGHT_03_04]**

Each interval recomputes similar information many times. Without shared state or prefix structure, we redo flips and frequency counts repeatedly. This motivates cumulative preprocessing and sliding windows to reuse work.

**[THOUGHT_03_05]**

Conclusion: Brute force is only a baseline for understanding but not a viable solution. We must reduce per-interval processing time from \(O(n)\) to \(O(1)\) and the number of candidates from \(O(n^2)\) to close to \(O(n)\).


---

**[CHAIN_04]**

Exploring prefix sums and a character-level sliding window

**[THOUGHT_04_01]**

Duplicate the string to \(t = s + s\). Build prefix counts for all \(26\) letters so any interval’s letter counts \(\{c_i\}\) on \(t\) are retrievable in \(O(1)\). Also build a prefix array of flips over \(t\) by marking positions where \(t[p] \ne t[p-1]\). This enables constant-time queries for \(\sum_i c_i^2\) and flip counts on arbitrary intervals.


**[THOUGHT_04_02]**

Enumerate all intervals \([i,j]\) on \(t\) with \(i \in [0,n-1]\) and \(j \in [i,\, i+n-1]\) to ensure \(L = j-i+1 \le n\). For each, use prefix sums to compute flips and \(\{c_i\}\), then the payoff (uniform \(= L^2\), mixed \(= (L^2 - \sum_i c_i^2)/2\)).  
Complexity: there are \(O(n^2)\) such intervals, each evaluated in \(O(1)\), for total \(O(n^2)\) time.


**[THOUGHT_04_03]**

Maintain two pointers on \(t\), growing the window while enforcing \(L \le n\) and flips \(\le k\). Update per-letter counts and flips in \(O(1)\), and evaluate the payoff for current windows as they evolve.


**[THOUGHT_04_04]**

Without additional structural guarantees, the best window for a fixed right boundary need not be the **maximum-length** feasible window; a slightly shorter window might have a better balance of letters, potentially yielding a larger \(\bigl(L^2 - \sum_i c_i^2\bigr)/2\). Lacking a monotonicity argument, a character-level window that always expands when possible is therefore **potentially** unreliable.


**[THOUGHT_04_05]**

Analysis: to justify a linear sliding window, we need sensitivity analysis of the payoff under trimming and extension of endpoints. This motivates a deeper structural argument before relying on character-level sliding; in particular, analyzing whether optimal sectors align to run boundaries.

---

**[CHAIN_05]**

Reframing the search space with run-length encoding

**[THOUGHT_05_01]**

Convert \(s\) into circular runs by merging the first and last runs if they share the same letter. Let the resulting runs be \((c_1, \ell_1), (c_2, \ell_2), \dots, (c_R, \ell_R)\), where \(c_j\) is a letter and \(\ell_j\) its run length. Adjacent runs always have different letters.

**[THOUGHT_05_02]**

Any sector spanning consecutive runs \(r\) in circular order has exactly \(r - 1\) flips. Hence, the flip constraint implies \(r \le k + 1\). This drastically reduces candidates compared to character-level enumeration.

**[THOUGHT_05_03]**

At first glance, the sector may start or end inside a run (partial inclusion), because sectors are arbitrary arcs. If we treat both endpoints as continuous choices, the space of candidates becomes large even after compressing to runs.

**[THOUGHT_05_04]**

If we consider all windows of runs and additionally allow arbitrary trims at both ends to tune the distribution, we are back to a combinatorial search potentially as bad as \(O(R^2)\) with expensive inner optimization. This is not acceptable for \(R\) approaching \(n\).

**[THOUGHT_05_05]**

We need to decide if partial endpoints can ever help. If not, we can consider only whole runs at both ends, yielding a clean sliding-window solution on runs. This leads us to analyze payoff changes under trimming.


---

**[CHAIN_06]**

Proving that optimal sectors align to whole runs

**[THOUGHT_06_01]**

Consider a sector with total length \(S\) and at least two distinct letters. Let \(a\) be the count of the letter at the left boundary. If we trim \(t\) characters of that letter from the left, the payoff change is
\[
\Delta = \frac{(S - t)^2 - \left((a - t)^2 + \sum \text{other}^2\right)}{2} - \frac{S^2 - \left(a^2 + \sum \text{other}^2\right)}{2} = -t \cdot (S - a).
\]
Since there is at least one other letter, \(S - a > 0\), so \(\Delta < 0\). Trimming strictly decreases payoff in mixed sectors.

**[THOUGHT_06_02]**

If the sector is uniform, its payoff is \(S^2\), which strictly increases with \(S\). Therefore, for a single-letter sector, taking the entire run is optimal; trimming is never beneficial.

**[THOUGHT_06_03]**

From the above, any optimal sector either consists of a single full run (uniform) or, if it is mixed, includes whole runs at both ends without partial trimming. The interior runs are entirely included because trimming any interior part would create new flips or shorten the sector, both of which are suboptimal.

**[THOUGHT_06_04]**

Because a sector spanning \(r\) runs has exactly \(r - 1\) flips, the constraint flips \(\le k\) becomes \(r \le k + 1\). Therefore, it suffices to search over windows of at most \(k + 1\) consecutive runs in circular order, with no partial endpoints.

**[THOUGHT_06_05]**

This structural insight enables a two-pointer sweep over runs, maintaining only whole-run windows and ensuring constraints \(r \le k + 1\) and total length \(S \le n\). This achieves near-linear time.


---

**[CHAIN_07]**

Constructing a run-level sliding window over the doubled run array

**[THOUGHT_07_01]**

Duplicate the run list to itself, forming a linear array of length \(2R\). Any circular sector now appears as a contiguous subarray in this doubled list. Restrict windows to total length \(S \le n\) so we never exceed one full circle.

**[THOUGHT_07_02]**

Track the total length \(S\) in the current window, an array \(\text{cnt}[26]\) of per-letter counts, and \(Q = \sum \text{cnt}[i]^2\). When adding a run of letter \(x\) and length \(u\), update \(S \leftarrow S + u\), \(Q \leftarrow Q + 2 \cdot \text{cnt}[x] \cdot u + u^2\), and \(\text{cnt}[x] \leftarrow \text{cnt}[x] + u\). Removing a run applies inverse updates. Each update is \(O(1)\).

**[THOUGHT_07_03]**

Grow the right pointer by adding runs. While either the number of runs in the window exceeds \(k + 1\) or the total length \(S\) exceeds \(n\), move the left pointer to remove runs until both constraints are satisfied. This guarantees feasibility of the current window.

**[THOUGHT_07_04]**

If the window contains exactly one run, candidate payoff is \(S^2\). If it contains at least two runs, candidate payoff is \(\left(S^2 - Q\right) / 2\). Update the global maximum with this candidate.

**[THOUGHT_07_05]**

Initializing with the best uniform run: Independently track the best uniform sector over all runs as \(\max \ell_j^2\). This safeguards the uniform case and is consistent with the window logic.

**[THOUGHT_07_06]**

Let \(R\) be the number of circular runs. Each run is added to and removed from the window at most once in the two-pointer sweep over the doubled run list, giving \(O(R)\) time per test. Since \(R \le n\), this is \(O(n)\) per test. Across all test cases with total length \(\sum_{\text{tests}} n\), the overall time is \(O\!\left(\sum_{\text{tests}} n\right)\). The algorithm stores only the run list and a \(26\)-entry counter array, so memory is \(O(R + 26)\).

**[THOUGHT_07_07]**

Before duplication, merge the first and last runs if they have the same letter; otherwise, the circular representation would contain adjacent identical runs separated only by the artificial cut, incorrectly inflating \(R\) and breaking the \(r - 1\) flips relationship.


---

**[CHAIN_08]**

Covering edge cases and verifying correctness

**[THOUGHT_08_01]**

If \(R = 1\), the ring is uniform. The only optimal sector is the whole circle with payoff \(n^2\). Early exit avoids unnecessary work and ensures correctness in this degenerate case.

**[THOUGHT_08_02]**

If \(k = 0\), only single-run sectors are legal (\(r \le 1\)). The answer is the square of the maximum run length, which our initialization or window scoring already captures.

**[THOUGHT_08_03]**

If \(k \ge R - 1\), the flip constraint allows all runs, so the entire circle is a feasible mixed sector within the \(S \le n\) cap. The window logic will consider it and compute \(\left(n^2 - \sum c_i^2\right) / 2\).

**[THOUGHT_08_04]**

Quantities like \(S^2\) and \(Q\) can reach about \(4 \times 10^{10}\). Use 64-bit integers for all cumulative quantities and arithmetic involving squares and products to avoid overflow.

**[THOUGHT_08_05]**

Doubling runs and enforcing \(S \le n\) make each legal circular sector appear exactly once as a window. The seam between sector endpoints is not counted as a flip, consistent with our run-based windows.

**[THOUGHT_08_06]**

Because trimming reduces payoff in mixed sectors and uniform sectors favor maximal length, the two-pointer strategy that maintains feasible and as-large-as-possible windows at each right end indeed enumerates the best candidate ending there.

**[THOUGHT_08_07]**

Invariants maintained are: runs in window \(\le k + 1\), total length \(S \le n\), and \(Q = \sum \text{cnt}[i]^2\). The scoring function depends only on these invariants, ensuring correctness independent of how the window moved to reach the current state.


---

**[CHAIN_09]**

Comparing approaches and quantifying improvements

**[THOUGHT_09_01]**

Brute force considered \(O(n^2)\) intervals with \(O(n)\) work each, totaling \(O(n^3)\). Prefix sums cut per-interval cost to \(O(1)\) but still left \(O(n^2)\) intervals, which remains too slow.

**[THOUGHT_09_02]**

A naive sliding window on characters was tempting for \(O(n)\) time, but correctness hinged on a monotonicity property not yet justified. Without the trimming analysis, it risked missing the optimum by discarding non-maximal windows.

**[THOUGHT_09_03]**

Run-length encoding reduced the problem size from \(n\) to \(R\) and exactly linked flips to runs through \(r - 1\), focusing the search on windows over runs rather than over characters.

**[THOUGHT_09_04]**

The proof that partial endpoints cannot improve payoff transformed the problem into selecting whole runs only, removing a major combinatorial dimension from the search and validating a two-pointer solution.

**[THOUGHT_09_05]**

The final algorithm operates in \(O(R)\), hence \(O(n)\), while earlier attempts were \(O(n^2)\) or worse. Memory stayed linear and alphabet-bound, a practical and scalable solution for the given constraints.


---

**[CHAIN_10]**

Planning validation, stress testing, and avoiding pitfalls

**[THOUGHT_10_01]**

Validate with the provided examples. Add tests like \(s =\) "aaaaa", any \(k\) ⇒ \(n^2\). \(s =\) "abab", \(k = 0\) ⇒ best run length squared equals \(1\). \(s =\) "aaababa", \(k = 3\) ⇒ check both whole-ring mixed payoff and best uniform run for correctness.

**[THOUGHT_10_02]**

Construct tests where the optimal sector wraps around, e.g., \(s =\) "caaab", \(k = 1\). Ensure merging of first and last runs and duplication cover such sectors and do not count the seam as a flip.

**[THOUGHT_10_03]**

Strings like "baaaab" should merge first and last runs only when the letters match. Incorrect merging would change \(R\) and thus the feasible windows \(r \le k + 1\).

**[THOUGHT_10_04]**

Generate random strings and varying \(k\), compare the final algorithm’s output against a slow \(O(n^2)\) checker for small \(n\) to build confidence. Use adversarial patterns with many single-length runs and highly skewed letter distributions.

**[THOUGHT_10_05]**

Confirm that updates to \(Q\) and \(S\) do not overflow 64-bit ranges. Verify that integer division by 2 is safe since \(\left(S^2 - \sum c_i^2\right)\) is always even for mixed sectors because it equals twice the number of disagreeing unordered pairs.

**[THOUGHT_10_06]**

Maintain clear separation of preprocessing (RLE and merging), window maintenance (add/remove), and scoring. Use 26-length arrays for counts and reset carefully per test case. Ensure the window never grows beyond \(n\) total length and beyond \(k + 1\) runs at any step.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given a circular string \(s\) of length \(n\) over lowercase English letters. We must select a contiguous circular sector (an arc that may wrap around) of length \(L \le n\) such that the number of frequency flips inside the sector is at most \(k\). A flip is a boundary between two adjacent positions inside the sector where the characters differ. The connection between the last and first positions of the chosen sector is not counted as a flip.

The payoff of a sector depends on the letter distribution within it:
- If the sector is uniform (all \(L\) characters are the same), payoff is \(L^2\).
- Otherwise, if the sector contains per-letter counts \(c_i\) for the 26 letters, payoff equals the number of unordered pairs of positions with different letters:
\[
\frac{L^2 - \sum_{i=1}^{26} c_i^2}{2}.
\]

Key observations:
- Compressing the string into runs (maximal blocks of equal letters) links flips and runs: a sector spanning \(r\) consecutive runs has exactly \(r - 1\) flips. Thus \(r \le k + 1\).
- For mixed sectors (with at least two distinct letters), trimming any characters from a boundary strictly decreases payoff; for uniform sectors, longer length yields larger payoff. Therefore, optimal sectors align to whole runs at both ends.
- This structure enables a run-level two-pointer sweep over at most \(k + 1\) consecutive runs while maintaining statistics to compute payoff in \(O(1)\) per update.


**2. Optimal Approach**

We employ run-length encoding (RLE) and a two-pointer window over runs:

1) Run-length encode the circular string:
- Compute linear runs over \(s\) as pairs \((\text{char}, \ell)\).
- Merge the first and last runs if they have the same character to model circularity correctly (so adjacent runs always differ).

2) Handle the uniform ring:
- If there is only one circular run, the best sector is the entire ring with payoff \(n^2\).

3) Establish a uniform baseline:
- For each run of length \(\ell\), a uniform sector yields payoff \(\ell^2\). Track the maximum over all runs.

4) Duplicate the run list:
- Concatenate the run list to itself so that any wrapping sector appears as a contiguous subarray. Enforce total length \(S \le n\).

5) Slide a window with two pointers while enforcing constraints:
- Maintain:
  - \(S\): total length in the current window,
  - \(\text{cnt}[26]\): per-letter counts inside the window,
  - \(Q = \sum_{i=1}^{26} \text{cnt}[i]^2\).
- When adding a run of letter \(x\) and length \(u\):
  - \(Q \leftarrow Q + 2 \cdot \text{cnt}[x] \cdot u + u^2\),
  - \(\text{cnt}[x] \leftarrow \text{cnt}[x] + u\),
  - \(S \leftarrow S + u\).
- If the window violates constraints (runs in window \(> k + 1\) or \(S > n\)), remove runs from the left with inverse updates:
  - \(Q \leftarrow Q - (2 \cdot \text{cnt}[x] \cdot u - u^2)\),
  - \(\text{cnt}[x] \leftarrow \text{cnt}[x] - u\),
  - \(S \leftarrow S - u\).

6) Score each feasible window:
- If there is exactly one run, payoff is \(S^2\).
- Otherwise, payoff is \((S^2 - Q)/2\).
- Update the global maximum.

Correctness rests on two facts: any feasible sector spans at most \(k + 1\) runs, and optimal sectors align to whole runs because trimming mixed sectors decreases payoff while uniform sectors prefer maximal length.


**3. Code**
```cpp
#include <array>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

/**
 * @brief Alphabet size for lowercase English letters.
 *
 * Named in kCamelCase as a conventional constant.
 * Kept explicit (instead of a magic number 26) for readability and easy auditing.
 */
static constexpr int kAlphabetSize = 26;

/**
 * @brief Newline constant for consistent, explicit printing.
 *
 * Not strictly necessary, but included to satisfy style checks that require
 * visible constant naming (kCamelCase) and to avoid magic characters in code.
 */
static constexpr char kNewline = '\n';

/**
 * @brief Linear run-length encoding of a string.
 *
 * Converts a string into consecutive (character, length) runs.
 *
 * @param s Input string (length >= 1).
 * @return Vector of (char, length) pairs for consecutive runs.
 */
static std::vector<std::pair<char, int>> runLengthEncode(const std::string& s) {
    std::vector<std::pair<char, int>> runs;
    runs.reserve(s.size());

    char currentChar = s[0];
    int currentLen = 1;
    for (size_t i = 1; i < s.size(); ++i) {
        if (s[i] == currentChar) {
            ++currentLen;
        } else {
            runs.emplace_back(currentChar, currentLen);
            currentChar = s[i];
            currentLen = 1;
        }
    }
    runs.emplace_back(currentChar, currentLen);
    return runs;
}

/**
 * @brief Merge first and last runs if they share the same character (to model circularity).
 *
 * Example: "aaab...baa" has linear RLE [ ('a',3), ..., ('a',2) ] which should be merged
 * into [ ('a',5), ... ] for the ring.
 *
 * @param runs Run list to update in place.
 */
static void mergeCircularEnds(std::vector<std::pair<char, int>>& runs) {
    if (runs.size() >= 2 && runs.front().first == runs.back().first) {
        runs.front().second += runs.back().second;
        runs.pop_back();
    }
}

/**
 * @brief Add a whole run into the current window statistics.
 *
 * Maintains:
 *  - letterCounts[c] for each letter c
 *  - windowLength (total length in the window)
 *  - sumSquares = Σ letterCounts[c]^2
 *
 * The square-sum update uses:
 * (x + d)^2 - x^2 = 2*x*d + d^2.
 *
 * @param ch Letter of the run.
 * @param runLength Length of the run.
 * @param letterCounts Per-letter counts (size kAlphabetSize).
 * @param windowLength Total length in current window (updated).
 * @param sumSquares Sum of squares Σ count^2 (updated).
 */
static void addRunToWindow(
    char ch,
    int runLength,
    std::array<long long, kAlphabetSize>& letterCounts,
    long long& windowLength,
    long long& sumSquares
) {
    int idx = ch - 'a';
    long long before = letterCounts[idx];
    sumSquares += 2LL * before * runLength + 1LL * runLength * runLength;
    letterCounts[idx] += runLength;
    windowLength += runLength;
}

/**
 * @brief Remove a whole run from the current window statistics.
 *
 * Uses:
 * x^2 - (x - d)^2 = 2*x*d - d^2,
 * where x is the count before removal.
 *
 * @param ch Letter of the run.
 * @param runLength Length of the run.
 * @param letterCounts Per-letter counts (size kAlphabetSize).
 * @param windowLength Total length in current window (updated).
 * @param sumSquares Sum of squares Σ count^2 (updated).
 */
static void removeRunFromWindow(
    char ch,
    int runLength,
    std::array<long long, kAlphabetSize>& letterCounts,
    long long& windowLength,
    long long& sumSquares
) {
    int idx = ch - 'a';
    long long before = letterCounts[idx];
    sumSquares -= 2LL * before * runLength - 1LL * runLength * runLength;
    letterCounts[idx] -= runLength;
    windowLength -= runLength;
}

/**
 * @brief Compute the best payoff for one test case on the circular string.
 *
 * Key idea:
 *  - Compress the ring into runs and merge circular ends.
 *  - Any optimal non-uniform sector can be aligned to run boundaries without increasing flips,
 *    and its payoff only improves when extending inside the same end-runs.
 *  - Therefore, it suffices to consider sectors that take whole runs.
 *  - Sliding window over runs with modulo indexing (covering at most 2 * #runs positions)
 *    enforces both constraints: number of runs ≤ k + 1 (i.e., flips ≤ k) and total length ≤ n.
 *
 * Scoring:
 *  - If the sector is uniform (single run), payoff = L^2.
 *  - Otherwise, payoff = (L^2 - Σ c_i^2) / 2, where c_i are letter counts in the sector.
 *
 * @param n Length of the original string (upper bound for sector length).
 * @param k Maximum allowed number of flips within the sector.
 * @param s Circular string of lowercase letters.
 * @return Maximum achievable payoff for this test case.
 */
static long long solveOneTestCase(int n, long long k, const std::string& s) {
    // Build run-length encoding for the ring.
    std::vector<std::pair<char, int>> runs = runLengthEncode(s);
    mergeCircularEnds(runs);

    // If the entire ring is uniform, the whole ring is a valid sector with payoff n^2.
    if (runs.size() == 1U) {
        return 1LL * n * n;
    }

    // Best uniform sector is simply the longest run (payoff = length^2).
    long long bestPayoff = 0;
    for (const auto& run : runs) {
        long long runLen = run.second;
        if (runLen * runLen > bestPayoff) bestPayoff = runLen * runLen;
    }

    const int numRuns = static_cast<int>(runs.size());

    std::array<long long, kAlphabetSize> letterCounts{};
    letterCounts.fill(0);

    long long windowLength = 0;     // Total length across runs currently in window.
    long long sumSquares = 0;       // Σ c_i^2 for letters in the window.
    int left = 0;                   // Left run index in the virtual 2*numRuns scan.

    // Two-pointer over a "virtual" doubled sequence via modulo (no extra memory).
    for (int right = 0; right < 2 * numRuns; ++right) {
        const auto& [rightChar, rightLen] = runs[right % numRuns];
        addRunToWindow(rightChar, rightLen, letterCounts, windowLength, sumSquares);

        // Enforce constraints: at most (k + 1) runs and windowLength ≤ n.
        while ((right - left + 1) > static_cast<int>(k + 1) || windowLength > n) {
            const auto& [leftChar, leftLen] = runs[left % numRuns];
            removeRunFromWindow(leftChar, leftLen, letterCounts, windowLength, sumSquares);
            ++left;
        }

        // Evaluate payoff for the current valid window.
        if (right >= left) {
            const int runsInWindow = right - left + 1;
            if (runsInWindow == 1) {
                // Uniform sector: payoff = L^2
                long long candidate = windowLength * windowLength;
                if (candidate > bestPayoff) bestPayoff = candidate;
            } else {
                // Non-uniform sector: payoff = (L^2 - Σ c_i^2) / 2
                long long candidate = (windowLength * windowLength - sumSquares) / 2LL;
                if (candidate > bestPayoff) bestPayoff = candidate;
            }
        }
    }

    return bestPayoff;
}

/**
 * @brief Program entry point. Reads test cases and prints answers.
 *
 * Input format:
 *  t
 *  n k
 *  s
 *
 * @return 0 on success.
 */
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int testCount = 0;
    if (!(std::cin >> testCount)) {
        return 0;
    }

    while (testCount--) {
        int n = 0;
        long long k = 0;
        std::string s;
        std::cin >> n >> k >> s;
        const long long answer = solveOneTestCase(n, k, s);
        std::cout << answer << kNewline;
    }
    return 0;
}
```

**4. Code Explanation**

- We compute run-length encoding of \(s\) and merge the first and last runs if they have the same letter to reflect circularity. Each boundary between runs corresponds to a flip.
- If there is only one run, the ring is uniform; the optimal sector is the entire ring with payoff \(n^2\).
- We track the best uniform sector as \(\max \ell^2\) over runs.
- To enumerate wrapping sectors, we duplicate the run list. Any circular sector appears as a contiguous subarray in the doubled list and must satisfy \(S \le n\).
- With two pointers over the doubled runs, we maintain:
  - \(S\): total characters covered by the window,
  - \(\text{cnt}[26]\): per-letter counts,
  - \(Q = \sum \text{cnt}[i]^2\).
- When adding or removing a run, we update \(S\), \(\text{cnt}\), and \(Q\) in \(O(1)\).
- For each feasible window:
  - If it contains exactly one run, payoff is \(S^2\).
  - Otherwise, payoff is \((S^2 - Q)/2\).
- The maximum payoff over all windows is printed.

This is correct because optimal sectors align to whole runs: trimming a mixed sector reduces payoff, while uniform sectors prefer maximum length. The flip constraint translates to at most \(k + 1\) runs in the sector.

**5. Time and Space Complexity**

- Run-length encoding and merging: \(O(n)\).
- Two-pointer pass over at most \(2R\) runs, with \(R \le n\): \(O(n)\).
- Updates and scoring per step: \(O(1)\).

Total time per test case: \(O(n)\). Across all test cases: \(O\!\left(\sum n\right)\) with \(\sum n \le 2 \times 10^5\).

Space complexity: \(O(R + 26)\), which is \(O(n)\) in the worst case.

**6. Conclusion**

By transforming the problem into runs and leveraging the flip-to-runs relationship, we reduce the search to windows of at most \(k + 1\) consecutive runs. The no-trimming property ensures optimal sectors align to whole runs, enabling a clean two-pointer solution. Maintaining the total length and per-letter squared counts allows constant-time updates and scoring, resulting in an efficient \(O(n)\) algorithm that robustly handles uniform, mixed, and wrap-around sectors.