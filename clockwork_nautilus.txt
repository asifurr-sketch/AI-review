# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** - ["Number Theory", "Computational Geometry (integer)", "Bit Manipulation", "Greatest Common Divisor", "Integer Square Root"]

**Difficulty:** - Hard

**Languages:** - C++

**Number of Approaches:** - 4 (progression in correctness/robustness; all approaches target \(O(1)\) per query)

**Number of Chains:** - 8

---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**Clockwork Nautilus — Sixteen Vanes and the Binary Hum**

**Time Limit:** **1 seconds**  
**Memory Limit:** **10 MB**

In a dim observatory sits the Clockwork Nautilus, etched with concentric rings and sixteen razor-straight vanes. Any lattice mote that lands directly on a ring or a vane darkens instantly. Everywhere else, the Nautilus decides the pigment by a faint binary hum that depends on how deep the dust lies in the rings, which vane-wedge it falls into, and how many times both of its coordinates are divisible by \(2\).

For each lattice point \((x, y)\) with integer coordinates, determine whether the instrument stains it **"obsidian"** or leaves it **"chalk"**.

**Rules**

The plane rules are as follows:

- **Boundary points are always obsidian:**
  - Any point with integer Euclidean distance from the origin, i.e., when \(x^2 + y^2\) is a perfect square.
  - Any point on one of the sixteen guide rays given by the families  
    \[
    x = 0, \quad y = 0, \quad |x| = |y|, \quad |y| = 2|x|, \quad |x| = 2|y|.
    \]

- **For any non-boundary point \((x, y)\), define:**

  - **Ring index \(h\):**
    \[
    r2 = x^2 + y^2, \quad s = \lfloor \sqrt{r2} \rfloor.
    \]
    Since \((x, y)\) is not on an integer-radius circle, set  
    \[
    h = s + 1.
    \]

  - **Vane-wedge index \(p \in \{0, \ldots, 15\}\):**

    In each quadrant, the vanes at slopes \(0, \tfrac{1}{2}, 1, 2, \infty\) split it into four open wedges.

    Let \(ax = |x|\) and \(ay = |y|\). Determine a local band \(b \in \{0, 1, 2, 3\}\) using only strict integer comparisons (equalities never occur here because those cases are boundary rays):

    \[
    \begin{cases}
    b = 0, & \text{if } 2 \cdot ay < ax, \\
    b = 1, & \text{if } 2 \cdot ay \ge ax \text{ and } ay < ax, \\
    b = 2, & \text{if } ay \ge ax \text{ and } ay < 2 \cdot ax, \\
    b = 3, & \text{if } ay \ge 2 \cdot ax.
    \end{cases}
    \]

    Map \(b\) to the global wedge index \(p\) by the **quadrant of \((x, y)\):**

    \[
    \begin{cases}
    \text{Quadrant I } (x > 0, y > 0): & p = b, \\
    \text{Quadrant II } (x < 0, y > 0): & p = 4 + (3 - b), \\
    \text{Quadrant III } (x < 0, y < 0): & p = 8 + b, \\
    \text{Quadrant IV } (x > 0, y < 0): & p = 12 + (3 - b).
    \end{cases}
    \]

  - **Binary hum \(e\):**

    Let \(g = \gcd(|x|, |y|)\).  
    Define \(e\) as the exponent of \(2\) in \(g\) (the number of trailing zero bits of \(g\)).  
    The case \(g = 0\) occurs only at the origin, which is already a boundary.

- **Final rule:**
  \[
  \text{If } (h + p + e) \text{ is even, the mote becomes obsidian; otherwise it remains chalk.}
  \]

**Input Format**
- The first line contains an integer \(Q\) \((1 \le Q \le 200000)\), the number of queries.
- Each of the next \(Q\) lines contains two integers \(x\) and \(y\) \((|x|, |y| \le 10^{18})\).

**Output Format**
- For each query, print **"obsidian"** or **"chalk"** on its own line.


**Constraints**
- Do not use floating-point arithmetic.  
- You may assume that \(x^2 + y^2\) fits in unsigned 128-bit integer arithmetic.  
- All boundary points (on any of the sixteen vanes or on any integer-radius circle) are obsidian.


**Examples**

- **Input:**
```
6  
3 4  
3 4  
3 4  
5 2  
5 2  
5 2  
```

- **Output:**
```
obsidian  
obsidian  
obsidian  
obsidian  
obsidian  
obsidian  
```

- **Input:**
```
4  
21 13  
34 21  
-21 13  
21 -13  
```

- **Output:**
```
obsidian  
chalk  
chalk  
chalk  
```

**Note**

In the first example, the first three queries are \((3,4)\) repeated and the next three are \((5,2)\) repeated.

- For \((3,4)\):  
  \(3^2 + 4^2 = 25\) is a perfect square, so it lies on an integer-radius circle (a boundary).  
  Boundary points are always obsidian. Repetition yields the same result.

- For \((5,2)\):  
  \(r2 = 29\) is not a square and the point is not on any vane. Compute:
  \[
  s = \lfloor \sqrt{29} \rfloor = 5 \Rightarrow h = 6.
  \]
  \(ax = 5, ay = 2 \Rightarrow 2 \cdot ay = 4 < ax = 5 \Rightarrow b = 0.\)  
  In Quadrant I, \(p = b = 0.\)  
  \(\gcd(5,2) = 1 \Rightarrow e = 0.\)  
  Sum \(h + p + e = 6 + 0 + 0 = 6\) (even) ⇒ **obsidian**.  
  Repetition yields the same result.

In the second example, none of the four points are on vanes or integer-radius circles; we classify by \((h, p, e)\).

- \((21,13)\) in Quadrant I:  
  \(r2 = 610, 24^2 < 610 < 25^2 \Rightarrow h = 25.\)  
  \(b = 1\) since \(2 \cdot 13 = 26 \ge 21\) and \(13 < 21\).  
  \(p = 1\), \(e = 0.\)  
  Sum \(25 + 1 + 0 = 26\) (even) ⇒ **obsidian**.

- \((34,21)\) in Quadrant I:  
  \(r2 = 1597, 39^2 < 1597 < 40^2 \Rightarrow h = 40.\)  
  \(b = 1\), \(p = 1\), \(e = 0.\)  
  Sum \(40 + 1 + 0 = 41\) (odd) ⇒ **chalk**.

- \((-21,13)\) in Quadrant II:  
  Same \(r2 \Rightarrow h = 25\), same \(b = 1.\)  
  Quadrant II mapping: \(p = 4 + (3 - b) = 6.\)  
  \(e = 0.\)  
  Sum \(25 + 6 = 31\) (odd) ⇒ **chalk**.

- \((21,-13)\) in Quadrant IV:  
  Same \(r2 \Rightarrow h = 25\), same \(b = 1.\)  
  Quadrant IV mapping: \(p = 12 + (3 - b) = 14.\)  
  \(e = 0.\)  
  Sum \(25 + 14 = 39\) (odd) ⇒ **chalk**.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarifying the rules and objective precisely

**[THOUGHT_01_01]**

We must classify each integer lattice point \((x, y)\) as **“obsidian”** or **“chalk”** using a deterministic rule. The decision has two layers: a **boundary** layer that instantly returns obsidian for points on specific lines or on integer-radius circles, and a **parity** layer that uses \((h + p + e)\) for all remaining points, where \(h\) captures radial depth into concentric rings, \(p\) identifies the open wedge relative to sixteen guide rays, and \(e\) measures the \(2\)-adic valuation of the \(\gcd(|x|, |y|)\).


**[THOUGHT_01_02]**

The boundary set that is always obsidian comprises two parts. First, the sixteen guide rays formed by eight lines: \(x = 0\), \(y = 0\), \(y = x\), \(y = -x\), \(y = 2x\), \(y = -2x\), \(x = 2y\), and \(x = -2y\). These lines partition the plane into sixteen open wedges (four per quadrant). Second, all points at integer Euclidean distances from the origin, i.e., those with \(x^2 + y^2\) equal to a perfect square.


**[THOUGHT_01_03]**

For non-boundary points, the ring index \(h\) identifies the annulus in which the point lies. Let \(r2 = x^2 + y^2\) and \(s = \lfloor \sqrt{r2} \rfloor\). Because the point is not on an integer-radius circle, we set \(h = s + 1\). This can be interpreted as the smallest integer radius strictly greater than the actual radius.


**[THOUGHT_01_04]**

To identify the wedge index \(p\), use comparisons on absolute coordinates only. Let \(ax = |x|\) and \(ay = |y|\). Define a local band \(b \in \{0, 1, 2, 3\}\) by:
- \(b = 0\) if \(2ay < ax\),
- \(b = 1\) if \(2ay \ge ax\) and \(ay < ax\),
- \(b = 2\) if \(ay \ge ax\) and \(ay < 2ax\),
- \(b = 3\) if \(ay \ge 2ax\).

Then map \(b\) to the global wedge index \(p \in \{0,\ldots,15\}\) by quadrant:
- Quadrant I \((x > 0, y > 0)\): \(p = b\),
- Quadrant II \((x < 0, y > 0)\): \(p = 4 + (3 - b)\),
- Quadrant III \((x < 0, y < 0)\): \(p = 8 + b\),
- Quadrant IV \((x > 0, y < 0)\): \(p = 12 + (3 - b)\).

Equalities at the boundaries never occur here because they were already classified as boundary points.


**[THOUGHT_01_05]**

Compute \(g = \gcd(|x|, |y|)\) and let \(e = v_{2}(g)\), the exponent of \(2\) in \(g\) (the number of trailing zero bits of \(g\)). The final decision for non-boundary points is obsidian if \((h + p + e)\) is even, and chalk otherwise. The origin is boundary, so the case \(g = 0\) never reaches this stage.


---

**[CHAIN_02]**

Designing comprehensive test cases to exercise all rules

**[THOUGHT_02_01]**

Verify all boundary vanes by direct equalities. Include:
- Axis points: \((0, 0)\), \((0, 7)\), \((5, 0)\),
- Diagonals: \((3, 3)\), \((-9, 9)\), \((10, -10)\),
- Slope \(2\) lines: \((1, 2)\), \((-4, -8)\), \((5, -10)\),
- Slope \(1/2\) lines: \((2, 1)\), \((-6, -3)\), \((8, -4)\).
All must be obsidian due to being on guide rays.


**[THOUGHT_02_02]**

Validate perfect-square detection (integer-radius circles) with explicit outcomes:

- \((3,4)\): \(r^2=3^2+4^2=25=5^2\Rightarrow\) boundary ⇒ **obsidian**.  
- \((6,8)\): \(r^2=36+64=100=10^2\Rightarrow\) boundary ⇒ **obsidian**.  
- \((-9,12)\): \(r^2=81+144=225=15^2\Rightarrow\) boundary ⇒ **obsidian**.  
- Scaled triple (example): \((30,40)\): \(r^2=900+1600=2500=50^2\Rightarrow\) boundary ⇒ **obsidian**.


**[THOUGHT_02_03]**

Test wedge interiors very near boundaries, with concrete labels:

- Near-horizontal: \((10^{18},1)\).  
  Band: \(2|y|=2<|x|=10^{18}\Rightarrow b=0\). QI ⇒ \(p=0\).  
  \(r^2=(10^{18})^2+1\Rightarrow s=10^{18},\ h=s+1=10^{18}+1\) (odd), \(e=0\).  
  Parity: \(h+p+e\) odd ⇒ **chalk**.  
  Quadrant-II mirror \(( -10^{18}, 1)\): same \(h\), \(b=0\) but \(p=4+(3-0)=7\) (odd) ⇒ sum even ⇒ **obsidian**.

- Near diagonal: \((5,6)\).  
  \(2|y|=12\ge |x|=5,\ |y|=6\ge |x|=5,\ |y|<2|x|=10 \Rightarrow b=2\). QI ⇒ \(p=2\).  
  \(r^2=61,\ 7^2<61<8^2\Rightarrow h=8,\ e=\gcd(5,6)=1\Rightarrow e=0\).  
  Parity \(8+2+0=10\) even ⇒ **obsidian**.  
  Quadrant-II mirror \((-5,6)\): \(p=4+(3-2)=5\) ⇒ \(8+5=13\) odd ⇒ **chalk**.

- Near slope \(2\):  
  Above the line: \((3,7)\). \(2|y|=14\ge |x|=3,\ |y|\ge 2|x|=6\Rightarrow b=3\). QI ⇒ \(p=3\).  
  \(r^2=58,\ 7^2<58<8^2\Rightarrow h=8,\ e=0\). Parity \(8+3=11\) odd ⇒ **chalk**.  
  Below the line: \((3,5)\). \(2|y|=10\ge 3,\ |y|=5<2|x|=6\Rightarrow b=2\). QI ⇒ \(p=2\).  
  \(r^2=34,\ 5^2<34<6^2\Rightarrow h=6,\ e=0\). Parity \(6+2=8\) even ⇒ **obsidian**.


**[THOUGHT_02_04]**

Exercise \(2\)-adic variability for \(e\) with expected labels:

- Co-prime: \((7,11)\). \(r^2=170,\ 13^2<170<14^2\Rightarrow h=14\).  
  Band: \(2|y|=22\ge 7,\ |y|=11\ge 7,\ |y|<2|x|=14\Rightarrow b=2\). QI ⇒ \(p=2\).  
  \(\gcd=1\Rightarrow e=0\). Parity \(14+2+0=16\) even ⇒ **obsidian**.

- Higher power of two in gcd: \((24,40)\). \(r^2=2176,\ 46^2<2176<47^2\Rightarrow h=47\).  
  Band: \(2|y|=80\ge 24,\ |y|=40<2|x|=48\Rightarrow b=2\). QI ⇒ \(p=2\).  
  \(\gcd=8\Rightarrow e=3\). Parity \(47+2+3=52\) even ⇒ **obsidian**.

- Zeros (on guide rays; boundary): \((0,6)\), \((8,0)\) ⇒ **obsidian**.

- Adjacent non-boundary for contrast:  
  \((1,6)\): \(h=7,\ b=3,\ p=3,\ e=0\Rightarrow 7+3=10\) even ⇒ **obsidian**.  
  \((8,1)\): \(h=9,\ b=0,\ p=0,\ e=0\Rightarrow 9\) odd ⇒ **chalk**.


**[THOUGHT_02_05]**

Test parity sensitivity by controlled changes (state outcomes explicitly, no assumption of guaranteed flips):

- Vary \(h\) with fixed \(p,e\): \((8,1)\Rightarrow h=9,\ b=0,\ p=0,\ e=0\Rightarrow\) **chalk**;  
  \((9,1)\Rightarrow h=10,\ b=0,\ p=0,\ e=0\Rightarrow\) **obsidian** (alternation across annuli).

- Increase \(e\) by scaling both coordinates while keeping the same wedge \(p\):  
  \((8,1)\): **chalk** (above). Doubling → \((16,2)\): \(h=17,\ p=0,\ e=1\Rightarrow 17+0+1=18\) even ⇒ **obsidian**.  
  Note: Changing \(e\) via scaling can also change \(h\); the observed parity change results from the combined effect of \(h\) and \(e\), so compute the sum explicitly for each case.


**[THOUGHT_02_06]**

Large-magnitude and near-square correctness checks (no performance claims), with labels:

- \((10^{18},0)\): on \(x\)-axis (guide ray) ⇒ **obsidian**.  
- \((10^{18},10^{18})\): on diagonal \(|x|=|y|\) ⇒ **obsidian**.  
- \((10^{18},1)\): from **[THOUGHT_02_03]** ⇒ **chalk**; quadrant variants toggle \(p\) and can flip parity as shown.  
- Ring boundary neighbors: for any large \(n\), \((n,1)\) gives \(r^2=n^2+1\Rightarrow s=n,\ h=n+1\); with \(b=0,\ p\) by quadrant, \(\gcd=1\Rightarrow e=0\); label follows from parity \(h+p\) (e.g., QI ⇒ **chalk** when \(n\) is even, **obsidian** when \(n\) is odd).


---

**[CHAIN_03]**

Floating-point geometry baseline

**[THOUGHT_03_01]**

Start by computing \(r = \sqrt{x^2 + y^2}\) in floating point and set \(h = \lceil r \rceil\). Use \(\theta = \operatorname{atan2}(y, x)\) to determine the wedge index \(p\) by partitioning the angle range into sectors delimited by slopes \(0\), \(\tfrac{1}{2}\), \(1\), \(2\), and \(\infty\). Compute \(g = \gcd(|x|, |y|)\), derive \(e = v_2(g)\), and output the parity of \((h + p + e)\). This analysis targets \(O(1)\) time per query.


**[THOUGHT_03_02]**

Using \(\theta\) to decide wedge membership is fragile when points lie extremely close to the guide rays. For instance, \((10^{18}, 1)\) produces an angle so small that floating-point rounding can flip it across the wedge boundary, leading to an incorrect \(p\).


**[THOUGHT_03_03]**

Testing whether \(r\) is an integer using floating-point arithmetic is unreliable at large magnitudes. Since \(r^2\) may be just above or below a representable value, rounding can misclassify perfect squares, violating exactness.


**[THOUGHT_03_04]**

Although runtime is \(O(1)\) per query, rounding errors in both wedge classification and perfect-square tests make this approach unsuitable and it also violates the constraint to avoid floating-point arithmetic.


---

**[CHAIN_04]**

64-bit integer attempt with mixed-precision sqrt

**[THOUGHT_04_01]**

Compute \(r2 = x^2 + y^2\) in integers, then obtain \(s = \lfloor \sqrt{r2} \rfloor\) by converting \(r2\) to a floating type for \(\sqrt{\cdot}\) and casting back. Determine \(b\) and \(p\) via integer comparisons; compute \(g = \gcd(|x|, |y|)\) and obtain \(e\) by counting trailing zeros. Intended per-query time remains \(O(1)\).


**[THOUGHT_04_02]**

Identify overflow in \(r2\) with 64-bit arithmetic. With \(|x|, |y| \le 10^{18}\), squaring exceeds 64-bit limits: \(10^{18} \cdot 10^{18} = 10^{36}\), far greater than \(2^{64}\). Thus, storing \(x^2\), \(y^2\), or their sum in 64-bit overflows, corrupting the result.


**[THOUGHT_04_03]**

Even if \(r2\) were widened first, converting to \(\text{double}\) or \(\text{long double}\) to compute \(\sqrt{\cdot}\) cannot guarantee exactness for large integers, resulting in off-by-one errors in \(s\) and misclassification of perfect squares and ring indices.


**[THOUGHT_04_04]**

Conclusion: While this avoids floating-point angles, it fails to address overflow and relies on inexact square roots; correctness is not guaranteed for large inputs, so this approach must be discarded.

---

**[CHAIN_05]**

Refactoring wedge classification using exact integer comparisons

**[THOUGHT_05_01]**

Eliminate angle computations entirely by using integer-only comparisons to determine the local band \(b\). Compare \(2ay\) with \(ax\), \(ay\) with \(ax\), and \(ay\) with \(2ax\). Since all equality cases are resolved by earlier boundary checks, exactly one strict inequality holds, making \(b\) well-defined.


**[THOUGHT_05_02]**

Translate the local band into a global wedge index \(p\) based on the quadrant. The mapping
- Quadrant I: \(p = b\),
- Quadrant II: \(p = 4 + (3 - b)\),
- Quadrant III: \(p = 8 + b\),
- Quadrant IV: \(p = 12 + (3 - b)\)

creates a consistent enumeration of the sixteen wedges with exact integer arithmetic and no divisions.


**[THOUGHT_05_03]**

Compute the \(2\)-adic component \(e\) precisely using \(g = \gcd(|x|, |y|)\) and the trailing-zero count \(e = v_{2}(g)\). This step is exact, fast, and independent of the wedge logic. It respects symmetries under sign changes and scaling by odd constants, aligning with the intended behavior.


**[THOUGHT_05_04]**

The remaining piece is the ring index \(h\) and the perfect-square boundary. Use a \(128\)-bit integer square root to evaluate \(s = \lfloor \sqrt{r2} \rfloor\) for \(r2 = x^2 + y^2\), check \(s^2 = r2\) to detect the boundary, and set \(h = s + 1\) otherwise. Combine \(h\), \(p\), and \(e\) and classify by the parity of \((h + p + e)\).

**Complexity:** All steps are constant-time per query; overall **\(O(1)\)** per query.


---

**[CHAIN_06]**

Adopting 128-bit arithmetic and implementing an integer square root

**[THOUGHT_06_01]**

Compute \(r2 = x^2 + y^2\) using unsigned 128-bit arithmetic to avoid overflow. Since \(x^2 + y^2 \le 2 \cdot 10^{36}\), the 128-bit range suffices. This guarantees exact intermediate values for robust perfect square checks.


**[THOUGHT_06_02]**

Implement a bitwise integer square root for 128-bit inputs. Use a classic method that identifies the highest power-of-four less than or equal to \(r2\) and iteratively refines the result. The algorithm is deterministic, exact, and runs in \(O(\log 128)\) steps, effectively constant per query.


**[THOUGHT_06_03]**

Order the decision pipeline to short-circuit early on boundaries. First, test vane equalities using integer comparisons: \(x = 0\), \(y = 0\), \(|x| = |y|\), \(|y| = 2|x|\), \(|x| = 2|y|\). Second, compute \(r2\) and \(s = \lfloor \sqrt{r2} \rfloor\), and if \(s^2 = r2\), return obsidian. Only then proceed to compute \((h, p, e)\).


**[THOUGHT_06_04]**

Set \(h = s + 1\), determine \(b\) via strict inequalities, map to \(p\) based on the quadrant, compute \(g = gcd(|x|, |y|)\), and set \(e = v_2(g)\) using a trailing-zero count. Output obsidian if \((h + p + e)\) is even, chalk otherwise.


**[THOUGHT_06_05]**

A handful of comparisons, a 128-bit integer sqrt with a fixed small number of iterations, a 64-bit gcd, and parity checks. Time per query is \(O(1)\) with small constants; space usage is \(O(1)\). This meets the constraints for \(Q \le 200000\).


---

**[CHAIN_07]**

Validating correctness with invariants and edge-case reasoning

**[THOUGHT_07_01]**

Establish that wedge equalities are fully removed by boundary checks. Any point with \(ax = 0\), \(ay = 0\), \(ax = ay\), \(ay = 2 \cdot ax\), or \(ax = 2 \cdot ay\) is immediately flagged as obsidian. Therefore, in wedge classification, equalities cannot occur and the local band \(b\) is uniquely determined by strict inequalities.


**[THOUGHT_07_02]**

For non-perfect-square \(r2\), the real radius satisfies \(s < \sqrt{r2} < s + 1\) with \(s = \lfloor \sqrt{r2} \rfloor\). Thus, the integer ring index that begins strictly after the actual radius is \(h = s + 1\), consistent with the annuli structure.


**[THOUGHT_07_03]**

The thresholds \(0\), \(\tfrac{1}{2}\), \(1\), \(2\), and \(\infty\) partition each quadrant into four wedges. The mapping formulas for \(p\) yield a bijection across sixteen wedges and ensure continuity when crossing axes or diagonals, preserving rotational and reflectional symmetry.


**[THOUGHT_07_04]**

Since \(e = v_2(g)\) with \(g = gcd(|x|, |y|)\), sign changes have no effect, and multiplication by an odd factor does not change \(e\). Multiplying both coordinates by \(2\) increases \(e\) by 1, matching the intended binary hum characteristic.


**[THOUGHT_07_05]**

The origin \((0, 0)\) satisfies both vane and perfect-square boundaries (\(r2 = 0\)), so it is obsidian without invoking \(e\). Axis points are vanes. The algorithm never attempts to count trailing zeros of zero in the non-boundary path.


---

**[CHAIN_08]**

Compiling an implementation checklist with minimal code anchors

**[THOUGHT_08_01]**

Enumerate the exact numeric primitives to implement:
- A 128-bit integer square root function returning \(\lfloor \sqrt{n} \rfloor\) for \(0 \le n < 2^{128}\),
- A gcd function on 64-bit absolute values \(|x|\) and \(|y|\),
- A trailing-zero counter for a 64-bit integer to compute \(e = v_2(g)\).


**[THOUGHT_08_02]**

Lay out the precise decision pipeline:
1) Read \(x, y\); compute \(ax = |x|\), \(ay = |y|\).
2) Test vane equalities using exact integer comparisons: \(x = 0\), \(y = 0\), \(ax = ay\), \(ay = 2 \cdot ax\), \(ax = 2 \cdot ay\).
3) Compute \(r2 = ax^2 + ay^2\) using 128-bit; compute \(s = \lfloor \sqrt{r2} \rfloor\). If \(s^2 = r2\), output "obsidian".
4) Set \(h = s + 1\).
5) Determine \(b\) via strict comparisons; map to \(p\) via quadrant signs.
6) Compute \(g = gcd(ax, ay)\) and \(e = v_2(g)\).
7) Output "obsidian" if \((h + p + e)\) is even; otherwise "chalk".


**[THOUGHT_08_03]**

Avoid 64-bit overflow by casting to 128-bit before squaring \(ax\) and \(ay\). Use integer-only comparisons for wedge logic. Avoid floating-point anywhere. While \(2 \cdot 10^{18}\) fits within signed 64-bit, prefer consistent casting for comparisons like \(ay < 2 \cdot ax\) to prevent accidental signed overflow or promotion issues.


**[THOUGHT_08_04]**

List common pitfalls and how to avoid them:
- Do not compute \(x^2\) or \(y^2\) in 64-bit; cast to 128-bit first.
- Do not use floating-point sqrt or equality checks for perfect squares.
- Always short-circuit boundary detections before wedge logic to eliminate equality cases.
- Do not call trailing-zero routines on zero; the origin is filtered by boundary checks and should not reach this step.

---

**[RESPONSE]**

**1. Problem Understanding**

We must classify each integer lattice point \((x, y)\) as "obsidian" or "chalk" according to deterministic geometric rules. The classification has two layers:
- Boundary layer (always obsidian):
  - Points on any of the sixteen guide rays: \(x = 0\), \(y = 0\), \(|x| = |y|\), \(|y| = 2|x|\), \(|x| = 2|y|\).
  - Points at integer Euclidean distance from the origin, i.e., when \(x^2 + y^2\) is a perfect square.
- Interior layer (points not on the boundary):
  - Compute the ring index \(h\): let \(r2 = x^2 + y^2\), \(s = \lfloor \sqrt{r2} \rfloor\). Since the point is not on a ring, set \(h = s + 1\).
  - Compute the wedge index \(p \in \{0..15\}\):
    - Let \(ax = |x|\) and \(ay = |y|\). Determine the local band \(b \in \{0, 1, 2, 3\}\) by strict comparisons:
      - \(b = 0\) if \(2 \cdot ay < ax\),
      - \(b = 1\) if \(2 \cdot ay \ge ax\) and \(ay < ax\),
      - \(b = 2\) if \(ay \ge ax\) and \(ay < 2 \cdot ax\),
      - \(b = 3\) if \(ay \ge 2 \cdot ax\).
    - Map to global \(p\) by quadrant:
      - Quadrant I \((x > 0, y > 0)\): \(p = b\),
      - Quadrant II \((x < 0, y > 0)\): \(p = 4 + (3 - b)\),
      - Quadrant III \((x < 0, y < 0)\): \(p = 8 + b\),
      - Quadrant IV \((x > 0, y < 0)\): \(p = 12 + (3 - b)\).
  - Compute the binary hum \(e\): let \(g = gcd(|x|, |y|)\), then \(e\) is the exponent of 2 in \(g\) (number of trailing zero bits).
  - Final rule: the point is obsidian if \((h + p + e)\) is even; otherwise chalk.

Key observations:
- Boundary checks remove all equality cases before the wedge classification, so wedge comparisons are strict and unambiguous.
- Integer arithmetic is mandatory; floating point must be avoided to ensure exactness on large inputs.
- Computing \(x^2 + y^2\) requires 128-bit unsigned integers to avoid overflow for \(|x|, |y| \le 10^{18}\).
- An integer square root on 128-bit values is required to test for perfect squares and to obtain \(\lfloor \sqrt{r2} \rfloor\).


**2. Optimal Approach**

We use integer-only arithmetic with 128-bit intermediates and a bitwise integer square root.

Step 1: Boundary rays
- Check vanes using exact integer equalities:
  - \(x = 0\) or \(y = 0\),
  - \(|x| = |y|\),
  - \(|y| = 2|x|\),
  - \(|x| = 2|y|\).
- If true, output "obsidian".

Step 2: Integer-radius circles
- Compute \(r2 = x^2 + y^2\) in unsigned 128-bit.
- Compute \(s = \lfloor \sqrt{r2} \rfloor\) via a bit-by-bit integer square root.
- If \(s \cdot s = r2\), output "obsidian".

Step 3: Ring index
- For non-boundary points, set \(h = s + 1\).

Step 4: Wedge index
- Let \(ax = |x|\), \(ay = |y|\).
- Compute local band \(b\) by strict comparisons using only integers.
- Map \(b\) to global index \(p\) by the quadrant of \((x, y)\).

Step 5: Binary hum
- Compute \(g = gcd(ax, ay)\).
- Let \(e\) be the number of trailing zero bits of \(g\).

Step 6: Final decision
- If \((h + p + e)\) is even, print "obsidian"; else "chalk".

This approach is exact, requires no floating-point operations, and runs in constant time per query with small constants.


**3. Code**
```cpp
#include <iostream>
#include <string>
#include <numeric>
#include <cstdint>

/**
 * @brief Initial shift for the restoring-sqrt algorithm.
 *
 * We start from the highest power of four that fits under 2^128:
 * 4^63 = 2^126, so the corresponding bit is (1u << 126).
 * Starting here lets us "pull down" two bits at a time in the classic
 * digit-by-digit (restoring) integer square root algorithm.
 */
static constexpr int kHighestPowerOfFourShift = 126;

/**
 * @brief Computes floor(sqrt(n)) for 0 <= n < 2^128 using integer arithmetic.
 *
 * This is a restoring square-root algorithm specialized for base-2 digits,
 * advancing two bits per loop (powers of four).
 *
 * @param n The 128-bit unsigned integer whose integer square root is required.
 * @return The floor of the square root as a 64-bit unsigned integer.
 */
static uint64_t floorSqrt128(__uint128_t n) {
    if (n == 0) return 0;

    __uint128_t result = 0;
    __uint128_t bit = __uint128_t(1) << kHighestPowerOfFourShift; // highest power of four <= 2^126

    // Align starting 'bit' to the largest power-of-four <= n.
    while (bit > n) bit >>= 2;

    // Classic restoring square root loop (two bits per iteration).
    while (bit != 0) {
        if (n >= result + bit) {
            n      -= result + bit;
            result  = (result >> 1) + bit;
        } else {
            result >>= 1;
        }
        bit >>= 2;
    }
    return static_cast<uint64_t>(result);
}

/**
 * @brief Tests whether a 128-bit integer is a perfect square (exactly).
 *
 * @param n The 128-bit unsigned integer to test.
 * @return True if n is a perfect square; false otherwise.
 */
static bool isPerfectSquare128(__uint128_t n) {
    uint64_t s = floorSqrt128(n);
    return (__uint128_t)s * (__uint128_t)s == n;
}

/**
 * @brief Classifies a lattice point according to the Clockwork Nautilus rule.
 *
 * Boundary points (on guide rays or integer-radius circles) are always "obsidian".
 * Non-boundary points use the parity of (h + p + e):
 *  - h: ring index (1 + floor(sqrt(x^2 + y^2)) for non-squares)
 *  - p: wedge index in {0..15} based on quadrant and band
 *  - e: exponent of 2 in gcd(|x|, |y|)
 *
 * @param x The x-coordinate (signed 64-bit).
 * @param y The y-coordinate (signed 64-bit).
 * @return "obsidian" if the point is darkened; otherwise "chalk".
 */
static std::string classifyLatticePoint(long long x, long long y) {
    // Absolute values as unsigned, to avoid UB on LLONG_MIN (not needed here but clean).
    uint64_t absX = (x >= 0) ? static_cast<uint64_t>(x) : static_cast<uint64_t>(-x);
    uint64_t absY = (y >= 0) ? static_cast<uint64_t>(y) : static_cast<uint64_t>(-y);

    // ---- Boundary check: guide rays (axes, |x|=|y|, |y|=2|x|, |x|=2|y|) ----
    bool isOnGuideRay = false;
    if (x == 0 || y == 0 || absX == absY) {
        isOnGuideRay = true;
    } else {
        // Use 128-bit to keep comparisons crystal clear at extreme magnitudes.
        __uint128_t ax128 = (__uint128_t)absX;
        __uint128_t ay128 = (__uint128_t)absY;
        if (ay128 == (ax128 << 1) || ax128 == (ay128 << 1)) {
            isOnGuideRay = true;
        }
    }
    if (isOnGuideRay) {
        return "obsidian";
    }

    // ---- Boundary check: integer-radius circle (x^2 + y^2 is a perfect square) ----
    __uint128_t ax128 = (__uint128_t)absX;
    __uint128_t ay128 = (__uint128_t)absY;
    __uint128_t radiusSquared = ax128 * ax128 + ay128 * ay128;

    if (isPerfectSquare128(radiusSquared)) {
        return "obsidian";
    }

    // ---- Non-boundary classification ----

    // Ring index h = floor(sqrt(r2)) + 1 for non-squares.
    uint64_t floorSqrt = floorSqrt128(radiusSquared);
    uint64_t ringIndex = floorSqrt + 1;

    // Local band b ∈ {0,1,2,3} using strict inequalities:
    // b=0: 2*|y| < |x|
    // b=1: 2*|y| >= |x| and |y| < |x|
    // b=2: |y| >= |x| and |y| < 2*|x|
    // b=3: |y| >= 2*|x|
    int localBand = 0;
    {
        __uint128_t twoAbsY = ay128 << 1;
        if (twoAbsY < ax128) {
            localBand = 0;
        } else if (ay128 < ax128) {
            localBand = 1;
        } else if (ay128 < (ax128 << 1)) {
            localBand = 2;
        } else {
            localBand = 3;
        }
    }

    // Quadrant index (QI=0, QII=1, QIII=2, QIV=3); axes already handled as boundary.
    int quadrantIndex = 0;
    if      (x > 0 && y > 0) quadrantIndex = 0;  // QI
    else if (x < 0 && y > 0) quadrantIndex = 1;  // QII
    else if (x < 0 && y < 0) quadrantIndex = 2;  // QIII
    else                     quadrantIndex = 3;  // QIV (x>0 && y<0)

    // Global wedge index p in {0..15}.
    int wedgeIndex;
    if (quadrantIndex == 0) {
        wedgeIndex = localBand;                      // QI
    } else if (quadrantIndex == 1) {
        wedgeIndex = 4 + (3 - localBand);           // QII
    } else if (quadrantIndex == 2) {
        wedgeIndex = 8 + localBand;                 // QIII
    } else {
        wedgeIndex = 12 + (3 - localBand);          // QIV
    }

    // Binary hum e = v2(gcd(|x|, |y|)) (exponent of 2 in the gcd).
    uint64_t g = std::gcd(absX, absY);
    int twoAdicExponent = (g == 0) ? 0 : __builtin_ctzll(g);

    // Final parity: obsidian iff (h + p + e) is even.
    uint64_t paritySum = ringIndex + static_cast<uint64_t>(wedgeIndex) + static_cast<uint64_t>(twoAdicExponent);
    return ((paritySum & 1ULL) == 0ULL) ? "obsidian" : "chalk";
}

/**
 * @brief Program entry point: reads queries and prints classifications.
 *
 * Input:
 *   Q
 *   x y   (repeated Q times)
 *
 * Output:
 *   "obsidian" or "chalk" per line.
 *
 * @return 0 on normal termination.
 */
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int queryCount;
    if (!(std::cin >> queryCount)) {
        return 0;
    }

    while (queryCount--) {
        long long xCoord, yCoord;
        std::cin >> xCoord >> yCoord;
        std::string answer = classifyLatticePoint(xCoord, yCoord);
        std::cout << answer << '\n';
    }
    return 0;
}
```

**4. Code Explanation**

The solution works entirely with exact integer arithmetic:
- Boundary detection:
  - Vanes: Check integer equalities \(x = 0\), \(y = 0\), \(|x| = |y|\), \(|y| = 2|x|\), \(|x| = 2|y|\). If true, return "obsidian".
  - Integer-radius circles: Compute \(r2 = x^2 + y^2\) in unsigned 128-bit. Compute \(s = \lfloor \sqrt{r2} \rfloor\) via a bit-by-bit integer square root. If \(s^2 = r2\), return "obsidian".
- Interior classification:
  - Ring index: \(h = s + 1\).
  - Wedge index: Determine local band \(b \in \{0,1,2,3\}\) using strict integer comparisons of \(ax\), \(ay\), \(2 \cdot ax\), \(2 \cdot ay\). Map \(b\) to global \(p \in \{0..15\}\) by quadrant.
  - Binary hum: Compute \(g = gcd(|x|, |y|)\); set \(e\) to the number of trailing zero bits of \(g\).
  - Final decision: Output "obsidian" if \((h + p + e)\) is even; otherwise "chalk".

Example execution:
- Input \((1, 2)\): On the vane \(|y| = 2|x|\), so output "obsidian".
- Input \((7, 3)\): Not on a vane or integer-radius circle. \(r2 = 58\), \(s = 7\), \(h = 8\). With \(ax = 7\), \(ay = 3\), we have \(2 \cdot ay = 6 < ax\), so \(b = 0\) and in Quadrant I, \(p = 0\). \(g = 1\), \(e = 0\). Sum \(= 8\), even → "obsidian".

**5. Time and Space Complexity**

- Per query operations:
  - Boundary vane checks: \(O(1)\).
  - 128-bit integer square root: \(O(\log 128)\) iterations, effectively \(O(1)\).
  - GCD and trailing-zero count on 64-bit values: \(O(1)\).
  - Wedge and parity computations: \(O(1)\).
- Total time: \(O(Q)\) with a small constant per query.
- Space: \(O(1)\) auxiliary memory.

**6. Conclusion**

By combining exact boundary detection, a 128-bit integer square root, wedge determination via integer-only comparisons, and 2-adic valuation of the gcd, the algorithm classifies all points precisely and efficiently. It avoids floating-point arithmetic, handles extreme coordinate magnitudes safely, and runs in constant time per query, satisfying the problem constraints.