# Metadata

**Category:** - Coding  

**Topic:** - Competitive Programming  

**Subtopic:** - ["Greedy Algorithms", "Sorting Algorithms", "Searching Algorithms", "Heaps and Priority Queues", "Arrays and Lists", "Basic Data Structures", "Algorithm Complexity and Big O Notation"]

**Difficulty:** - Hard  

**Languages:** - C++  

**Number of Approaches:** - $3$, ($O(2^n)$ → $O(n \log n)$ → $O((n + s) \log n)$)  

**Number of Chains:** - $9$  

**GitHub URL:** https://github.com/NOI-gen/the_keepers_chorus_tiered_hush_around_the_citadel_2


---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**The Keeper’s Chorus — Tiered Hush Around the Citadel**

Time Limit: **2 seconds**

Memory Limit: **10 MB**

In the old city, the Citadel at coordinate $C$ is revered. Choirs sing over integer intervals, and some choirs are royal guilds that must never be silenced. The Keeper of Sound wants the Citadel’s song to be strictly more resonant than anywhere else by a distance-dependent margin. You may hush private choirs, but never royal ones. If it is possible, hush as few private choirs as necessary; otherwise, report impossibility.

Formally:
- There are $n$ choirs. The $i$-th choir sings on every integer position in $[L_i, R_i]$ (inclusive).
- Each choir has type $T_i$:
  - $T_i = 1$ means Royal Guild (locked; cannot be hushed),
  - $T_i = 0$ means Private (may be hushed).
- Define a stepwise, nonincreasing “required advantage” function $A(d)$ for integer distances $d \ge 1$:
  - You are given $s$ increasing radii $D_1 < D_2 < \dots < D_s$,
  - And $s+1$ nonincreasing levels $a_1 \ge a_2 \ge \dots \ge a_{s+1}$, each an integer $\ge 0$,
  - Interpretation for an integer position $y$ at distance $d = |y - C|$:
    - If $1 \le d \le D_1$, the Citadel must be ahead by $a_1$,
    - If $D_1 < d \le D_2$, ahead by $a_2$, …,
    - If $d > D_s$, ahead by $a_{s+1}$.
- Let $\mathrm{sing}(x)$ be the number of kept choirs covering position $x$.
- The Citadel $C$ is tier-dominant if for every integer $y \ne C$:
  $$\mathrm{sing}(C) \ge \mathrm{sing}(y) + A(|y - C|).$$
- You may hush any subset of private choirs ($T_i = 0$). Royal choirs ($T_i = 1$) must stay.
- Find the minimum number of private choirs to hush so that $C$ becomes tier-dominant. If it is impossible, output $-1$.

**Input Format:-**

- The first line contains an integer $t$ — the number of test cases.
- For each test case:
  - The first line contains integers $n$, $C$, $s$.
  - The next $s$ lines each contain two integers $D_j$ and $a_j$ for $1 \le j \le s$, with $D_1 < D_2 < \dots < D_s$.
  - The next line contains a single integer $a_{s+1}$.
  - The next $n$ lines each contain three integers $L_i$, $R_i$, $T_i$ — the interval and type of the $i$-th choir.

All intervals are inclusive, and all positions are integers.

**Output Format:-**

For each test case, output a single integer — the minimum number of private choirs to hush so that the Citadel is tier-dominant, or $-1$ if it is impossible.

**Constraints:-**

- $1 \le t \le 2 \cdot 10^5$
- $1 \le n \le 2 \cdot 10^5$ per test
- $\sum n \le 2 \cdot 10^5$ over all tests
- $\sum s \le 2 \cdot 10^5$ over all tests
- $1 \le L_i \le R_i \le 10^9$
- $1 \le C \le 10^9$
- $1 \le D_1 < D_2 < \dots < D_s \le 10^9$
- $0 \le a_1 \ge a_2 \ge \dots \ge a_{s+1} \le 2 \cdot 10^5$
- $T_i \in \{0, 1\}$
**Examples:-**
 - **Input:**
```
1
3 10 2
2 1
4 1
0
10 10 1
12 12 0
13 13 0
```

 - **Output:**
```
2
```

 - **Input:**
```
1
2 10 3
1 2
2 2
3 2
2
1 1 0
19 19 1
```

 - **Output:**
```
-1
```

**Note:-**
  
In the first example, $A(d)=1$ for $1 \le d \le 4$ and $A(d)=0$ for $d>4$. Only the royal choir covers $C=10$, so $\mathrm{sing}(C)=1$. The private choirs at $y=12$ and $y=13$ each give $\mathrm{sing}(y)=1$ with $|y-C|=2,3$, so the requirement $1 \ge 1 + 1$ fails at both points. Hushing both private choirs makes $\mathrm{sing}(y)=0$ everywhere, hence for $d \le 4$ we get $1 \ge 0 + 1$ and for $d>4$ we get $1 \ge 0$, so the minimum is $2$.

In the second example, $A(d)=2$ for all $d \ge 1$. No choir covers $C=10$, so $\mathrm{sing}(C)=0$. The royal choir at $y=19$ forces $\mathrm{sing}(19)=1$ with $|19-10|=9$, and the inequality $0 \ge 1 + 2$ cannot be satisfied. Since royal choirs cannot be hushed and no choir can increase $\mathrm{sing}(C)$, the answer is $-1$.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarify the objective and constraints precisely.

**[THOUGHT_01_01]**  
We are given $n$ inclusive integer intervals $[L_i, R_i]$ (choirs) and a distinguished coordinate $C$. Each kept interval contributes $1$ to $\mathrm{sing}(x)$ for every integer $x \in [L_i, R_i]$. Each choir has type $T_i \in \{0,1\}$: $T_i=1$ (Royal) cannot be hushed; $T_i=0$ (Private) may be hushed. The goal is to make the Citadel tier-dominant:
$$
\mathrm{sing}(C) \;\ge\; \mathrm{sing}(y) + A(|y-C|)\quad\text{for all integers }y\ne C,
$$
minimizing the number of hushed Private choirs, or report $-1$ if impossible.



**[THOUGHT_01_02]**  
The required advantage $A(d)$ is a stepwise nonincreasing function for integer $d\ge 1$: we are given radii $1\le D_1<\dots<D_s$ and levels $a_1\ge a_2\ge\dots\ge a_{s+1}\ge 0$. The interpretation is
$$
A(d)=
\begin{cases}
a_1,& 1\le d\le D_1,\\
a_2,& D_1< d\le D_2,\\
\vdots\\
a_{s+1},& d>D_s.
\end{cases}
$$
All positions and endpoints are integers; intervals are inclusive.



**[THOUGHT_01_03]**

It is natural to distinguish **Core** intervals (those covering $C$) from **Outer** intervals (those not covering $C$). Core intervals raise $\mathrm{sing}(C)$ and may also cover some $y\ne C$; Outer intervals never cover $C$ but can increase $\mathrm{sing}(y)$ elsewhere. The dominance condition must hold simultaneously for all $y\ne C$.

---

**[CHAIN_02]**

Design comprehensive test cases to exercise corner conditions.

**[THOUGHT_02_01]**  

No-Outer baseline

- Parameters: $n=2$, $C=10$, $s=1$, $(D_1,a_1)=(2,1)$, $a_{2}=0$.
- Intervals (all cover $C$): $[8,10]$ with $T=1$, and $[10,14]$ with $T=0$.
- For $y\ne C$: $\mathrm{sing}(C)=2$.  
  - At $y=9$: covered by only $[8,10]$ so $\mathrm{sing}(9)=1$; $A(1)=1$; check $2\ge 1+1$ holds.  
  - At $y=11$: covered by only $[10,14]$ so $\mathrm{sing}(11)=1$; $A(1)=1$; check $2\ge 1+1$ holds.  
  - For $|y-C|\ge 3$: $A(d)=0$ and $\mathrm{sing}(y)\le 1$, so $2\ge \mathrm{sing}(y)$ holds.
- Expected answer: $0$ (already dominant everywhere).



**[THOUGHT_02_02]**  

Nearest-neighbor impossibility

- Parameters: $n=1$, $C=10$, $s=1$, $(D_1,a_1)=(1,2)$, $a_{2}=2$.
- Interval: $[10,10]$ with $T=1$. Then $\mathrm{sing}(C)=1$.
- At $y=11$: $\mathrm{sing}(11)=0$, but $A(1)=2$, so we require $1\ge 0+2$, which is false.
- Since no interval can increase $\mathrm{sing}(C)$ and the single interval is royal, the violation cannot be corrected.
- Expected answer: $-1$.



**[THOUGHT_02_03]**  

Royal pressure (forced overflow away from $C$)

- Parameters: $n=2$, $C=10$, $s=1$, $(D_1,a_1)=(5,1)$, $a_{2}=1$.
- Intervals: $[9,11]$ with $T=1$ (covers $C$), and $[18,18]$ with $T=1$ (royal away from $C$).
- Values: $\mathrm{sing}(C)=1$. At $y=18$: $\mathrm{sing}(18)=1$, and $A(|18-10|)=A(8)=1$.
- Requirement at $y=18$: $1\ge 1+1$ is false. Royals cannot be removed, and nothing increases $\mathrm{sing}(C)$.
- Expected answer: $-1$.



**[THOUGHT_02_04]**  

Multiple step transitions

- Parameters: $n=4$, $C=10$, $s=2$, $(D_1,a_1)=(2,2)$, $(D_2,a_2)=(5,1)$, $a_{3}=0$.
- Intervals: $[10,10]$ with $T=1$, $[9,12]$ with $T=0$, $[7,7]$ with $T=0$, $[15,15]$ with $T=0$.
- Values: $\mathrm{sing}(C)=2$.
  - At $y=9$: only $[9,12]$ covers, so $\mathrm{sing}(9)=1$; with $A(1)=2$, we need $2\ge 1+2$ (false).
  - At $y=11$: only $[9,12]$ covers, so $\mathrm{sing}(11)=1$; need $2\ge 1+2$ (false).
- If $[9,12]$ is removed, then $\mathrm{sing}(C)=1$ and at $y=9$ we need $1\ge 0+2$ (false). The other intervals do not change these failures at $d=1$.
- **Expected answer:** $-1$.



**[THOUGHT_02_05]**

Symmetry vs. skew

- **Symmetric case (unchanged):**
  - Parameters: $n=3$, $C=0$, $s=1$, $(D_1,a_1)=(3,1)$, $a_{2}=0$.
  - Intervals: $[-2,0]$ with $T=1$, $[0,2]$ with $T=1$, $[-1,1]$ with $T=0$.
  - $\mathrm{sing}(0)=3$; for $|y|\le 3$, $A(d)=1$ and $\mathrm{sing}(y)\le 2$ so $3\ge \mathrm{sing}(y)+1$; for $|y|>3$, $A(d)=0$ and $\mathrm{sing}(y)\le 1$ so $3\ge \mathrm{sing}(y)$.
  - **Expected answer:** $0$.
- **Skewed case (corrected):**
  - Parameters: $n=3$, $C=0$, $s=1$, $(D_1,a_1)=(2,1)$, $a_{2}=0$.
  - Intervals: $[0,3]$ with $T=1$, $[0,3]$ with $T=0$, $[3,3]$ with $T=0$.
  - $\mathrm{sing}(0)=2$. At $y=1$: $\mathrm{sing}(1)=2$ and $A(1)=1$, requiring $2\ge 2+1$ (false).
  - Removing the private $[0,3]$ gives $\mathrm{sing}(0)=1$ and at $y=1$ still $1\ge 1+1$ (false). The point $[3,3]$ does not affect $y=1$. No change increases $\mathrm{sing}(0)$.
  - **Expected answer:** $-1$.



**[THOUGHT_02_06]**  

Large coordinates, sparse events

- Parameters: $n=2$, $C=10^9$, $s=1$, $(D_1,a_1)=(10^6,1)$, $a_{2}=0$.
- Intervals: $[10^9-2,\,10^9-2]$ with $T=1$, and $[10^9+10^6+5,\,10^9+10^6+5]$ with $T=0$.
- Values: $\mathrm{sing}(C)=0$.  
  - At $y=10^9-2$: $\mathrm{sing}(y)=1$, $|y-C|=2\le 10^6$, so $A=1$; need $0\ge 1+1$ false. The point interval is royal, so it cannot be removed and nothing increases $\mathrm{sing}(C)$.
- Expected answer: $-1$.



**[THOUGHT_02_07]**  

Overlapping starts with different ends

- Parameters: $n=4$, $C=50$, $s=1$, $(D_1,a_1)=(3,1)$, $a_{2}=0$.
- Intervals: $[49,55]$ with $T=1$; and $[50,52]$, $[50,53]$, $[50,60]$ with $T=0$.
- $\mathrm{sing}(C)=4$. At $y=51$: all four cover, so $\mathrm{sing}(51)=4$ with $A(1)=1$, requiring $4\ge 4+1$ (false).
- Any removal among these privates also reduces $\mathrm{sing}(C)$ (they all cover $C$), and the same near failures persist: with one removed, $3\ge 3+1$ (false); with two removed, $2\ge 2+1$ (false); with all removed, $1\ge 1+1$ (false).
- **Expected answer:** $-1$.



**[THOUGHT_02_08]**  

Boundary/equality cases

- **Case A ($a_{s+1}=0$ far-field, unchanged):**
  - Parameters: $n=2$, $C=0$, $s=1$, $(D_1,a_1)=(1,1)$, $a_{2}=0$.
  - Intervals: $[0,0]$ with $T=1$, $[2,2]$ with $T=0$.
  - Near: $y=\pm 1$ gives $1\ge 0+1$ (true). Far: $y=2$ gives $1\ge 1$ (true).
  - **Expected answer:** $0$.
- **Case B (expiry at $R+1$, corrected):**
  - Parameters: $n=2$, $C=5$, $s=1$, $(D_1,a_1)=(1,1)$, $a_{2}=0$.
  - Intervals: $[4,5]$ with $T=1$, $[6,6]$ with $T=0$.
  - $\mathrm{sing}(5)=1$. At $y=4$: $\mathrm{sing}(4)=1$ and $A(1)=1$, requiring $1\ge 1+1$ (false). This failure exists independently of the private at $y=6$.
  - **Expected answer:** $-1$.
- **Case C (zero hush vs. both near-offenders, unchanged):**
  - Parameters: $n=3$, $C=10$, $s=1$, $(D_1,a_1)=(2,1)$, $a_{2}=0$.
  - Intervals: $[10,10]$ with $T=1$, $[12,12]$ with $T=0$, $[13,13]$ with $T=0$.
  - At $y=12$: $1\ge 1+1$ (false); at $y=13$: $1\ge 1$ (true). Removing the private at $12$ resolves all checks. Variant with offenders at $11$ and $12$ requires removing both.
  - **Expected answers:** $1$ for the stated instance; $2$ for the variant with two near-offenders.

---

**[CHAIN_03]**

Implement brute force.

**[THOUGHT_03_01]**

A naive idea is to try all subsets of Private intervals to hush, keep all Royals (forced), and check the dominance constraints at every integer $y \ne C$. For each subset, we compute $\mathrm{sing}(x)$ across the relevant region and verify whether $\mathrm{sing}(C) \ge \mathrm{sing}(y) + A(|y - C|)$ holds for all $y \ne C$. The subset with the fewest hushed Private intervals that passes would be a solution.




**[THOUGHT_03_02]**

This approach is intractable. There are $2^n$ possible subsets (considering up to $n$ intervals). Even for moderate $n$, this is astronomically large. Moreover, evaluating the constraints naively would require scanning a potentially huge coordinate span since interval endpoints and $D_j$ can be up to $10^9$. The time complexity is exponential in $n$ and linear in the examined coordinate span, which is untenable.



**[THOUGHT_03_03]**

Attempting to prune the search space by early rejection still leaves an exponential core. One might try backtracking, hushing intervals that appear to cause local violations. However, due to overlapping intervals and varying $A(d)$, local decisions may not be globally optimal. This fails to guarantee a minimal hush count and remains computationally explosive.



**[THOUGHT_03_04]**

Because the subset space grows as $2^n$ and interval coordinates can reach $10^9$, any backtracking or pruning still faces exponential enumeration with potentially large per-check costs. Therefore, brute force is infeasible, and we require structural insights that lead to polynomial-time strategies.

---

**[CHAIN_04]**

Greedily hush intervals without separating Core (failed approach).

**[THOUGHT_04_01]**  
Sweep outward from $C$; whenever the dominance condition fails at some $x$, hush a Private interval covering $x$, treating all intervals uniformly without distinguishing whether they cover $C$.




**[THOUGHT_04_02]**  
Removing an interval that covers $C$ decreases $\mathrm{sing}(C)$, which tightens all inequalities globally. Even if such an interval also reduces $\mathrm{sing}(y)$ locally, the net effect can make constraints at other $y$ strictly harder because the baseline at $C$ fell by $1$.




**[THOUGHT_04_03]**  
Consider two Private intervals overlapping near $C$: one ends soon and one extends far. Fixing a nearby violation by removing the short one may leave a later violation unavoidable due to the long interval’s persistence where $A(d)$ is smaller, indicating the choice was counterproductive.



**[THOUGHT_04_04]**  

Given that lowering $\mathrm{sing}(C)$ globally worsens constraints and that locally convenient deletions can force later conflicts, this uniform-greedy strategy does not guarantee minimal removals and can fail even when a solution exists. A method that distinguishes intervals covering $C$ from those that do not is required. The implementation, if attempted, would run in $O(n\log n)$ due to sorting and balanced-structure operations.

---

**[CHAIN_05]**

Fix Core intervals and verify feasibility at distance 1.

**[THOUGHT_05_01]**  
Let $m=|\{\text{Core intervals}\}|$ and $h(x)=|\{\text{Core intervals covering }x\}|$. The residual capacity available to non-Core coverage at $x$ is
$$
\mathrm{cap}(x)=m - A(|x-C|) - h(x).
$$
Removing any Core interval decreases $m$ by $1$, and decreases $h(x)$ by $1$ on its support but by $0$ elsewhere, so $\mathrm{cap}(x)$ never increases globally; keeping all Core intervals is always optimal.





**[THOUGHT_05_02]**  
At $x=C+1$ and $x=C-1$, we require $\mathrm{sing}(C)-\mathrm{sing}(x)\ge A(1)$. These differences equal the counts of Core intervals ending at $C$ and starting at $C$, respectively. If either count is $<A(1)$, dominance cannot hold; the instance is impossible.



**[THOUGHT_05_03]**  
When both sides meet the $A(1)$ requirement, moving away from $C$ only increases the number of Core intervals that no longer cover $x$ while $A(d)$ is nonincreasing, thus $\mathrm{cap}(x)\ge 0$ for all $x\ne C$.



**[THOUGHT_05_04]**  
These checks integrate into the overall sweep and do not change the asymptotic bound; the total remains $O((n+s)\log n)$.


**[THOUGHT_05_05]**

The separation also clarifies the optimization objective: since Core intervals are fixed and required, minimizing the number of hushed Private intervals is equivalent to selecting a maximum number of Private Outers to keep, subject to not exceeding the residual capacity at any integer position.

---

**[CHAIN_06]**

Place Royal Outers under capacity constraints.

**[THOUGHT_06_01]**  
Royal Outers are mandatory coverage. At $x\ne C$, if the number of active Royals exceeds $\mathrm{cap}(x)$, dominance is impossible regardless of Private choices.



**[THOUGHT_06_02]**  
Relevant coordinates are finite: Core deltas at $L$ and $R+1$, starts of Outer intervals, step boundaries $x=C-D_j$ and $x=C+D_j+1$, and $C$ (where the inequality is not enforced).



**[THOUGHT_06_03]**  
At each coordinate $x$: expire intervals with end $<x$; apply Core deltas to update $h(x)$; insert Royals starting at $x$; then ensure $\mathrm{activeRoyal}(x)\le \mathrm{cap}(x)$.



**[THOUGHT_06_04]**  
Evaluate $A(d)$ for $d=|x-C|$ by lower-bounding $d$ in the sorted $D$-array and selecting the corresponding level.



**[THOUGHT_06_05]**  
A violation $\mathrm{activeRoyal}(x)>\mathrm{cap}(x)$ at any $x\ne C$ certifies impossibility.



**[THOUGHT_06_06]**  

Royals are inserted and removed once each, and with sorted events this step remains within the global $O((n+s)\log n)$ bound.

---

**[CHAIN_07]**

Schedule Private Outers under time-varying capacity.

**[THOUGHT_07_01]**

After placing Royals, the residual capacity is $$\mathrm{res}(x) = \mathrm{cap}(x) - \mathrm{activeRoyal}(x).$$ We must choose a largest subset of Private Outers such that, for every $x \ne C$, the number of active chosen Private Outers covering $x$ does not exceed $\mathrm{res}(x)$. Minimizing the number hushed is equivalent to maximizing the number kept.





**[THOUGHT_07_02]**

A standard greedy approach applies: sweep increasing $x$ over events. Maintain a multiset (or priority queue) of end positions of active Private Outers. When a new Private Outer starts, insert it. If at any coordinate $x$, the number of active Private Outers exceeds $\mathrm{res}(x)$, repeatedly remove the Private interval with the largest end (i.e., finishing latest) until the constraint is satisfied. Each removal corresponds to hushing one Private interval.




**[THOUGHT_07_03]**

The correctness hinges on an exchange argument. Suppose at a coordinate $x$ we exceed capacity and remove some active Private interval that does not have the latest end. Swapping this removal with the one having the latest end cannot increase future conflicts, because keeping earlier-ending intervals frees capacity sooner, strictly dominating any choice that keeps a later-ending one. Hence, always removing the latest end is optimal and yields a maximum feasible set.




**[THOUGHT_07_04]**

Edge conditions must be handled carefully:
- Intervals are inclusive, so expiration occurs at $R + 1$.
- The constraint is skipped at $x = C$.
- When multiple Private intervals end at the same point, any of them is acceptable to remove; using a multiset of end positions suffices.
- Royals are tracked separately and subtracted from total capacity to compute residual capacity for Privates.



**[THOUGHT_07_05]**

The final hush count is the number of Private intervals removed during the sweep. Since we keep as many as possible within capacity everywhere, this count is minimal. The time complexity is $O((n + s) \log n)$ due to sorting events and multiset operations.

---

**[CHAIN_08]**

Implement an event-driven sweep robustly.

**[THOUGHT_08_01]**  
Event coordinates include: Core deltas at $L$ and $R+1$; starts of Private and Royal Outers; step boundaries $x=C-D_j$ and $x=C+D_j+1$; and $C$ (skipped for enforcement). Deduplicate and sort to define the sweep order.



**[THOUGHT_08_02]**  
At each $x$:  
$1)$ Expire intervals with end $<x$.  
$2)$ Apply Core coverage changes at $x$ to maintain $h(x)$.  
$3)$ Insert Outer intervals starting at $x$.  
$4)$ If $x\ne C$, compute $d=|x-C|$, set $\mathrm{need}=A(d)$, and
$$
\mathrm{allowedTotal} \;=\; m - \mathrm{need} - h(x).
$$
Check $\mathrm{activeRoyal}(x)\le \mathrm{allowedTotal}$. Let
$$
\mathrm{allowedPriv} \;=\; \mathrm{allowedTotal} - \mathrm{activeRoyal}(x).
$$
While $\mathrm{activePriv}(x)>\mathrm{allowedPriv}$, remove the Private with the largest end (each removal is one hush).




**[THOUGHT_08_03]**  
Use: a sorted vector of Core deltas, two multisets keyed by end (for Royals and Privates), and sorted vectors of Outers by start. This preserves inclusive semantics via expiration at $R+1$.



**[THOUGHT_08_04]**  
Skipping enforcement at $x=C$ avoids comparing $\mathrm{sing}(C)$ to itself.



**[THOUGHT_08_05]**  
Removing the latest-ending Private is optimal by a standard exchange argument: keeping earlier-ending intervals frees capacity sooner and cannot increase future violations.



**[THOUGHT_08_06]**  

Sorting events dominates $O((n+s)\log n)$, each insert or erase is $O(\log n)$, and each interval is processed $O(1)$ times overall.

---

**[CHAIN_09]**

Validate the algorithm and perform stress testing.

**[THOUGHT_09_01]**

Validate inclusivity and neighbor checks. Construct cases to ensure expiration at $R + 1$ behaves correctly and that the Core-only check at $d = 1$ is both necessary and sufficient for nonnegative capacities. Confirm that equalities at $A(1)$ thresholds are handled precisely.




**[THOUGHT_09_02]**

Run randomized stress tests for small instances. For $n$ up to $20$, brute force over Private subsets is feasible. Compare the greedy result to brute-force optimum to build confidence. Randomize interval endpoints, $C$, $D$, and $a$ levels while preserving nonincreasing $a$ and increasing $D$.




**[THOUGHT_09_03]**

Test step transitions at boundaries. Focus on distances exactly equal to $D_j$ and just beyond. Confirm that left-side boundaries at $x = C - D_j$ and right-side at $x = C + D_j + 1$ reflect the intended $A(d)$ transitions and that no off-by-one errors occur.




**[THOUGHT_09_04]**

Evaluate performance for large $n$ and $s$. Use $n, s$ near $2 \cdot 10^5$ with large coordinates to ensure the event compression eliminates any iteration over irrelevant integers. Measure that the total time remains within acceptable bounds and memory usage scales linearly.




**[THOUGHT_09_05]**

Avoid common pitfalls:
- Forgetting to skip enforcing at $x = C$ leads to incorrect self-comparisons.
- Mishandling inclusive intervals by expiring at $R$ instead of $R + 1$ causes off-by-one errors.
- Hushing Core intervals is never beneficial; if implemented, it will reduce capacity in unintended regions and break correctness.
- Not separating Royal and Private counts can mask an infeasibility caused by royal overflow.

---

**[RESPONSE]**

**1. Problem Understanding**

We are given $n$ choir intervals on the integer line and a distinguished coordinate $C$ called the Citadel. Each interval $[L_i, R_i]$ contributes one unit to $\mathrm{sing}(x)$ for every integer $x \in [L_i, R_i]$ if the interval is kept. Intervals are of two types: Royal ($T_i = 1$) that cannot be hushed (removed), and Private ($T_i = 0$) that may be hushed.

We are also given a stepwise nonincreasing advantage function $A(d)$ for integer distances $d \ge 1$, defined by $s$ radii $D_1 < D_2 < \dots < D_s$ and $s + 1$ levels $a_1 \ge a_2 \ge \dots \ge a_{s+1}$. The Citadel $C$ must be tier-dominant:
$$\mathrm{sing}(C) \ge \mathrm{sing}(y) + A(|y - C|) \quad \text{for every integer } y \ne C.$$

We must hush a minimum number of Private intervals so that the condition holds, or report $-1$ if it is impossible.

Key observations:
- Split intervals into Core (those covering $C$) and Outer (those that do not).
- It is never beneficial to hush any Core interval because it decreases $\mathrm{sing}(C)$ and cannot increase capacity for Outers elsewhere.
- With only Core intervals, the tight feasibility check is at $C - 1$ and $C + 1$. If Core alone fails at distance $1$ on either side, no solution exists.
- After fixing Core, define the capacity for Outers at each $x$ by:
$$\mathrm{cap}(x) = m - A(|x - C|) - h(x),$$
where $m$ is the number of Core intervals and $h(x)$ is the number of Core intervals covering $x$. Royal Outers must fit within capacity everywhere; otherwise, it is impossible.
- To minimize hushed Private intervals, maximize the number of Private Outers kept under the residual capacity at each $x$. This is scheduling with time-varying capacity solved optimally by a greedy sweep that removes the latest-ending Private interval when capacity is exceeded.

**2. Optimal Approach**

We proceed in five steps:

1) Separate Core and Outer intervals and keep all Core intervals.
- Let $m$ be the number of Core intervals.
- For each $x$, let $h(x)$ be the count of Core intervals covering $x$.

2) Core-only feasibility at distance $1$:
- Let $\mathrm{need}_1 = A(1)$.
- Compute the number of Core intervals starting at $C$ and ending at $C$. If either count is less than $\mathrm{need}_1$, then even with all Outers hushed, the nearest neighbor constraint cannot be satisfied; return $-1$.
- If both are at least $\mathrm{need}_1$, then the Core alone satisfies the dominance inequalities for all $y \ne C$, guaranteeing nonnegative capacity for Outers.

3) Compute capacity and place Royal Outers:
- For any $x \ne C$, total allowed Outers is $\mathrm{cap}(x) = m - A(|x - C|) - h(x)$.
- Royal Outers are mandatory. If at any $x$ the number of active Royal Outers exceeds $\mathrm{cap}(x)$, return $-1$.

4) Maximize kept Private Outers:
- The residual capacity is $\mathrm{res}(x) = \mathrm{cap}(x) - \mathrm{activeRoyal}(x)$.
- Sweep over a compressed set of event coordinates (Core deltas at $L$ and $R + 1$, starts of Outers, step boundaries of $A$, and $C$).
- Maintain active Private Outers in a multiset keyed by end coordinate. When the number of active Private Outers exceeds $\mathrm{res}(x)$, repeatedly remove the one with the largest end. Each removal corresponds to hushing one Private interval.
- An exchange argument shows this greedy removal is optimal, yielding the maximum feasible set of Private intervals kept.

5) Count and output:
- The number of removed Private intervals during the sweep is the minimal hush count.

Event compression ensures we only process $O(n + s)$ coordinates. All updates and checks are done at these coordinates, and inclusivity is handled with expirations at $R + 1$.

**3. Code**
```cpp
#include <algorithm>
#include <iostream>
#include <set>
#include <utility>
#include <vector>

/*
 * Problem summary:
 *  - Intervals are either Royal (must keep) or Private (may hush).
 *  - The Citadel at position C is "tier-dominant" if for every integer y != C:
 *        sing(C) >= sing(y) + A(|y - C|)
 *  - A(d) is a stepwise nonincreasing function defined by radii D[0..s-1] and levels a[0..s].
 *  - Goal: hush the minimum number of Private intervals to satisfy the condition; or output -1.
 *
 * Key implementation ideas:
 *  - Keep all intervals that cover C ("Core"). Removing Core never helps: it reduces sing(C)
 *    and does not increase capacity elsewhere.
 *  - First, a necessary (and here sufficient) core-only feasibility check at distance 1:
 *      count of Core with L = C  >= A(1)  and  count of Core with R = C  >= A(1)
 *    If it fails, return -1 immediately.
 *  - Define capacity at x (excluding C) as:
 *        cap(x) = m - A(|x - C|) - h(x)
 *    where m = number of Core intervals, and h(x) = number of Core intervals covering x.
 *    Royal Outers must fit within cap(x); otherwise infeasible.
 *  - For Private Outers, to maximize how many we keep (i.e., minimize hushing),
 *    sweep over event positions and, whenever active privates exceed residual capacity,
 *    hush the private interval with the latest end (greedy by exchange argument).
 *
 * Data structures:
 *  - Multiset of active private ends (to remove latest end when over capacity and
 *    to expire intervals ending before current position).
 *  - Multiset of active royal ends (count and expire).
 *
 * Event positions (coordinate compression):
 *  - Core L and R+1 (inclusive-interval deltas)
 *  - Starts (L) of all Outers (private and royal)
 *  - Step boundaries for A(d): C - D_j (left strict), C + D_j (right strict)
 *  - The Citadel C itself (to skip enforcement there)
 *
 * Complexity: O((n + s) log n) per test (sorting + multiset operations).
 */

/**
 * @brief Returns A(d): the required advantage at an integer distance d >= 1.
 *
 * Levels are specified so that for index i:
 *   - if i < s:  levels[i] applies for distances in (D[i-1], D[i]], treating D[-1] = 0
 *   - if i = s:  levels[i] applies for distances > D[s-1]
 */
static inline long long requiredAdvantageAtDistance(const std::vector<long long>& distances,
                                                    const std::vector<long long>& levels,
                                                    long long d) {
    // lower_bound finds the first D[i] >= d; if none, idx == s so we use levels[s]
    int idx = static_cast<int>(std::lower_bound(distances.begin(), distances.end(), d) - distances.begin());
    return levels[idx];
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int testCount;
    if (!(std::cin >> testCount)) {
        return 0;
    }

    while (testCount--) {
        int choirCount, stepCount;
        long long citadel;
        std::cin >> choirCount >> citadel >> stepCount;

        std::vector<long long> radii(stepCount);
        std::vector<long long> levels(stepCount + 1);
        for (int i = 0; i < stepCount; ++i) {
            std::cin >> radii[i] >> levels[i];
        }
        std::cin >> levels[stepCount];

        // Partition intervals into Core (cover C) and Outers (do not cover C).
        std::vector<std::pair<long long, long long>> coreIntervals;
        std::vector<std::pair<long long, long long>> privateOuters;
        std::vector<std::pair<long long, long long>> royalOuters;

        long long coreStartAtCitadelCount = 0;  // # of Core with L == C
        long long coreEndAtCitadelCount = 0;    // # of Core with R == C

        for (int i = 0; i < choirCount; ++i) {
            long long L, R;
            int type;
            std::cin >> L >> R >> type;

            if (L <= citadel && citadel <= R) {
                coreIntervals.emplace_back(L, R);
                if (L == citadel) {
                    ++coreStartAtCitadelCount;
                }
                if (R == citadel) {
                    ++coreEndAtCitadelCount;
                }
            } else {
                if (type == 1) {
                    royalOuters.emplace_back(L, R);
                } else {
                    privateOuters.emplace_back(L, R);
                }
            }
        }

        // Core-only feasibility at distance 1.
        long long needAt1 = requiredAdvantageAtDistance(radii, levels, 1);
        if (coreStartAtCitadelCount < needAt1 || coreEndAtCitadelCount < needAt1) {
            std::cout << -1 << '\n';
            continue;
        }

        // Prepare Core coverage deltas: +1 at L, -1 at R+1 (inclusive coverage).
        std::vector<std::pair<long long, int>> coreCoverageDeltas;
        coreCoverageDeltas.reserve(2 * coreIntervals.size());
        for (const auto& interval : coreIntervals) {
            coreCoverageDeltas.emplace_back(interval.first, +1);
            coreCoverageDeltas.emplace_back(interval.second + 1, -1);
        }
        std::sort(coreCoverageDeltas.begin(), coreCoverageDeltas.end());

        // Sort Outers by start coordinate to feed the sweep efficiently.
        std::sort(privateOuters.begin(), privateOuters.end());
        std::sort(royalOuters.begin(), royalOuters.end());

        // Build the set of event positions for the sweep.
        std::vector<long long> eventPositions;

        // Reserve: core contributes 2 deltas; each outer contributes its start;
        // A(d) contributes 2 boundaries per step; plus a slot for citadel C.
        eventPositions.reserve(
            2 * coreIntervals.size() +
            privateOuters.size() +
            royalOuters.size() +
            2LL * stepCount +
            1
        );

        // Core L and R+1 (to update h(x) via deltas)
        for (const auto& interval : coreIntervals) {
            eventPositions.push_back(interval.first);
            eventPositions.push_back(interval.second + 1);
        }

        // Starts of Outers
        for (const auto& interval : privateOuters) {
            eventPositions.push_back(interval.first);
        }
        for (const auto& interval : royalOuters) {
            eventPositions.push_back(interval.first);
        }

        // Step boundaries for A(d):
        //  - Left strict boundary at x = C - D_j  (distance D_j on the left)
        //  - Right strict boundary at x = C + D_j (distance D_j on the right)
        for (int i = 0; i < stepCount; ++i) {
            eventPositions.push_back(citadel - radii[i]);
            eventPositions.push_back(citadel + radii[i]);
        }

        // Add C itself so we can skip enforcement there explicitly.
        eventPositions.push_back(citadel);

        std::sort(eventPositions.begin(), eventPositions.end());
        eventPositions.erase(std::unique(eventPositions.begin(), eventPositions.end()), eventPositions.end());

        // Sweep state.
        std::size_t coreDeltaIndex = 0;
        std::size_t privateIndex = 0;
        std::size_t royalIndex = 0;

        long long coreCoverageAtX = 0;                      // h(x): # of Core covering current x
        long long singAtCitadelWithCore = static_cast<long long>(coreIntervals.size());  // m
        long long hushedPrivateCount = 0;
        bool infeasible = false;

        // Multisets of active Outer interval ends.
        // NOTE: We use a multiset instead of priority_queue because we need:
        //   - to remove expired intervals from the beginning (smallest end)
        //   - to remove the "latest end" (largest) when over capacity
        std::multiset<long long> activePrivateEnds;
        std::multiset<long long> activeRoyalEnds;

        for (long long x : eventPositions) {
            // Expire intervals whose end < x (since intervals are inclusive and expire at R+1).
            while (!activePrivateEnds.empty() && *activePrivateEnds.begin() < x) {
                activePrivateEnds.erase(activePrivateEnds.begin());
            }
            while (!activeRoyalEnds.empty() && *activeRoyalEnds.begin() < x) {
                activeRoyalEnds.erase(activeRoyalEnds.begin());
            }

            // Apply Core coverage deltas at x.
            while (coreDeltaIndex < coreCoverageDeltas.size() &&
                   coreCoverageDeltas[coreDeltaIndex].first == x) {
                coreCoverageAtX += coreCoverageDeltas[coreDeltaIndex].second;
                ++coreDeltaIndex;
            }

            // Insert newly-started Outers at x.
            while (privateIndex < privateOuters.size() && privateOuters[privateIndex].first == x) {
                activePrivateEnds.insert(privateOuters[privateIndex].second);
                ++privateIndex;
            }
            while (royalIndex < royalOuters.size() && royalOuters[royalIndex].first == x) {
                activeRoyalEnds.insert(royalOuters[royalIndex].second);
                ++royalIndex;
            }

            // No constraint enforced at the Citadel itself.
            if (x == citadel) {
                continue;
            }

            // Compute capacity at x.
            long long dist = (x > citadel ? x - citadel : citadel - x);
            if (dist == 0) {
                // (Defensive; we already continue on x == C above.)
                continue;
            }

            long long requiredAdv = requiredAdvantageAtDistance(radii, levels, dist);
            // Capacity formula: outerCapacity = m - A(d) - h(x)
            long long outerCapacity = singAtCitadelWithCore - requiredAdv - coreCoverageAtX;

            // Guard: even with zero outers, inequality fails here.
            if (outerCapacity < 0) {
                infeasible = true;
                break;
            }

            long long royalActiveCount = static_cast<long long>(activeRoyalEnds.size());
            if (royalActiveCount > outerCapacity) {
                infeasible = true;
                break;
            }

            long long allowedPrivateCount = outerCapacity - royalActiveCount;
            while (static_cast<long long>(activePrivateEnds.size()) > allowedPrivateCount) {
                // Remove the private that ends latest (greedy choice).
                auto latest = std::prev(activePrivateEnds.end());
                activePrivateEnds.erase(latest);
                ++hushedPrivateCount;
            }
        }

        if (infeasible) {
            std::cout << -1 << '\n';
        } else {
            std::cout << hushedPrivateCount << '\n';
        }
    }

    return 0;
}
```

**4. Code Explanation**

- We split intervals into Core (cover $C$) and Outer (do not cover $C$). All Core intervals are kept because removing any Core interval reduces $\mathrm{sing}(C)$ and never increases capacity elsewhere.
- Core-only feasibility is checked at distance $1$ on both sides:
  - $\mathrm{sing}(C) - \mathrm{sing}(C + 1)$ equals the number of Core intervals with $R = C$.
  - $\mathrm{sing}(C) - \mathrm{sing}(C - 1)$ equals the number of Core intervals with $L = C$.
  - If either is below $A(1)$, we return $-1$.
- We build event coordinates from:
  - Core starts $L$ and ends $R + 1$ (for coverage delta),
  - Starts of Outer intervals,
  - Step boundaries of $A$: $x = C - D_j$ and $x = C + D_j + 1$,
  - The Citadel $C$ (to skip enforcing there).
- We sweep in ascending order of coordinates:
  - Expire intervals with end $< x$ (inclusive behavior).
  - Apply Core coverage deltas at $x$ to keep $h(x)$.
  - Insert any Outer intervals starting at $x$.
  - If $x \ne C$, compute $\mathrm{cap}(x) = m - A(|x - C|) - h(x)$. If active Royal Outers exceed $\mathrm{cap}(x)$, the instance is infeasible.
  - The remaining capacity is for Private Outers. If active Privates exceed this residual capacity, remove (hush) Private intervals with the largest end first until feasible. This greedy choice is optimal by a standard exchange argument because keeping earlier-ending intervals preserves more future capacity.
- The total number of removed Private intervals is the minimal hush count.

**5. Time and Space Complexity**

- Coordinate collection and sorting: $O((n + s) \log(n + s))$.
- Each interval is inserted and erased at most once in multisets: $O(n \log n)$ total.
- Overall time complexity: $O((n + s) \log n)$ per test case.
- Space complexity: $O(n + s)$ for events, deltas, and active sets.

**6. Conclusion**

By fixing all Core intervals, verifying a necessary and sufficient Core-only condition at distance $1$, and then scheduling Outer intervals under a time-varying capacity using an event-driven sweep, we can detect infeasibility early and minimize the number of hushed Private intervals optimally. The greedy removal of the latest-ending Private intervals ensures maximum utilization of future capacity, achieving the required tier-dominance efficiently within the given constraints.

**7. Walkthrough (Example 1, using the optimal approach in the code)**

- Parameters: $n=3$, $C=10$, $s=2$, $(D_1,a_1)=(2,1)$, $(D_2,a_2)=(4,1)$, $a_{3}=0$.  
  Intervals: $[10,10]$ with $T=1$, $[12,12]$ with $T=0$, $[13,13]$ with $T=0$.  
  Step function: $A(d)=1$ for $1\le d\le 4$, and $A(d)=0$ for $d>4$.


**Step 1 — Split Core vs. Outer**
- Core (cover $C$): $\{[10,10]\}$, so $m=1$.  
- Outers: privates $\{[12,12], [13,13]\}$, royals $\varnothing$.

**Step 2 — Core-only feasibility at distance $1$**
- Count Core intervals with $L=C$: $1$; with $R=C$: $1$.  
- $\mathrm{need}_1=A(1)=1$. Both counts $\ge \mathrm{need}_1$, so Core alone passes at $C\pm 1$. This guarantees nonnegative capacity everywhere.

**Step 3 — Construct event coordinates (compressed sweep)**
- Core deltas at $L$ and $R+1$: $\{10,\,11\}$.  
- Outer starts: $\{12,\,13\}$.  
- Step boundaries: $C-D_1=8$, $C+D_1+1=13$; $C-D_2=6$, $C+D_2+1=15$.  
- Add $C=10$ to skip enforcement there.  
- Sorted unique sweep coordinates: $\{6,\,8,\,10,\,11,\,12,\,13,\,15\}$.

We maintain:
- $h(x)$ = Core coverage at $x$ (from deltas).  
- $\mathrm{activeRoyal}(x)$ = number of active royal Outers (here always $0$).  
- Multiset of ends for active Private Outers.  
- At any $x\ne C$, allowed total Outers:
  $$\mathrm{cap}(x)=m-A(|x-C|)-h(x).$$
  Residual for privates:
  $$\mathrm{res}(x)=\mathrm{cap}(x)-\mathrm{activeRoyal}(x).$$


**Step 4 — Sweep the coordinates**

1) $x=6$: $d=|6-10|=4$, $A(d)=1$, Core $[10,10]$ does not cover $6$ so $h=0$.  
   $$\mathrm{cap}(6)=1-1-0=0,\quad \mathrm{res}(6)=0.$$  
   No active privates yet, nothing to hush.

2) $x=8$: $d=2$, $A(d)=1$, $h=0$.  
   $$\mathrm{cap}(8)=1-1-0=0,\quad \mathrm{res}(8)=0.$$  
   Still no privates active.

3) $x=10$: apply Core $+1$ at $10$, so $h\leftarrow 1$. We **skip** enforcement at $x=C$.

4) $x=11$: apply Core $-1$ at $11$ (expire $[10,10]$), so $h\leftarrow 0$.  
   $d=1$, $A(d)=1$.  
   $$\mathrm{cap}(11)=1-1-0=0,\quad \mathrm{res}(11)=0.$$  
   No privates active (both start later).

5) $x=12$: start private $[12,12]$ (insert end $12$).  
   $d=2$, $A(d)=1$, $h=0$.  
   $$\mathrm{cap}(12)=1-1-0=0,\quad \mathrm{res}(12)=0.$$  
   Active privates $=1>\mathrm{res}(12)=0$ ⇒ hush one private (remove the latest-ending; here the only one is $[12,12]$).  
   Hushed count $\leftarrow 1$; active privates $\leftarrow 0$.

6) $x=13$: step boundary (also start private $[13,13]$, insert end $13$).  
   $d=3$, $A(d)=1$, $h=0$.  
   $$\mathrm{cap}(13)=1-1-0=0,\quad \mathrm{res}(13)=0.$$  
   Active privates $=1>\mathrm{res}(13)=0$ ⇒ hush one private (remove $[13,13]$).  
   Hushed count $\leftarrow 2$; active privates $\leftarrow 0$.

7) $x=15$: $d=5$, $A(d)=0$, $h=0$.  
   $$\mathrm{cap}(15)=1-0-0=1,\quad \mathrm{res}(15)=1.$$  
   No active privates remain.

**Step 5 — Result**
- Total hushed privates $=2$, which is minimal.  
- After hushing, $\mathrm{sing}(y)=0$ for all $y\ne 10$, so for $1\le d\le 4$ we have $1\ge 0+1$ and for $d>4$ we have $1\ge 0$, satisfying tier-dominance everywhere.