# Metadata

**Category:** - Coding

**Topic:** - Competitive Programming

**Subtopic:** - ["Sorting Algorithms", "Searching Algorithms", "Graph Algorithms", "Graphs and Networks", "Arrays and Lists", "Algorithm Complexity and Big O Notation", "Game Theory", "Dynamic Programming", "Memoization"]

**Difficulty:** - Hard

**Languages:** - Python

**Number of Approaches:** - 5, ($O(n \cdot (n + m)^2)$ -> $O(n \cdot (n + m) \log(n + m))$ -> $O(n \cdot (n + m))$ -> $O(n \log n + m \log m)$ -> $O(n + m)$)

**Number of Chains:** - 7

**GitHub:** - https://github.com/NOI-gen/beacon_ping_pong

---

**[User]**

*Demark the start of the User's activity*

---

**[Prompt]**

**Beacon Ping-Pong**

Time Limit: **2 seconds**

Memory Limit: **32 MB**

Two ancient beacons, Northlight and Southlight, volley light pulses. Each pulse is a pair of integers $(I, F)$:
- intensity $I$
- filter $F$

A pulse $A$ disrupts pulse $B$ if $I_A > F_B$.

Northlight starts by choosing any one of its pulses. After that, replies are forced: whenever a side must answer a pulse with filter $F$, it must choose, among its own pulses with $I > F$,
- the one with the smallest $I$,
- if several, the one with the smallest $F$,
- if still tied, the one with the smallest input index (1-based within that side).

Pulses are reusable; the sets never change. If, on your turn, you have no pulse that can disrupt the last pulse, you lose. If the back-and-forth repeats forever, it is a stalemate.

For each test case, consider every possible opening pulse of Northlight. Because replies are forced, each opening yields a unique outcome and, if it ends, a unique total number of shown pulses (including the opening). For each test case, report:
- how many openings are wins for Northlight,
- how many are stalemates,
- how many are losses,
- the sum of total pulses shown over all winning openings,
- the sum of total pulses shown over all losing openings.

If Southlight cannot answer the opening pulse, that opening’s total is $1$.

**Input Format:-**

- $t$ — number of test cases ($1 \le t \le 10^4$)
For each test case:
- $n$ — Northlight’s pulse count
- $n$ integers $I_1,\dots,I_n$ — intensities of Northlight’s pulses
- $n$ integers $F_1,\dots,F_n$ — filters of Northlight’s pulses
- $m$ — Southlight’s pulse count
- $m$ integers $J_1,\dots,J_m$ — intensities of Southlight’s pulses
- $m$ integers $G_1,\dots,G_m$ — filters of Southlight’s pulses

Indices for tie-breaking are 1-based within each side, according to input order.

**Output Format:-**

For each test case, print five integers:
- $W$ $D$ $L$ $SW$ $SL$, where
  - $W$ = number of Northlight openings that win for Northlight,
  - $D$ = number that end in stalemate,
  - $L$ = number that lose to Southlight,
  - $SW$ = sum of total pulses over winning openings,
  - $SL$ = sum of total pulses over losing openings.

**Constraints:-**

- $1 \le n, m \le 3 \cdot 10^5$ per test case
- $1 \le I_i, F_i, J_j, G_j \le 10^6$
- Over all test cases, $\sum n \le 3 \cdot 10^5$ and $\sum m \le 3 \cdot 10^5$
**Examples:-**
 - **Input:**
```
1
2
9 4
5 1
2
5 8
2 6
```

 - **Output:**
```
0 2 0 0 0
```

 - **Input:**
```
1
4
5 5 5 7
1 2 1 3
4
6 6 6 8
2 1 2 4
```

 - **Output:**
```
0 4 0 0 0
```

**Note:-**
In the first example, North has pulses $(9,5)$ and $(4,1)$, South has $(5,2)$ and $(8,6)$. Replies use the last pulse’s filter as threshold and pick the smallest qualifying intensity ($I>F$), then smallest filter, then smallest index.
- Opening with $(9,5)$: South must pick $(8,6)$ (smallest $J>5$). Now North must answer $G=6$ with $(9,5)$ (only $I>6$). This forms a 2-cycle $(9,5)\leftrightarrow(8,6)$, hence a stalemate.
- Opening with $(4,1)$: South must pick $(5,2)$ (smallest $J>1$). Now North must answer $G=2$ with $(4,1)$ (smallest $I>2$). This forms a 2-cycle $(4,1)\leftrightarrow(5,2)$, hence a stalemate.
Thus $W=0$, $D=2$, $L=0$, and since there are no wins or losses, $SW=0$, $SL=0$.

In the second example, North has $(5,1)$, $(5,2)$, $(5,1)$, $(7,3)$ and South has $(6,2)$, $(6,1)$, $(6,2)$, $(8,4)$. For any North opening, South answers a filter $F<6$ with intensity $6$, and among $J=6$ ties picks $(6,1)$ (smallest $G$, then smallest index). Responding to $G=1$, North must pick a pulse with $I=5$ (smallest $I>1$), and among those, the smallest filter is $1$; between $(5,1)$ ties, the smallest index is the first one. Therefore every opening flows into the same 2-cycle $(5,1)\leftrightarrow(6,1)$, a stalemate. Hence $W=0$, $D=4$, $L=0$, and $SW=SL=0$.

---

**[Assistant]**

Demark the start of the Assistant's activity

---

**[CHAIN_01]**

Clarifying entities, rules, and outputs

**[THOUGHT_01_01]**

We have two players, Northlight and Southlight. Each possesses a set of pulses. A pulse is represented as a pair $(I, F)$, where $I$ is the intensity and $F$ is the filter. A pulse $A$ can disrupt a pulse $B$ if and only if $I_A > F_B$. This relation is directional and depends only on comparing the intensity of the responding pulse to the filter of the last displayed pulse.

**[THOUGHT_01_02]**

The turn order is fixed and begins with Northlight, who chooses any one of its pulses as the opening. Subsequent replies are forced by a deterministic tie-breaking policy: for a required counter to a filter $F$, a side must choose among its pulses with $I > F$ the one with the smallest $I$; if multiple pulses share this $I$, choose the one with the smallest $F$; if still tied, choose the one that appeared earlier in that side’s input (1-based index).

**[THOUGHT_01_03]**

Pulses are reusable indefinitely; no pulse is ever removed or blocked for future use. Therefore, the state is determined solely by the last displayed pulse. If, on your turn, you have no pulse that can disrupt the last pulse, you lose. If the back-and-forth repeats forever due to deterministic choices, it is a stalemate (draw).

**[THOUGHT_01_04]**

For each test case, we evaluate every possible opening from Northlight. Because replies are forced, each opening induces exactly one deterministic sequence. We must output, over all Northlight openings: the counts of wins, draws, and losses for Northlight, and the sums of total pulses displayed over winning openings and over losing openings. The total includes the opening pulse. If the opponent cannot answer the opening, the total is $1$.


---

**[CHAIN_02]**

Enumerating test cases and edge scenarios

**[THOUGHT_02_01]**

Single-step win: Northlight opens with a pulse $(I, F)$ such that Southlight has no pulse with intensity $> F$. The outcome is an immediate win for Northlight with total pulses $= 1$. This validates the base condition for termination on the opponent’s first turn.

**[THOUGHT_02_02]**

Two-cycle stalemate: A Northlight $(I_1, F_1)$ and Southlight $(J_1, G_1)$ satisfy $I_1 > G_1$ and $J_1 > F_1$, with tie-break rules forcing these same choices repeatedly. This creates a 2-cycle and must be classified as a draw, not as a win or loss.

**[THOUGHT_02_03]**

Long alternating chain: The game alternates between sides across many pulses and eventually reaches a pulse whose opponent has no legal reply. The last mover wins. This checks that the counted total pulses equals the exact traversed length and includes the opening pulse.

**[THOUGHT_02_04]**

Tie-breaking verification: Multiple pulses share the same intensity. Among those, filters can differ; among equal filters, earlier input index must prevail. This tests stability and determinism of the reply rule within identical-intensity groups on each side.

**[THOUGHT_02_05]**

Degenerate sizes and duplicates: Cases with $n = 1$ or $m = 1$, and inputs with many identical pulses. This examines robustness when many choices appear equivalent except for tie-breakers, and ensures 1-based input indices are honored.

**[THOUGHT_02_06]**

Extreme numeric ranges: Intensities and filters range up to $10^6$. This checks correctness under large values and guards against assumptions about distribution or density of intensities and filters.


---

**[CHAIN_03]**

Implementing brute force

**[THOUGHT_03_01]**

We simulate each opening independently. Starting from a chosen Northlight pulse, we repeatedly determine the opponent’s forced reply by scanning all opponent pulses to find those with $I > F$ and selecting the one that minimizes $I$, then $F$, then index. We continue until either no reply exists (termination) or we detect repetition (stalemate) by tracking visited pulses in the current simulation.

**[THOUGHT_03_02]**

This method is correct in principle because the rules guarantee at most one legal reply is chosen at each step. Thus, the sequence from any starting pulse is well-defined, and it either terminates or repeats. The last mover in a terminating sequence is the winner, and the total pulse count is the path length.

**[THOUGHT_03_03]**

Time complexity is prohibitive. For each opening (there are $n$), every reply selection scans an entire opposing list, which is $O(\max(n, m))$ per step. A single path can be $O(n + m)$ steps long. Therefore, the total worst-case time is
$$
O\big(n \cdot (n + m)^2\big),
$$
which is infeasible for $n, m$ up to $3 \cdot 10^5$. Space is $O(n + m)$ to hold pulses and a small local visited set.

**[THOUGHT_03_04]**

Limitations motivate a redesign: repeated full scans and recomputation per hop dominate runtime. Even when paths are short, adversarial inputs can trigger worst-case behavior frequently. We need to accelerate reply selection and reduce redundant work across openings.


---

**[CHAIN_04]**

Accelerating selection with binary search

**[THOUGHT_04_01]**

We sort each side’s pulses by the tuple $(I, F, \text{index})$. For any required response to a filter $F$, the forced reply is the first pulse with $I > F$. This can be found via binary search (upper_bound) on the intensity array; due to the stable ordering by $(I, F, \text{index})$, the earliest with admissible intensity automatically satisfies the tie-breaker rules.

**[THOUGHT_04_02]**

We keep the rest of the brute-force simulation intact. For each opening, we traverse hop by hop. At each hop, we select the forced reply using $O(\log(n + m))$ time via binary search, replacing the $O(\max(n, m))$ scan. Cycle detection still uses a local visited set.

**[THOUGHT_04_03]**

The per-opening worst-case cost becomes $O\big((n + m) \cdot \log(n + m)\big)$, and over $n$ openings the total is
$$
O\big(n \cdot (n + m) \cdot \log(n + m)\big),
$$
which improves strictly over the brute force. However, it remains too slow for the largest inputs.

**[THOUGHT_04_04]**

The bottleneck is recomputation: many openings traverse overlapping tails, yet we recompute them independently. We must avoid repeated work by precomputing transitions and sharing results across openings.


---

**[CHAIN_05]**

Precomputing edges but simulating per opening

**[THOUGHT_05_01]**

We precompute a single outgoing edge for every pulse: for a Northlight pulse $(I_i, F_i)$, the edge points to Southlight’s forced reply to $F_i$; and symmetrically for Southlight pulses. Using the sorted lists from the previous section, we can determine each next pointer via upper_bound in $O(\log(n + m))$ time per node.

**[THOUGHT_05_02]**

After building all next pointers, each hop becomes $O(1)$. However, we still simulate from each opening independently, following next pointers until termination or cycle detection with a local visited set. We record the path length and outcome per opening.

**[THOUGHT_05_03]**

This reduces per-opening cost to $O(n + m)$ for traversal, giving a total of
$$
O\big(n \cdot (n + m)\big) + O\big((n + m) \cdot \log(n + m)\big)
$$
for the entire test case. This strictly improves over the previous section’s $O\big(n \cdot (n + m) \cdot \log(n + m)\big)$ bound.

**[THOUGHT_05_04]**

Despite the improvement, this approach remains too slow: many openings still traverse long, overlapping paths without sharing resolved outcomes. We need to process the functional graph globally so that each node is solved once, and results are reused.


---

**[CHAIN_06]**

Processing the functional graph once with cycle detection

**[THOUGHT_06_01]**

We view all pulses as nodes in a functional graph with at most one outgoing edge per node (some nodes may have none). We globally traverse using 3-color marking: $0$ for unvisited, $1$ for visiting (on stack), and $2$ for processed. Starting from any unvisited node, we follow next pointers iteratively until we encounter a sink, a visiting node (cycle), or a processed node.

**[THOUGHT_06_02]**

If we reach a sink (node with no outgoing edge), the owner of the last node wins. Assign that last node distance $1$ (that pulse is displayed), then propagate backwards along the current stack: increment the distance by $+1$ per step and assign the same winner to every node in the path. This precisely counts the number of pulses shown from each starting node.

**[THOUGHT_06_03]**

If we encounter a cycle (revisiting a visiting node), all nodes on the cycle and all nodes in the active chain that lead into it are stalemates (draws). We mark them as draws with no finite distance. If we reach a processed node, we reuse its result; if it is a draw, the entire current stack is also a draw; otherwise, we propagate winner and distances backward similarly to the sink case.

**[THOUGHT_06_04]**

To build edges efficiently, we sort each side by $(I, F, \text{index})$ in
$$
O\big(n \log n + m \log m\big)
$$
time and then use a two-pointer sweep to assign next pointers for all nodes in
$$
O(n + m)
$$
time: for each filter $F$ of one side (processed in nondecreasing order), advance a pointer over the opponent’s intensity-sorted list to the first pulse with $I > F$ and record that as the forced reply. This respects all tie-breakers because the opponent list is sorted by $(I, F, \text{index})$.

**[THOUGHT_06_05]**

Overall complexity becomes
$$
O\big(n \log n + m \log m\big) + O(n + m),
$$
with space $O(n + m)$. This strictly improves from the prior section’s $O\big(n \cdot (n + m)\big)$ by solving every node exactly once and eliminating per-opening recomputation, while ensuring deterministic outcomes and accurate pulse counts.


---

**[CHAIN_07]**

Eliminating comparison sort with linear-time radix sorting

**[THOUGHT_07_01]**

We further reduce asymptotic cost by replacing comparison-based sorting. Since $I$, $F$, and indices are bounded integers, we can apply stable LSD radix sorting (or counting sort per digit) to sort by the composite key $(I, F, \text{index})$ in linear time with respect to the number of pulses.

**[THOUGHT_07_02]**

Implementation outline: for each side, perform stable passes on the least significant key first—stably sort by index, then by filter $F$, then by intensity $I$. With fixed-width integers and a suitable base (e.g., $2^{16}$), the number of passes is constant. This yields $O(n + m)$ sorting time and $O(n + m)$ auxiliary space.

**[THOUGHT_07_03]**

With linear-time sorting, the two-pointer edge construction remains $O(n + m)$, and the functional-graph classification is $O(n + m)$. The total per test case reduces strictly to
$$
O(n + m),
$$
with $O(n + m)$ space, improving over the previous $O\big(n \log n + m \log m\big)$ bound.

**[THOUGHT_07_04]**

Practical considerations: while radix sorting offers the best asymptotic bound, constants and implementation complexity are higher. In environments where comparison sorts are sufficiently fast, the $O\big(n \log n + m \log m\big)$ approach may be acceptable. However, for worst-case sizes and tight limits, this linear-time refinement provides the strongest guarantee.

---

**[RESPONSE]**

**1. Problem Understanding**

We have two players, Northlight and Southlight. Each player owns a set
of reusable pulses. A pulse is represented by two integers: intensity
$I$ and filter $F$. A pulse $A$ with intensity $I_A$ disrupts a pulse
$B$ with filter $F_B$ if and only if $I_A > F_B$.

The game proceeds as follows:
- Northlight chooses any one of its pulses to start.
- Thereafter, replies are forced. Given a filter $F$ to answer, a side
  must choose among its pulses with $I > F$:
  - the one with the smallest $I$;
  - if several, the one with the smallest $F$;
  - if still tied, the one with the smallest input index (1-based per
    side).

Pulses are reusable; sets never change. If a side cannot answer on its
turn, it loses. If the sequence repeats forever due to forced choices,
the outcome is a stalemate.

For each test case, we must consider every possible Northlight opening.
Each opening yields a unique outcome and, if finite, a unique total
number of shown pulses (including the opening). We must report:
- how many openings are wins, draws, and losses for Northlight;
- the sum of total pulses over winning openings;
- the sum of total pulses over losing openings.


**2. Optimal Approach**

Key observations:
- Forced replies induce at most one outgoing edge per pulse: the unique
  pulse chosen by the opponent to answer a given filter or none if no
  pulse can answer.
- The entire game becomes a functional graph (each node has outdegree
  $0$ or $1$). From any starting node, the trajectory is uniquely
  determined.
- A finite path that ends at a node with no outgoing edge is a win for
  the owner of that last node. Entering a directed cycle implies an
  infinite loop, hence a draw.

Approach outline:
1) Sort each side's pulses by the tuple
   $(I, F, \text{index})$ so tie-breakers are respected.
2) Build the unique outgoing edge for every pulse in $O(n + m)$ using a
   two-pointer sweep:
   - For each Northlight filter $F$ in nondecreasing order, find the
     first Southlight pulse with $I > F$. Assign that as the next node.
   - Repeat symmetrically for Southlight filters using the Northlight
     sorted list.
3) Traverse the functional graph once with iterative 3-color marking:
   - 0 = unvisited, 1 = visiting, 2 = processed.
   - If a path reaches a node with no outgoing edge, the last node's
     owner wins. Assign distance $1$ to that last node and propagate
     distances backward along the current path, increasing by $+1$.
   - If a path hits a visiting node, a cycle is found. Mark all nodes on
     the current path as draws.
   - If a path reaches a processed node, reuse its result. If it is a
     draw, mark the current path as draw; otherwise propagate the winner
     and distances backward as above.
4) Aggregate results considering only Northlight nodes (openings) to
   produce the required counts and sums.

This yields $O(n \log n + m \log m)$ for sorting, $O(n + m)$ for edge
construction, and $O(n + m)$ for graph processing.


**3. Example Walkthrough with Optimal Algorithm**

Let's walk through Example 1 in detail:

Input:
```
1
2
9 4
5 1
2
5 8
2 6
```

1. Initial Data:
   - Northlight pulses: $(9,5)$ at index 1, $(4,1)$ at index 2
   - Southlight pulses: $(5,2)$ at index 1, $(8,6)$ at index 2

2. Sorting Phase:
   - Northlight sorted by $(I,F,\text{index})$:
     - $(4,1,2)$  // smaller intensity first
     - $(9,5,1)$
   - Southlight sorted by $(I,F,\text{index})$:
     - $(5,2,1)$  // smaller intensity first
     - $(8,6,2)$

3. Edge Construction (Two-pointer sweep):
   For each pulse, find forced reply by finding first pulse with $I > F$
   - Northlight $(9,5,1)$ → Southlight $(8,6,2)$  // only $8 > 5$
   - Northlight $(4,1,2)$ → Southlight $(5,2,1)$  // $5 > 1$, smallest intensity
   - Southlight $(8,6,2)$ → Northlight $(9,5,1)$  // only $9 > 6$
   - Southlight $(5,2,1)$ → Northlight $(4,1,2)$  // $4 > 2$, smallest intensity

4. Graph Processing:
   Starting from each Northlight opening:
   
   Opening with $(9,5)$:
   - North shows $(9,5)$
   - South must reply with $(8,6)$ (only pulse with $I > 5$)
   - North must reply with $(9,5)$ (only pulse with $I > 6$)
   - Detected cycle: $(9,5) \to (8,6) \to (9,5)$
   - Result: STALEMATE

   Opening with $(4,1)$:
   - North shows $(4,1)$
   - South must reply with $(5,2)$ (smallest $I > 1$)
   - North must reply with $(4,1)$ (smallest $I > 2$)
   - Detected cycle: $(4,1) \to (5,2) \to (4,1)$
   - Result: STALEMATE

5. Results Aggregation:
   - Wins $(W)$: 0 openings
   - Draws $(D)$: 2 openings (both cycles)
   - Losses $(L)$: 0 openings
   - Sum of winning lengths $(SW)$: 0 (no wins)
   - Sum of losing lengths $(SL)$: 0 (no losses)

Final output: `0 2 0 0 0`

**4. Code**
```python
"""
Beacon Ping-Pong solution using a functional graph and two-pointer
edge construction. For each test case, it computes how many openings
are wins/draws/losses for Northlight and the sums of pulse counts for
wins and losses.
"""

import sys


class Pulse:
    """
    Represents a pulse with its properties and global node id.

    Attributes:
        intensity (int): Intensity value I of the pulse.
        filter_value (int): Filter value F of the pulse.
        input_index (int): Original input index within its side (0-based).
        node_id (int): Global node id in the combined graph.
    """

    def __init__(self, intensity: int, filter_value: int,
                 input_index: int, node_id: int) -> None:
        self.intensity = intensity
        self.filter_value = filter_value
        self.input_index = input_index
        self.node_id = node_id


class FilterEntry:
    """
    Represents a mapping from a pulse's filter to its node id, used for
    two-pointer edge construction.

    Attributes:
        filter_value (int): Filter value F of the pulse.
        node_id (int): Global node id of the pulse.
    """

    def __init__(self, filter_value: int, node_id: int) -> None:
        self.filter_value = filter_value
        self.node_id = node_id


def assign_next_edges_for_side(own_filter_entries: list,
                               opponent_sorted_by_intensity: list,
                               next_node: list) -> None:
    """
    Assign next pointers for a side by sweeping over the opponent's
    intensity-sorted list.

    For each own filter F (in nondecreasing order), set next to the
    first opponent pulse with intensity > F, or keep -1 if none exists.

    Args:
        own_filter_entries (list): Entries sorted by filter_value
            ascending for the side whose next edges are being assigned.
        opponent_sorted_by_intensity (list): Opponent pulses sorted by
            (intensity, filter_value, input_index).
        next_node (list): Mutable array of next pointers to write into.
    """
    opponent_index = 0
    opponent_count = len(opponent_sorted_by_intensity)
    for entry in own_filter_entries:
        current_filter = entry.filter_value
        while (opponent_index < opponent_count and
               opponent_sorted_by_intensity[opponent_index].intensity
               <= current_filter):
            opponent_index += 1
        if opponent_index < opponent_count:
            next_node[entry.node_id] = (
                opponent_sorted_by_intensity[opponent_index].node_id
            )
        # Else, no valid reply; leave as -1


def compute_outcomes(next_node: list, node_owner: list) -> tuple:
    """
    Compute the outcome and pulse counts for every node in a functional
    graph using iterative 3-color traversal.

    A node's outcome is:
      - 0 for draw,
      - 1 if Northlight eventually wins,
      - 2 if Southlight eventually wins.
    The pulse count is the number of pulses shown from that node until
    termination; for draws, it is -1.

    Args:
        next_node (list): Next pointers for each node, or -1 if none.
        node_owner (list): Owner of each node: 1 for Northlight,
            2 for Southlight.

    Returns:
        tuple: (node_outcome, pulse_total_count) where both are lists.
    """
    total_nodes = len(next_node)
    visit_state = [0] * total_nodes
    node_outcome = [0] * total_nodes
    pulse_total_count = [-1] * total_nodes

    for start_node in range(total_nodes):
        if visit_state[start_node] != 0:
            continue

        current_node = start_node
        path_nodes = []

        # Follow next pointers until sink, cycle, or processed node.
        while True:
            if current_node == -1:
                break
            if visit_state[current_node] == 0:
                visit_state[current_node] = 1
                path_nodes.append(current_node)
                current_node = next_node[current_node]
                continue
            # Reached a visiting or processed node
            break

        if current_node == -1:
            # Sink reached; last displayed node wins
            last_node = path_nodes[-1]
            winning_owner = node_owner[last_node]
            distance = 1
            for node_index in range(len(path_nodes) - 1, -1, -1):
                node_id = path_nodes[node_index]
                node_outcome[node_id] = winning_owner
                pulse_total_count[node_id] = distance
                visit_state[node_id] = 2
                distance += 1
        elif visit_state[current_node] == 1:
            # Cycle detected; entire path leads to a draw
            for node_id in path_nodes:
                node_outcome[node_id] = 0
                pulse_total_count[node_id] = -1
                visit_state[node_id] = 2
        else:
            # Reached a processed node; reuse and propagate
            if node_outcome[current_node] == 0:
                for node_id in path_nodes:
                    node_outcome[node_id] = 0
                    pulse_total_count[node_id] = -1
                    visit_state[node_id] = 2
            else:
                winning_owner = node_outcome[current_node]
                distance = pulse_total_count[current_node] + 1
                for node_index in range(len(path_nodes) - 1, -1, -1):
                    node_id = path_nodes[node_index]
                    node_outcome[node_id] = winning_owner
                    pulse_total_count[node_id] = distance
                    visit_state[node_id] = 2
                    distance += 1

    return node_outcome, pulse_total_count


def solve_single_test_case(north_count: int,
                           north_intensities: list,
                           north_filters: list,
                           south_count: int,
                           south_intensities: list,
                           south_filters: list) -> tuple:
    """
    Solve one test case by building the functional graph and computing
    outcomes and pulse counts for all starting pulses.

    Args
        north_count (int): Number of Northlight pulses.
        north_intensities (list): Intensities for Northlight pulses.
        north_filters (list): Filters for Northlight pulses.
        south_count (int): Number of Southlight pulses.
        south_intensities (list): Intensities for Southlight pulses.
        south_filters (list): Filters for Southlight pulses.

    Returns:
        tuple: (wins_count, draws_count, losses_count,
                sum_winning_pulses, sum_losing_pulses)
    """
    total_nodes = north_count + south_count

    north_pulses = []
    for input_index in range(north_count):
        node_id = input_index
        north_pulses.append(
            Pulse(north_intensities[input_index],
                  north_filters[input_index],
                  input_index, node_id)
        )

    south_pulses = []
    for input_index in range(south_count):
        node_id = north_count + input_index
        south_pulses.append(
            Pulse(south_intensities[input_index],
                  south_filters[input_index],
                  input_index, node_id)
        )

    north_sorted_by_intensity = sorted(
        north_pulses,
        key=lambda pulse: (pulse.intensity,
                           pulse.filter_value,
                           pulse.input_index)
    )
    south_sorted_by_intensity = sorted(
        south_pulses,
        key=lambda pulse: (pulse.intensity,
                           pulse.filter_value,
                           pulse.input_index)
    )

    north_filters_sorted = sorted(
        (FilterEntry(pulse.filter_value, pulse.node_id)
         for pulse in north_pulses),
        key=lambda entry: entry.filter_value
    )
    south_filters_sorted = sorted(
        (FilterEntry(pulse.filter_value, pulse.node_id)
         for pulse in south_pulses),
        key=lambda entry: entry.filter_value
    )

    next_node = [-1] * total_nodes
    node_owner = [0] * total_nodes
    for node_id in range(north_count):
        node_owner[node_id] = 1
    for node_id in range(south_count):
        node_owner[north_count + node_id] = 2

    assign_next_edges_for_side(north_filters_sorted,
                               south_sorted_by_intensity,
                               next_node)
    assign_next_edges_for_side(south_filters_sorted,
                               north_sorted_by_intensity,
                               next_node)

    node_outcome, pulse_total_count = compute_outcomes(next_node,
                                                       node_owner)

    wins_count = 0
    draws_count = 0
    losses_count = 0
    sum_winning_pulses = 0
    sum_losing_pulses = 0

    for node_id in range(north_count):
        if node_outcome[node_id] == 1:
            wins_count += 1
            sum_winning_pulses += pulse_total_count[node_id]
        elif node_outcome[node_id] == 2:
            losses_count += 1
            sum_losing_pulses += pulse_total_count[node_id]
        else:
            draws_count += 1

    return (wins_count, draws_count, losses_count,
            sum_winning_pulses, sum_losing_pulses)


def read_int_list(tokens_iter, count: int) -> list:
    """
    Read a fixed number of integers from a token iterator.

    Args:
        tokens_iter: Iterator over input tokens.
        count (int): Number of integers to read.

    Returns:
        list: List of read integers.
    """
    result = []
    for item_index in range(count):
        result.append(int(next(tokens_iter)))
    return result


def main() -> None:
    """
    Main entry point: reads input, processes each test case, and writes
    the results to standard output.
    """
    tokens_iter = iter(sys.stdin.buffer.read().split())
    test_case_count = int(next(tokens_iter))
    output_lines = []

    for test_index in range(test_case_count):
        north_count = int(next(tokens_iter))
        north_intensities = read_int_list(tokens_iter, north_count)
        north_filters = read_int_list(tokens_iter, north_count)

        south_count = int(next(tokens_iter))
        south_intensities = read_int_list(tokens_iter, south_count)
        south_filters = read_int_list(tokens_iter, south_count)

        (wins_count, draws_count, losses_count,
         sum_winning_pulses, sum_losing_pulses) = solve_single_test_case(
            north_count, north_intensities, north_filters,
            south_count, south_intensities, south_filters
        )

        output_lines.append(
            f"{wins_count} {draws_count} {losses_count} "
            f"{sum_winning_pulses} {sum_losing_pulses}"
        )

    sys.stdout.write("\n".join(output_lines))


if __name__ == "__main__":
    main()
```

**4. Code Explanation**

- We represent each pulse as a Pulse object with fields for intensity,
  filter, original index, and global node id. This allows us to sort
  deterministically by $(I, F, \text{index})$.

- We build two sorted lists for each side: by intensity (for finding the
  minimal admissible reply) and by filter (for sweeping queries in
  nondecreasing order).

- Edge construction uses a two-pointer sweep:
  - For Northlight pulses sorted by filter, we keep a pointer in the
    Southlight list sorted by intensity. For each filter $F$, we advance
    the pointer until the first pulse with $I > F$ and set the next
    pointer accordingly. This respects the tie-breakers due to the full
    $(I, F, \text{index})$ ordering.
  - We repeat symmetrically to set Southlight edges.

- After building the functional graph (array next_node), we perform a
  single pass over all nodes using a 3-color visitation scheme:
  - If we reach a sink (no outgoing edge), the last mover wins. We set
    its pulse count to $1$ and propagate increasing counts back along
    the path.
  - If we encounter a cycle (revisiting a visiting node), we mark all
    nodes on the current path as draws (infinite loop).
  - If we reach an already processed node, we reuse its result. If it is
    a draw, the current path is a draw; otherwise, we propagate the same
    winner and distance plus one per step.

- Finally, we aggregate over Northlight nodes to compute:
  $W$, $D$, $L$, $SW$, and $SL$ and print them.

Example walkthrough (brief):
- If Northlight opens with a pulse whose filter exceeds all opponent
  intensities, the opponent has no reply and the edge is absent. The
  path ends immediately (count $= 1$) and Northlight wins.
- If a path enters a directed cycle due to forced replies, we classify
  all nodes that lead to this cycle as draws and do not count a finite
  pulse total for them.


**5. Time and Space Complexity**

Let $n$ be the number of Northlight pulses and $m$ be the number of
Southlight pulses.

- Sorting by $(I, F, \text{index})$:
  $O(n \log n + m \log m)$.
- Two-pointer edge construction:
  $O(n + m)$.
- Functional graph classification (3-color traversal):
  $O(n + m)$.
- Aggregation:
  $O(n)$.

Total time per test case:
$$
O(n \log n + m \log m) + O(n + m).
$$

Space complexity: Arrays and lists proportional to the number of pulses,
hence $O(n + m)$.


**6. Conclusion**

By modeling forced replies as a functional graph and constructing the
unique outgoing edge for each pulse using a two-pointer sweep over
intensity-sorted lists, we reduce the problem to a single global graph
traversal. The 3-color traversal detects sinks (wins/losses) and cycles
(draws), while backward propagation counts the exact number of pulses
for finite games. The solution runs in $O(n \log n + m \log m)$ time and
$O(n + m)$ space per test case, meeting the problem's constraints.